/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/build/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./assets/js/vue.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./assets/js/vue.js":
/*!**************************!*\
  !*** ./assets/js/vue.js ***!
  \**************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, setImmediate) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * Vue.js v2.5.16
 * (c) 2014-2018 Evan You
 * Released under the MIT License.
 */
(function (global, factory) {
  ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : global.Vue = factory();
})(this, function () {
  'use strict';

  /*  */

  var emptyObject = Object.freeze({});

  // these helpers produces better vm code in JS engines due to their
  // explicitness and function inlining
  function isUndef(v) {
    return v === undefined || v === null;
  }

  function isDef(v) {
    return v !== undefined && v !== null;
  }

  function isTrue(v) {
    return v === true;
  }

  function isFalse(v) {
    return v === false;
  }

  /**
   * Check if value is primitive
   */
  function isPrimitive(value) {
    return typeof value === 'string' || typeof value === 'number' ||
    // $flow-disable-line
    (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'symbol' || typeof value === 'boolean';
  }

  /**
   * Quick object check - this is primarily used to tell
   * Objects from primitive values when we know the value
   * is a JSON-compliant type.
   */
  function isObject(obj) {
    return obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';
  }

  /**
   * Get the raw type string of a value e.g. [object Object]
   */
  var _toString = Object.prototype.toString;

  function toRawType(value) {
    return _toString.call(value).slice(8, -1);
  }

  /**
   * Strict object type check. Only returns true
   * for plain JavaScript objects.
   */
  function isPlainObject(obj) {
    return _toString.call(obj) === '[object Object]';
  }

  function isRegExp(v) {
    return _toString.call(v) === '[object RegExp]';
  }

  /**
   * Check if val is a valid array index.
   */
  function isValidArrayIndex(val) {
    var n = parseFloat(String(val));
    return n >= 0 && Math.floor(n) === n && isFinite(val);
  }

  /**
   * Convert a value to a string that is actually rendered.
   */
  function toString(val) {
    return val == null ? '' : (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' ? JSON.stringify(val, null, 2) : String(val);
  }

  /**
   * Convert a input value to a number for persistence.
   * If the conversion fails, return original string.
   */
  function toNumber(val) {
    var n = parseFloat(val);
    return isNaN(n) ? val : n;
  }

  /**
   * Make a map and return a function for checking if a key
   * is in that map.
   */
  function makeMap(str, expectsLowerCase) {
    var map = Object.create(null);
    var list = str.split(',');
    for (var i = 0; i < list.length; i++) {
      map[list[i]] = true;
    }
    return expectsLowerCase ? function (val) {
      return map[val.toLowerCase()];
    } : function (val) {
      return map[val];
    };
  }

  /**
   * Check if a tag is a built-in tag.
   */
  var isBuiltInTag = makeMap('slot,component', true);

  /**
   * Check if a attribute is a reserved attribute.
   */
  var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');

  /**
   * Remove an item from an array
   */
  function remove(arr, item) {
    if (arr.length) {
      var index = arr.indexOf(item);
      if (index > -1) {
        return arr.splice(index, 1);
      }
    }
  }

  /**
   * Check whether the object has the property.
   */
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  function hasOwn(obj, key) {
    return hasOwnProperty.call(obj, key);
  }

  /**
   * Create a cached version of a pure function.
   */
  function cached(fn) {
    var cache = Object.create(null);
    return function cachedFn(str) {
      var hit = cache[str];
      return hit || (cache[str] = fn(str));
    };
  }

  /**
   * Camelize a hyphen-delimited string.
   */
  var camelizeRE = /-(\w)/g;
  var camelize = cached(function (str) {
    return str.replace(camelizeRE, function (_, c) {
      return c ? c.toUpperCase() : '';
    });
  });

  /**
   * Capitalize a string.
   */
  var capitalize = cached(function (str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  });

  /**
   * Hyphenate a camelCase string.
   */
  var hyphenateRE = /\B([A-Z])/g;
  var hyphenate = cached(function (str) {
    return str.replace(hyphenateRE, '-$1').toLowerCase();
  });

  /**
   * Simple bind polyfill for environments that do not support it... e.g.
   * PhantomJS 1.x. Technically we don't need this anymore since native bind is
   * now more performant in most browsers, but removing it would be breaking for
   * code that was able to run in PhantomJS 1.x, so this must be kept for
   * backwards compatibility.
   */

  /* istanbul ignore next */
  function polyfillBind(fn, ctx) {
    function boundFn(a) {
      var l = arguments.length;
      return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
    }

    boundFn._length = fn.length;
    return boundFn;
  }

  function nativeBind(fn, ctx) {
    return fn.bind(ctx);
  }

  var bind = Function.prototype.bind ? nativeBind : polyfillBind;

  /**
   * Convert an Array-like object to a real Array.
   */
  function toArray(list, start) {
    start = start || 0;
    var i = list.length - start;
    var ret = new Array(i);
    while (i--) {
      ret[i] = list[i + start];
    }
    return ret;
  }

  /**
   * Mix properties into target object.
   */
  function extend(to, _from) {
    for (var key in _from) {
      to[key] = _from[key];
    }
    return to;
  }

  /**
   * Merge an Array of Objects into a single Object.
   */
  function toObject(arr) {
    var res = {};
    for (var i = 0; i < arr.length; i++) {
      if (arr[i]) {
        extend(res, arr[i]);
      }
    }
    return res;
  }

  /**
   * Perform no operation.
   * Stubbing args to make Flow happy without leaving useless transpiled code
   * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)
   */
  function noop(a, b, c) {}

  /**
   * Always return false.
   */
  var no = function no(a, b, c) {
    return false;
  };

  /**
   * Return same value
   */
  var identity = function identity(_) {
    return _;
  };

  /**
   * Generate a static keys string from compiler modules.
   */
  function genStaticKeys(modules) {
    return modules.reduce(function (keys, m) {
      return keys.concat(m.staticKeys || []);
    }, []).join(',');
  }

  /**
   * Check if two values are loosely equal - that is,
   * if they are plain objects, do they have the same shape?
   */
  function looseEqual(a, b) {
    if (a === b) {
      return true;
    }
    var isObjectA = isObject(a);
    var isObjectB = isObject(b);
    if (isObjectA && isObjectB) {
      try {
        var isArrayA = Array.isArray(a);
        var isArrayB = Array.isArray(b);
        if (isArrayA && isArrayB) {
          return a.length === b.length && a.every(function (e, i) {
            return looseEqual(e, b[i]);
          });
        } else if (!isArrayA && !isArrayB) {
          var keysA = Object.keys(a);
          var keysB = Object.keys(b);
          return keysA.length === keysB.length && keysA.every(function (key) {
            return looseEqual(a[key], b[key]);
          });
        } else {
          /* istanbul ignore next */
          return false;
        }
      } catch (e) {
        /* istanbul ignore next */
        return false;
      }
    } else if (!isObjectA && !isObjectB) {
      return String(a) === String(b);
    } else {
      return false;
    }
  }

  function looseIndexOf(arr, val) {
    for (var i = 0; i < arr.length; i++) {
      if (looseEqual(arr[i], val)) {
        return i;
      }
    }
    return -1;
  }

  /**
   * Ensure a function is called only once.
   */
  function once(fn) {
    var called = false;
    return function () {
      if (!called) {
        called = true;
        fn.apply(this, arguments);
      }
    };
  }

  var SSR_ATTR = 'data-server-rendered';

  var ASSET_TYPES = ['component', 'directive', 'filter'];

  var LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated', 'errorCaptured'];

  /*  */

  var config = {
    /**
     * Option merge strategies (used in core/util/options)
     */
    // $flow-disable-line
    optionMergeStrategies: Object.create(null),

    /**
     * Whether to suppress warnings.
     */
    silent: false,

    /**
     * Show production mode tip message on boot?
     */
    productionTip: "development" !== 'production',

    /**
     * Whether to enable devtools
     */
    devtools: "development" !== 'production',

    /**
     * Whether to record perf
     */
    performance: false,

    /**
     * Error handler for watcher errors
     */
    errorHandler: null,

    /**
     * Warn handler for watcher warns
     */
    warnHandler: null,

    /**
     * Ignore certain custom elements
     */
    ignoredElements: [],

    /**
     * Custom user key aliases for v-on
     */
    // $flow-disable-line
    keyCodes: Object.create(null),

    /**
     * Check if a tag is reserved so that it cannot be registered as a
     * component. This is platform-dependent and may be overwritten.
     */
    isReservedTag: no,

    /**
     * Check if an attribute is reserved so that it cannot be used as a component
     * prop. This is platform-dependent and may be overwritten.
     */
    isReservedAttr: no,

    /**
     * Check if a tag is an unknown element.
     * Platform-dependent.
     */
    isUnknownElement: no,

    /**
     * Get the namespace of an element
     */
    getTagNamespace: noop,

    /**
     * Parse the real tag name for the specific platform.
     */
    parsePlatformTagName: identity,

    /**
     * Check if an attribute must be bound using property, e.g. value
     * Platform-dependent.
     */
    mustUseProp: no,

    /**
     * Exposed for legacy reasons
     */
    _lifecycleHooks: LIFECYCLE_HOOKS
  };

  /*  */

  /**
   * Check if a string starts with $ or _
   */
  function isReserved(str) {
    var c = (str + '').charCodeAt(0);
    return c === 0x24 || c === 0x5F;
  }

  /**
   * Define a property.
   */
  function def(obj, key, val, enumerable) {
    Object.defineProperty(obj, key, {
      value: val,
      enumerable: !!enumerable,
      writable: true,
      configurable: true
    });
  }

  /**
   * Parse simple path.
   */
  var bailRE = /[^\w.$]/;
  function parsePath(path) {
    if (bailRE.test(path)) {
      return;
    }
    var segments = path.split('.');
    return function (obj) {
      for (var i = 0; i < segments.length; i++) {
        if (!obj) {
          return;
        }
        obj = obj[segments[i]];
      }
      return obj;
    };
  }

  /*  */

  // can we use __proto__?
  var hasProto = '__proto__' in {};

  // Browser environment sniffing
  var inBrowser = typeof window !== 'undefined';
  var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
  var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
  var UA = inBrowser && window.navigator.userAgent.toLowerCase();
  var isIE = UA && /msie|trident/.test(UA);
  var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
  var isEdge = UA && UA.indexOf('edge/') > 0;
  var isAndroid = UA && UA.indexOf('android') > 0 || weexPlatform === 'android';
  var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA) || weexPlatform === 'ios';
  var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;

  // Firefox has a "watch" function on Object.prototype...
  var nativeWatch = {}.watch;

  var supportsPassive = false;
  if (inBrowser) {
    try {
      var opts = {};
      Object.defineProperty(opts, 'passive', {
        get: function get() {
          /* istanbul ignore next */
          supportsPassive = true;
        }
      }); // https://github.com/facebook/flow/issues/285
      window.addEventListener('test-passive', null, opts);
    } catch (e) {}
  }

  // this needs to be lazy-evaled because vue may be required before
  // vue-server-renderer can set VUE_ENV
  var _isServer;
  var isServerRendering = function isServerRendering() {
    if (_isServer === undefined) {
      /* istanbul ignore if */
      if (!inBrowser && !inWeex && typeof global !== 'undefined') {
        // detect presence of vue-server-renderer and avoid
        // Webpack shimming the process
        _isServer = global['process'].env.VUE_ENV === 'server';
      } else {
        _isServer = false;
      }
    }
    return _isServer;
  };

  // detect devtools
  var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

  /* istanbul ignore next */
  function isNative(Ctor) {
    return typeof Ctor === 'function' && /native code/.test(Ctor.toString());
  }

  var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

  var _Set;
  /* istanbul ignore if */ // $flow-disable-line
  if (typeof Set !== 'undefined' && isNative(Set)) {
    // use native Set when available.
    _Set = Set;
  } else {
    // a non-standard Set polyfill that only works with primitive keys.
    _Set = function () {
      function Set() {
        this.set = Object.create(null);
      }
      Set.prototype.has = function has(key) {
        return this.set[key] === true;
      };
      Set.prototype.add = function add(key) {
        this.set[key] = true;
      };
      Set.prototype.clear = function clear() {
        this.set = Object.create(null);
      };

      return Set;
    }();
  }

  /*  */

  var warn = noop;
  var tip = noop;
  var generateComponentTrace = noop; // work around flow check
  var formatComponentName = noop;

  {
    var hasConsole = typeof console !== 'undefined';
    var classifyRE = /(?:^|[-_])(\w)/g;
    var classify = function classify(str) {
      return str.replace(classifyRE, function (c) {
        return c.toUpperCase();
      }).replace(/[-_]/g, '');
    };

    warn = function warn(msg, vm) {
      var trace = vm ? generateComponentTrace(vm) : '';

      if (config.warnHandler) {
        config.warnHandler.call(null, msg, vm, trace);
      } else if (hasConsole && !config.silent) {
        console.error("[Vue warn]: " + msg + trace);
      }
    };

    tip = function tip(msg, vm) {
      if (hasConsole && !config.silent) {
        console.warn("[Vue tip]: " + msg + (vm ? generateComponentTrace(vm) : ''));
      }
    };

    formatComponentName = function formatComponentName(vm, includeFile) {
      if (vm.$root === vm) {
        return '<Root>';
      }
      var options = typeof vm === 'function' && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm || {};
      var name = options.name || options._componentTag;
      var file = options.__file;
      if (!name && file) {
        var match = file.match(/([^/\\]+)\.vue$/);
        name = match && match[1];
      }

      return (name ? "<" + classify(name) + ">" : "<Anonymous>") + (file && includeFile !== false ? " at " + file : '');
    };

    var repeat = function repeat(str, n) {
      var res = '';
      while (n) {
        if (n % 2 === 1) {
          res += str;
        }
        if (n > 1) {
          str += str;
        }
        n >>= 1;
      }
      return res;
    };

    generateComponentTrace = function generateComponentTrace(vm) {
      if (vm._isVue && vm.$parent) {
        var tree = [];
        var currentRecursiveSequence = 0;
        while (vm) {
          if (tree.length > 0) {
            var last = tree[tree.length - 1];
            if (last.constructor === vm.constructor) {
              currentRecursiveSequence++;
              vm = vm.$parent;
              continue;
            } else if (currentRecursiveSequence > 0) {
              tree[tree.length - 1] = [last, currentRecursiveSequence];
              currentRecursiveSequence = 0;
            }
          }
          tree.push(vm);
          vm = vm.$parent;
        }
        return '\n\nfound in\n\n' + tree.map(function (vm, i) {
          return "" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + "... (" + vm[1] + " recursive calls)" : formatComponentName(vm));
        }).join('\n');
      } else {
        return "\n\n(found in " + formatComponentName(vm) + ")";
      }
    };
  }

  /*  */

  var uid = 0;

  /**
   * A dep is an observable that can have multiple
   * directives subscribing to it.
   */
  var Dep = function Dep() {
    this.id = uid++;
    this.subs = [];
  };

  Dep.prototype.addSub = function addSub(sub) {
    this.subs.push(sub);
  };

  Dep.prototype.removeSub = function removeSub(sub) {
    remove(this.subs, sub);
  };

  Dep.prototype.depend = function depend() {
    if (Dep.target) {
      Dep.target.addDep(this);
    }
  };

  Dep.prototype.notify = function notify() {
    // stabilize the subscriber list first
    var subs = this.subs.slice();
    for (var i = 0, l = subs.length; i < l; i++) {
      subs[i].update();
    }
  };

  // the current target watcher being evaluated.
  // this is globally unique because there could be only one
  // watcher being evaluated at any time.
  Dep.target = null;
  var targetStack = [];

  function pushTarget(_target) {
    if (Dep.target) {
      targetStack.push(Dep.target);
    }
    Dep.target = _target;
  }

  function popTarget() {
    Dep.target = targetStack.pop();
  }

  /*  */

  var VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
    this.tag = tag;
    this.data = data;
    this.children = children;
    this.text = text;
    this.elm = elm;
    this.ns = undefined;
    this.context = context;
    this.fnContext = undefined;
    this.fnOptions = undefined;
    this.fnScopeId = undefined;
    this.key = data && data.key;
    this.componentOptions = componentOptions;
    this.componentInstance = undefined;
    this.parent = undefined;
    this.raw = false;
    this.isStatic = false;
    this.isRootInsert = true;
    this.isComment = false;
    this.isCloned = false;
    this.isOnce = false;
    this.asyncFactory = asyncFactory;
    this.asyncMeta = undefined;
    this.isAsyncPlaceholder = false;
  };

  var prototypeAccessors = { child: { configurable: true } };

  // DEPRECATED: alias for componentInstance for backwards compat.
  /* istanbul ignore next */
  prototypeAccessors.child.get = function () {
    return this.componentInstance;
  };

  Object.defineProperties(VNode.prototype, prototypeAccessors);

  var createEmptyVNode = function createEmptyVNode(text) {
    if (text === void 0) text = '';

    var node = new VNode();
    node.text = text;
    node.isComment = true;
    return node;
  };

  function createTextVNode(val) {
    return new VNode(undefined, undefined, undefined, String(val));
  }

  // optimized shallow clone
  // used for static nodes and slot nodes because they may be reused across
  // multiple renders, cloning them avoids errors when DOM manipulations rely
  // on their elm reference.
  function cloneVNode(vnode) {
    var cloned = new VNode(vnode.tag, vnode.data, vnode.children, vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);
    cloned.ns = vnode.ns;
    cloned.isStatic = vnode.isStatic;
    cloned.key = vnode.key;
    cloned.isComment = vnode.isComment;
    cloned.fnContext = vnode.fnContext;
    cloned.fnOptions = vnode.fnOptions;
    cloned.fnScopeId = vnode.fnScopeId;
    cloned.isCloned = true;
    return cloned;
  }

  /*
   * not type checking this file because flow doesn't play well with
   * dynamically accessing methods on Array prototype
   */

  var arrayProto = Array.prototype;
  var arrayMethods = Object.create(arrayProto);

  var methodsToPatch = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];

  /**
   * Intercept mutating methods and emit events
   */
  methodsToPatch.forEach(function (method) {
    // cache original method
    var original = arrayProto[method];
    def(arrayMethods, method, function mutator() {
      var args = [],
          len = arguments.length;
      while (len--) {
        args[len] = arguments[len];
      }var result = original.apply(this, args);
      var ob = this.__ob__;
      var inserted;
      switch (method) {
        case 'push':
        case 'unshift':
          inserted = args;
          break;
        case 'splice':
          inserted = args.slice(2);
          break;
      }
      if (inserted) {
        ob.observeArray(inserted);
      }
      // notify change
      ob.dep.notify();
      return result;
    });
  });

  /*  */

  var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

  /**
   * In some cases we may want to disable observation inside a component's
   * update computation.
   */
  var shouldObserve = true;

  function toggleObserving(value) {
    shouldObserve = value;
  }

  /**
   * Observer class that is attached to each observed
   * object. Once attached, the observer converts the target
   * object's property keys into getter/setters that
   * collect dependencies and dispatch updates.
   */
  var Observer = function Observer(value) {
    this.value = value;
    this.dep = new Dep();
    this.vmCount = 0;
    def(value, '__ob__', this);
    if (Array.isArray(value)) {
      var augment = hasProto ? protoAugment : copyAugment;
      augment(value, arrayMethods, arrayKeys);
      this.observeArray(value);
    } else {
      this.walk(value);
    }
  };

  /**
   * Walk through each property and convert them into
   * getter/setters. This method should only be called when
   * value type is Object.
   */
  Observer.prototype.walk = function walk(obj) {
    var keys = Object.keys(obj);
    for (var i = 0; i < keys.length; i++) {
      defineReactive(obj, keys[i]);
    }
  };

  /**
   * Observe a list of Array items.
   */
  Observer.prototype.observeArray = function observeArray(items) {
    for (var i = 0, l = items.length; i < l; i++) {
      observe(items[i]);
    }
  };

  // helpers

  /**
   * Augment an target Object or Array by intercepting
   * the prototype chain using __proto__
   */
  function protoAugment(target, src, keys) {
    /* eslint-disable no-proto */
    target.__proto__ = src;
    /* eslint-enable no-proto */
  }

  /**
   * Augment an target Object or Array by defining
   * hidden properties.
   */
  /* istanbul ignore next */
  function copyAugment(target, src, keys) {
    for (var i = 0, l = keys.length; i < l; i++) {
      var key = keys[i];
      def(target, key, src[key]);
    }
  }

  /**
   * Attempt to create an observer instance for a value,
   * returns the new observer if successfully observed,
   * or the existing observer if the value already has one.
   */
  function observe(value, asRootData) {
    if (!isObject(value) || value instanceof VNode) {
      return;
    }
    var ob;
    if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
      ob = value.__ob__;
    } else if (shouldObserve && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
      ob = new Observer(value);
    }
    if (asRootData && ob) {
      ob.vmCount++;
    }
    return ob;
  }

  /**
   * Define a reactive property on an Object.
   */
  function defineReactive(obj, key, val, customSetter, shallow) {
    var dep = new Dep();

    var property = Object.getOwnPropertyDescriptor(obj, key);
    if (property && property.configurable === false) {
      return;
    }

    // cater for pre-defined getter/setters
    var getter = property && property.get;
    if (!getter && arguments.length === 2) {
      val = obj[key];
    }
    var setter = property && property.set;

    var childOb = !shallow && observe(val);
    Object.defineProperty(obj, key, {
      enumerable: true,
      configurable: true,
      get: function reactiveGetter() {
        var value = getter ? getter.call(obj) : val;
        if (Dep.target) {
          dep.depend();
          if (childOb) {
            childOb.dep.depend();
            if (Array.isArray(value)) {
              dependArray(value);
            }
          }
        }
        return value;
      },
      set: function reactiveSetter(newVal) {
        var value = getter ? getter.call(obj) : val;
        /* eslint-disable no-self-compare */
        if (newVal === value || newVal !== newVal && value !== value) {
          return;
        }
        /* eslint-enable no-self-compare */
        if ("development" !== 'production' && customSetter) {
          customSetter();
        }
        if (setter) {
          setter.call(obj, newVal);
        } else {
          val = newVal;
        }
        childOb = !shallow && observe(newVal);
        dep.notify();
      }
    });
  }

  /**
   * Set a property on an object. Adds the new property and
   * triggers change notification if the property doesn't
   * already exist.
   */
  function set(target, key, val) {
    if ("development" !== 'production' && (isUndef(target) || isPrimitive(target))) {
      warn("Cannot set reactive property on undefined, null, or primitive value: " + target);
    }
    if (Array.isArray(target) && isValidArrayIndex(key)) {
      target.length = Math.max(target.length, key);
      target.splice(key, 1, val);
      return val;
    }
    if (key in target && !(key in Object.prototype)) {
      target[key] = val;
      return val;
    }
    var ob = target.__ob__;
    if (target._isVue || ob && ob.vmCount) {
      "development" !== 'production' && warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');
      return val;
    }
    if (!ob) {
      target[key] = val;
      return val;
    }
    defineReactive(ob.value, key, val);
    ob.dep.notify();
    return val;
  }

  /**
   * Delete a property and trigger change if necessary.
   */
  function del(target, key) {
    if ("development" !== 'production' && (isUndef(target) || isPrimitive(target))) {
      warn("Cannot delete reactive property on undefined, null, or primitive value: " + target);
    }
    if (Array.isArray(target) && isValidArrayIndex(key)) {
      target.splice(key, 1);
      return;
    }
    var ob = target.__ob__;
    if (target._isVue || ob && ob.vmCount) {
      "development" !== 'production' && warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');
      return;
    }
    if (!hasOwn(target, key)) {
      return;
    }
    delete target[key];
    if (!ob) {
      return;
    }
    ob.dep.notify();
  }

  /**
   * Collect dependencies on array elements when the array is touched, since
   * we cannot intercept array element access like property getters.
   */
  function dependArray(value) {
    for (var e = void 0, i = 0, l = value.length; i < l; i++) {
      e = value[i];
      e && e.__ob__ && e.__ob__.dep.depend();
      if (Array.isArray(e)) {
        dependArray(e);
      }
    }
  }

  /*  */

  /**
   * Option overwriting strategies are functions that handle
   * how to merge a parent option value and a child option
   * value into the final value.
   */
  var strats = config.optionMergeStrategies;

  /**
   * Options with restrictions
   */
  {
    strats.el = strats.propsData = function (parent, child, vm, key) {
      if (!vm) {
        warn("option \"" + key + "\" can only be used during instance " + 'creation with the `new` keyword.');
      }
      return defaultStrat(parent, child);
    };
  }

  /**
   * Helper that recursively merges two data objects together.
   */
  function mergeData(to, from) {
    if (!from) {
      return to;
    }
    var key, toVal, fromVal;
    var keys = Object.keys(from);
    for (var i = 0; i < keys.length; i++) {
      key = keys[i];
      toVal = to[key];
      fromVal = from[key];
      if (!hasOwn(to, key)) {
        set(to, key, fromVal);
      } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {
        mergeData(toVal, fromVal);
      }
    }
    return to;
  }

  /**
   * Data
   */
  function mergeDataOrFn(parentVal, childVal, vm) {
    if (!vm) {
      // in a Vue.extend merge, both should be functions
      if (!childVal) {
        return parentVal;
      }
      if (!parentVal) {
        return childVal;
      }
      // when parentVal & childVal are both present,
      // we need to return a function that returns the
      // merged result of both functions... no need to
      // check if parentVal is a function here because
      // it has to be a function to pass previous merges.
      return function mergedDataFn() {
        return mergeData(typeof childVal === 'function' ? childVal.call(this, this) : childVal, typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal);
      };
    } else {
      return function mergedInstanceDataFn() {
        // instance merge
        var instanceData = typeof childVal === 'function' ? childVal.call(vm, vm) : childVal;
        var defaultData = typeof parentVal === 'function' ? parentVal.call(vm, vm) : parentVal;
        if (instanceData) {
          return mergeData(instanceData, defaultData);
        } else {
          return defaultData;
        }
      };
    }
  }

  strats.data = function (parentVal, childVal, vm) {
    if (!vm) {
      if (childVal && typeof childVal !== 'function') {
        "development" !== 'production' && warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);

        return parentVal;
      }
      return mergeDataOrFn(parentVal, childVal);
    }

    return mergeDataOrFn(parentVal, childVal, vm);
  };

  /**
   * Hooks and props are merged as arrays.
   */
  function mergeHook(parentVal, childVal) {
    return childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;
  }

  LIFECYCLE_HOOKS.forEach(function (hook) {
    strats[hook] = mergeHook;
  });

  /**
   * Assets
   *
   * When a vm is present (instance creation), we need to do
   * a three-way merge between constructor options, instance
   * options and parent options.
   */
  function mergeAssets(parentVal, childVal, vm, key) {
    var res = Object.create(parentVal || null);
    if (childVal) {
      "development" !== 'production' && assertObjectType(key, childVal, vm);
      return extend(res, childVal);
    } else {
      return res;
    }
  }

  ASSET_TYPES.forEach(function (type) {
    strats[type + 's'] = mergeAssets;
  });

  /**
   * Watchers.
   *
   * Watchers hashes should not overwrite one
   * another, so we merge them as arrays.
   */
  strats.watch = function (parentVal, childVal, vm, key) {
    // work around Firefox's Object.prototype.watch...
    if (parentVal === nativeWatch) {
      parentVal = undefined;
    }
    if (childVal === nativeWatch) {
      childVal = undefined;
    }
    /* istanbul ignore if */
    if (!childVal) {
      return Object.create(parentVal || null);
    }
    {
      assertObjectType(key, childVal, vm);
    }
    if (!parentVal) {
      return childVal;
    }
    var ret = {};
    extend(ret, parentVal);
    for (var key$1 in childVal) {
      var parent = ret[key$1];
      var child = childVal[key$1];
      if (parent && !Array.isArray(parent)) {
        parent = [parent];
      }
      ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];
    }
    return ret;
  };

  /**
   * Other object hashes.
   */
  strats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal, vm, key) {
    if (childVal && "development" !== 'production') {
      assertObjectType(key, childVal, vm);
    }
    if (!parentVal) {
      return childVal;
    }
    var ret = Object.create(null);
    extend(ret, parentVal);
    if (childVal) {
      extend(ret, childVal);
    }
    return ret;
  };
  strats.provide = mergeDataOrFn;

  /**
   * Default strategy.
   */
  var defaultStrat = function defaultStrat(parentVal, childVal) {
    return childVal === undefined ? parentVal : childVal;
  };

  /**
   * Validate component names
   */
  function checkComponents(options) {
    for (var key in options.components) {
      validateComponentName(key);
    }
  }

  function validateComponentName(name) {
    if (!/^[a-zA-Z][\w-]*$/.test(name)) {
      warn('Invalid component name: "' + name + '". Component names ' + 'can only contain alphanumeric characters and the hyphen, ' + 'and must start with a letter.');
    }
    if (isBuiltInTag(name) || config.isReservedTag(name)) {
      warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + name);
    }
  }

  /**
   * Ensure all props option syntax are normalized into the
   * Object-based format.
   */
  function normalizeProps(options, vm) {
    var props = options.props;
    if (!props) {
      return;
    }
    var res = {};
    var i, val, name;
    if (Array.isArray(props)) {
      i = props.length;
      while (i--) {
        val = props[i];
        if (typeof val === 'string') {
          name = camelize(val);
          res[name] = { type: null };
        } else {
          warn('props must be strings when using array syntax.');
        }
      }
    } else if (isPlainObject(props)) {
      for (var key in props) {
        val = props[key];
        name = camelize(key);
        res[name] = isPlainObject(val) ? val : { type: val };
      }
    } else {
      warn("Invalid value for option \"props\": expected an Array or an Object, " + "but got " + toRawType(props) + ".", vm);
    }
    options.props = res;
  }

  /**
   * Normalize all injections into Object-based format
   */
  function normalizeInject(options, vm) {
    var inject = options.inject;
    if (!inject) {
      return;
    }
    var normalized = options.inject = {};
    if (Array.isArray(inject)) {
      for (var i = 0; i < inject.length; i++) {
        normalized[inject[i]] = { from: inject[i] };
      }
    } else if (isPlainObject(inject)) {
      for (var key in inject) {
        var val = inject[key];
        normalized[key] = isPlainObject(val) ? extend({ from: key }, val) : { from: val };
      }
    } else {
      warn("Invalid value for option \"inject\": expected an Array or an Object, " + "but got " + toRawType(inject) + ".", vm);
    }
  }

  /**
   * Normalize raw function directives into object format.
   */
  function normalizeDirectives(options) {
    var dirs = options.directives;
    if (dirs) {
      for (var key in dirs) {
        var def = dirs[key];
        if (typeof def === 'function') {
          dirs[key] = { bind: def, update: def };
        }
      }
    }
  }

  function assertObjectType(name, value, vm) {
    if (!isPlainObject(value)) {
      warn("Invalid value for option \"" + name + "\": expected an Object, " + "but got " + toRawType(value) + ".", vm);
    }
  }

  /**
   * Merge two option objects into a new one.
   * Core utility used in both instantiation and inheritance.
   */
  function mergeOptions(parent, child, vm) {
    {
      checkComponents(child);
    }

    if (typeof child === 'function') {
      child = child.options;
    }

    normalizeProps(child, vm);
    normalizeInject(child, vm);
    normalizeDirectives(child);
    var extendsFrom = child.extends;
    if (extendsFrom) {
      parent = mergeOptions(parent, extendsFrom, vm);
    }
    if (child.mixins) {
      for (var i = 0, l = child.mixins.length; i < l; i++) {
        parent = mergeOptions(parent, child.mixins[i], vm);
      }
    }
    var options = {};
    var key;
    for (key in parent) {
      mergeField(key);
    }
    for (key in child) {
      if (!hasOwn(parent, key)) {
        mergeField(key);
      }
    }
    function mergeField(key) {
      var strat = strats[key] || defaultStrat;
      options[key] = strat(parent[key], child[key], vm, key);
    }
    return options;
  }

  /**
   * Resolve an asset.
   * This function is used because child instances need access
   * to assets defined in its ancestor chain.
   */
  function resolveAsset(options, type, id, warnMissing) {
    /* istanbul ignore if */
    if (typeof id !== 'string') {
      return;
    }
    var assets = options[type];
    // check local registration variations first
    if (hasOwn(assets, id)) {
      return assets[id];
    }
    var camelizedId = camelize(id);
    if (hasOwn(assets, camelizedId)) {
      return assets[camelizedId];
    }
    var PascalCaseId = capitalize(camelizedId);
    if (hasOwn(assets, PascalCaseId)) {
      return assets[PascalCaseId];
    }
    // fallback to prototype chain
    var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
    if ("development" !== 'production' && warnMissing && !res) {
      warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);
    }
    return res;
  }

  /*  */

  function validateProp(key, propOptions, propsData, vm) {
    var prop = propOptions[key];
    var absent = !hasOwn(propsData, key);
    var value = propsData[key];
    // boolean casting
    var booleanIndex = getTypeIndex(Boolean, prop.type);
    if (booleanIndex > -1) {
      if (absent && !hasOwn(prop, 'default')) {
        value = false;
      } else if (value === '' || value === hyphenate(key)) {
        // only cast empty string / same name to boolean if
        // boolean has higher priority
        var stringIndex = getTypeIndex(String, prop.type);
        if (stringIndex < 0 || booleanIndex < stringIndex) {
          value = true;
        }
      }
    }
    // check default value
    if (value === undefined) {
      value = getPropDefaultValue(vm, prop, key);
      // since the default value is a fresh copy,
      // make sure to observe it.
      var prevShouldObserve = shouldObserve;
      toggleObserving(true);
      observe(value);
      toggleObserving(prevShouldObserve);
    }
    {
      assertProp(prop, key, value, vm, absent);
    }
    return value;
  }

  /**
   * Get the default value of a prop.
   */
  function getPropDefaultValue(vm, prop, key) {
    // no default, return undefined
    if (!hasOwn(prop, 'default')) {
      return undefined;
    }
    var def = prop.default;
    // warn against non-factory defaults for Object & Array
    if ("development" !== 'production' && isObject(def)) {
      warn('Invalid default value for prop "' + key + '": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);
    }
    // the raw prop value was also undefined from previous render,
    // return previous default value to avoid unnecessary watcher trigger
    if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {
      return vm._props[key];
    }
    // call factory function for non-Function types
    // a value is Function if its prototype is function even across different execution context
    return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;
  }

  /**
   * Assert whether a prop is valid.
   */
  function assertProp(prop, name, value, vm, absent) {
    if (prop.required && absent) {
      warn('Missing required prop: "' + name + '"', vm);
      return;
    }
    if (value == null && !prop.required) {
      return;
    }
    var type = prop.type;
    var valid = !type || type === true;
    var expectedTypes = [];
    if (type) {
      if (!Array.isArray(type)) {
        type = [type];
      }
      for (var i = 0; i < type.length && !valid; i++) {
        var assertedType = assertType(value, type[i]);
        expectedTypes.push(assertedType.expectedType || '');
        valid = assertedType.valid;
      }
    }
    if (!valid) {
      warn("Invalid prop: type check failed for prop \"" + name + "\"." + " Expected " + expectedTypes.map(capitalize).join(', ') + ", got " + toRawType(value) + ".", vm);
      return;
    }
    var validator = prop.validator;
    if (validator) {
      if (!validator(value)) {
        warn('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
      }
    }
  }

  var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;

  function assertType(value, type) {
    var valid;
    var expectedType = getType(type);
    if (simpleCheckRE.test(expectedType)) {
      var t = typeof value === 'undefined' ? 'undefined' : _typeof(value);
      valid = t === expectedType.toLowerCase();
      // for primitive wrapper objects
      if (!valid && t === 'object') {
        valid = value instanceof type;
      }
    } else if (expectedType === 'Object') {
      valid = isPlainObject(value);
    } else if (expectedType === 'Array') {
      valid = Array.isArray(value);
    } else {
      valid = value instanceof type;
    }
    return {
      valid: valid,
      expectedType: expectedType
    };
  }

  /**
   * Use function string name to check built-in types,
   * because a simple equality check will fail when running
   * across different vms / iframes.
   */
  function getType(fn) {
    var match = fn && fn.toString().match(/^\s*function (\w+)/);
    return match ? match[1] : '';
  }

  function isSameType(a, b) {
    return getType(a) === getType(b);
  }

  function getTypeIndex(type, expectedTypes) {
    if (!Array.isArray(expectedTypes)) {
      return isSameType(expectedTypes, type) ? 0 : -1;
    }
    for (var i = 0, len = expectedTypes.length; i < len; i++) {
      if (isSameType(expectedTypes[i], type)) {
        return i;
      }
    }
    return -1;
  }

  /*  */

  function handleError(err, vm, info) {
    if (vm) {
      var cur = vm;
      while (cur = cur.$parent) {
        var hooks = cur.$options.errorCaptured;
        if (hooks) {
          for (var i = 0; i < hooks.length; i++) {
            try {
              var capture = hooks[i].call(cur, err, vm, info) === false;
              if (capture) {
                return;
              }
            } catch (e) {
              globalHandleError(e, cur, 'errorCaptured hook');
            }
          }
        }
      }
    }
    globalHandleError(err, vm, info);
  }

  function globalHandleError(err, vm, info) {
    if (config.errorHandler) {
      try {
        return config.errorHandler.call(null, err, vm, info);
      } catch (e) {
        logError(e, null, 'config.errorHandler');
      }
    }
    logError(err, vm, info);
  }

  function logError(err, vm, info) {
    {
      warn("Error in " + info + ": \"" + err.toString() + "\"", vm);
    }
    /* istanbul ignore else */
    if ((inBrowser || inWeex) && typeof console !== 'undefined') {
      console.error(err);
    } else {
      throw err;
    }
  }

  /*  */
  /* globals MessageChannel */

  var callbacks = [];
  var pending = false;

  function flushCallbacks() {
    pending = false;
    var copies = callbacks.slice(0);
    callbacks.length = 0;
    for (var i = 0; i < copies.length; i++) {
      copies[i]();
    }
  }

  // Here we have async deferring wrappers using both microtasks and (macro) tasks.
  // In < 2.4 we used microtasks everywhere, but there are some scenarios where
  // microtasks have too high a priority and fire in between supposedly
  // sequential events (e.g. #4521, #6690) or even between bubbling of the same
  // event (#6566). However, using (macro) tasks everywhere also has subtle problems
  // when state is changed right before repaint (e.g. #6813, out-in transitions).
  // Here we use microtask by default, but expose a way to force (macro) task when
  // needed (e.g. in event handlers attached by v-on).
  var microTimerFunc;
  var macroTimerFunc;
  var useMacroTask = false;

  // Determine (macro) task defer implementation.
  // Technically setImmediate should be the ideal choice, but it's only available
  // in IE. The only polyfill that consistently queues the callback after all DOM
  // events triggered in the same loop is by using MessageChannel.
  /* istanbul ignore if */
  if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
    macroTimerFunc = function macroTimerFunc() {
      setImmediate(flushCallbacks);
    };
  } else if (typeof MessageChannel !== 'undefined' && (isNative(MessageChannel) ||
  // PhantomJS
  MessageChannel.toString() === '[object MessageChannelConstructor]')) {
    var channel = new MessageChannel();
    var port = channel.port2;
    channel.port1.onmessage = flushCallbacks;
    macroTimerFunc = function macroTimerFunc() {
      port.postMessage(1);
    };
  } else {
    /* istanbul ignore next */
    macroTimerFunc = function macroTimerFunc() {
      setTimeout(flushCallbacks, 0);
    };
  }

  // Determine microtask defer implementation.
  /* istanbul ignore next, $flow-disable-line */
  if (typeof Promise !== 'undefined' && isNative(Promise)) {
    var p = Promise.resolve();
    microTimerFunc = function microTimerFunc() {
      p.then(flushCallbacks);
      // in problematic UIWebViews, Promise.then doesn't completely break, but
      // it can get stuck in a weird state where callbacks are pushed into the
      // microtask queue but the queue isn't being flushed, until the browser
      // needs to do some other work, e.g. handle a timer. Therefore we can
      // "force" the microtask queue to be flushed by adding an empty timer.
      if (isIOS) {
        setTimeout(noop);
      }
    };
  } else {
    // fallback to macro
    microTimerFunc = macroTimerFunc;
  }

  /**
   * Wrap a function so that if any code inside triggers state change,
   * the changes are queued using a (macro) task instead of a microtask.
   */
  function withMacroTask(fn) {
    return fn._withTask || (fn._withTask = function () {
      useMacroTask = true;
      var res = fn.apply(null, arguments);
      useMacroTask = false;
      return res;
    });
  }

  function nextTick(cb, ctx) {
    var _resolve;
    callbacks.push(function () {
      if (cb) {
        try {
          cb.call(ctx);
        } catch (e) {
          handleError(e, ctx, 'nextTick');
        }
      } else if (_resolve) {
        _resolve(ctx);
      }
    });
    if (!pending) {
      pending = true;
      if (useMacroTask) {
        macroTimerFunc();
      } else {
        microTimerFunc();
      }
    }
    // $flow-disable-line
    if (!cb && typeof Promise !== 'undefined') {
      return new Promise(function (resolve) {
        _resolve = resolve;
      });
    }
  }

  /*  */

  var mark;
  var measure;

  {
    var perf = inBrowser && window.performance;
    /* istanbul ignore if */
    if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {
      mark = function mark(tag) {
        return perf.mark(tag);
      };
      measure = function measure(name, startTag, endTag) {
        perf.measure(name, startTag, endTag);
        perf.clearMarks(startTag);
        perf.clearMarks(endTag);
        perf.clearMeasures(name);
      };
    }
  }

  /* not type checking this file because flow doesn't play well with Proxy */

  var initProxy;

  {
    var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify
    );

    var warnNonPresent = function warnNonPresent(target, key) {
      warn("Property or method \"" + key + "\" is not defined on the instance but " + 'referenced during render. Make sure that this property is reactive, ' + 'either in the data option, or for class-based components, by ' + 'initializing the property. ' + 'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);
    };

    var hasProxy = typeof Proxy !== 'undefined' && isNative(Proxy);

    if (hasProxy) {
      var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
      config.keyCodes = new Proxy(config.keyCodes, {
        set: function set(target, key, value) {
          if (isBuiltInModifier(key)) {
            warn("Avoid overwriting built-in modifier in config.keyCodes: ." + key);
            return false;
          } else {
            target[key] = value;
            return true;
          }
        }
      });
    }

    var hasHandler = {
      has: function has(target, key) {
        var has = key in target;
        var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';
        if (!has && !isAllowed) {
          warnNonPresent(target, key);
        }
        return has || !isAllowed;
      }
    };

    var getHandler = {
      get: function get(target, key) {
        if (typeof key === 'string' && !(key in target)) {
          warnNonPresent(target, key);
        }
        return target[key];
      }
    };

    initProxy = function initProxy(vm) {
      if (hasProxy) {
        // determine which proxy handler to use
        var options = vm.$options;
        var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;
        vm._renderProxy = new Proxy(vm, handlers);
      } else {
        vm._renderProxy = vm;
      }
    };
  }

  /*  */

  var seenObjects = new _Set();

  /**
   * Recursively traverse an object to evoke all converted
   * getters, so that every nested property inside the object
   * is collected as a "deep" dependency.
   */
  function traverse(val) {
    _traverse(val, seenObjects);
    seenObjects.clear();
  }

  function _traverse(val, seen) {
    var i, keys;
    var isA = Array.isArray(val);
    if (!isA && !isObject(val) || Object.isFrozen(val) || val instanceof VNode) {
      return;
    }
    if (val.__ob__) {
      var depId = val.__ob__.dep.id;
      if (seen.has(depId)) {
        return;
      }
      seen.add(depId);
    }
    if (isA) {
      i = val.length;
      while (i--) {
        _traverse(val[i], seen);
      }
    } else {
      keys = Object.keys(val);
      i = keys.length;
      while (i--) {
        _traverse(val[keys[i]], seen);
      }
    }
  }

  /*  */

  var normalizeEvent = cached(function (name) {
    var passive = name.charAt(0) === '&';
    name = passive ? name.slice(1) : name;
    var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
    name = once$$1 ? name.slice(1) : name;
    var capture = name.charAt(0) === '!';
    name = capture ? name.slice(1) : name;
    return {
      name: name,
      once: once$$1,
      capture: capture,
      passive: passive
    };
  });

  function createFnInvoker(fns) {
    function invoker() {
      var arguments$1 = arguments;

      var fns = invoker.fns;
      if (Array.isArray(fns)) {
        var cloned = fns.slice();
        for (var i = 0; i < cloned.length; i++) {
          cloned[i].apply(null, arguments$1);
        }
      } else {
        // return handler return value for single handlers
        return fns.apply(null, arguments);
      }
    }
    invoker.fns = fns;
    return invoker;
  }

  function updateListeners(on, oldOn, add, remove$$1, vm) {
    var name, def, cur, old, event;
    for (name in on) {
      def = cur = on[name];
      old = oldOn[name];
      event = normalizeEvent(name);
      /* istanbul ignore if */
      if (isUndef(cur)) {
        "development" !== 'production' && warn("Invalid handler for event \"" + event.name + "\": got " + String(cur), vm);
      } else if (isUndef(old)) {
        if (isUndef(cur.fns)) {
          cur = on[name] = createFnInvoker(cur);
        }
        add(event.name, cur, event.once, event.capture, event.passive, event.params);
      } else if (cur !== old) {
        old.fns = cur;
        on[name] = old;
      }
    }
    for (name in oldOn) {
      if (isUndef(on[name])) {
        event = normalizeEvent(name);
        remove$$1(event.name, oldOn[name], event.capture);
      }
    }
  }

  /*  */

  function mergeVNodeHook(def, hookKey, hook) {
    if (def instanceof VNode) {
      def = def.data.hook || (def.data.hook = {});
    }
    var invoker;
    var oldHook = def[hookKey];

    function wrappedHook() {
      hook.apply(this, arguments);
      // important: remove merged hook to ensure it's called only once
      // and prevent memory leak
      remove(invoker.fns, wrappedHook);
    }

    if (isUndef(oldHook)) {
      // no existing hook
      invoker = createFnInvoker([wrappedHook]);
    } else {
      /* istanbul ignore if */
      if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
        // already a merged invoker
        invoker = oldHook;
        invoker.fns.push(wrappedHook);
      } else {
        // existing plain hook
        invoker = createFnInvoker([oldHook, wrappedHook]);
      }
    }

    invoker.merged = true;
    def[hookKey] = invoker;
  }

  /*  */

  function extractPropsFromVNodeData(data, Ctor, tag) {
    // we are only extracting raw values here.
    // validation and default values are handled in the child
    // component itself.
    var propOptions = Ctor.options.props;
    if (isUndef(propOptions)) {
      return;
    }
    var res = {};
    var attrs = data.attrs;
    var props = data.props;
    if (isDef(attrs) || isDef(props)) {
      for (var key in propOptions) {
        var altKey = hyphenate(key);
        {
          var keyInLowerCase = key.toLowerCase();
          if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {
            tip("Prop \"" + keyInLowerCase + "\" is passed to component " + formatComponentName(tag || Ctor) + ", but the declared prop name is" + " \"" + key + "\". " + "Note that HTML attributes are case-insensitive and camelCased " + "props need to use their kebab-case equivalents when using in-DOM " + "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\".");
          }
        }
        checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);
      }
    }
    return res;
  }

  function checkProp(res, hash, key, altKey, preserve) {
    if (isDef(hash)) {
      if (hasOwn(hash, key)) {
        res[key] = hash[key];
        if (!preserve) {
          delete hash[key];
        }
        return true;
      } else if (hasOwn(hash, altKey)) {
        res[key] = hash[altKey];
        if (!preserve) {
          delete hash[altKey];
        }
        return true;
      }
    }
    return false;
  }

  /*  */

  // The template compiler attempts to minimize the need for normalization by
  // statically analyzing the template at compile time.
  //
  // For plain HTML markup, normalization can be completely skipped because the
  // generated render function is guaranteed to return Array<VNode>. There are
  // two cases where extra normalization is needed:

  // 1. When the children contains components - because a functional component
  // may return an Array instead of a single root. In this case, just a simple
  // normalization is needed - if any child is an Array, we flatten the whole
  // thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
  // because functional components already normalize their own children.
  function simpleNormalizeChildren(children) {
    for (var i = 0; i < children.length; i++) {
      if (Array.isArray(children[i])) {
        return Array.prototype.concat.apply([], children);
      }
    }
    return children;
  }

  // 2. When the children contains constructs that always generated nested Arrays,
  // e.g. <template>, <slot>, v-for, or when the children is provided by user
  // with hand-written render functions / JSX. In such cases a full normalization
  // is needed to cater to all possible types of children values.
  function normalizeChildren(children) {
    return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;
  }

  function isTextNode(node) {
    return isDef(node) && isDef(node.text) && isFalse(node.isComment);
  }

  function normalizeArrayChildren(children, nestedIndex) {
    var res = [];
    var i, c, lastIndex, last;
    for (i = 0; i < children.length; i++) {
      c = children[i];
      if (isUndef(c) || typeof c === 'boolean') {
        continue;
      }
      lastIndex = res.length - 1;
      last = res[lastIndex];
      //  nested
      if (Array.isArray(c)) {
        if (c.length > 0) {
          c = normalizeArrayChildren(c, (nestedIndex || '') + "_" + i);
          // merge adjacent text nodes
          if (isTextNode(c[0]) && isTextNode(last)) {
            res[lastIndex] = createTextVNode(last.text + c[0].text);
            c.shift();
          }
          res.push.apply(res, c);
        }
      } else if (isPrimitive(c)) {
        if (isTextNode(last)) {
          // merge adjacent text nodes
          // this is necessary for SSR hydration because text nodes are
          // essentially merged when rendered to HTML strings
          res[lastIndex] = createTextVNode(last.text + c);
        } else if (c !== '') {
          // convert primitive to vnode
          res.push(createTextVNode(c));
        }
      } else {
        if (isTextNode(c) && isTextNode(last)) {
          // merge adjacent text nodes
          res[lastIndex] = createTextVNode(last.text + c.text);
        } else {
          // default key for nested array children (likely generated by v-for)
          if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {
            c.key = "__vlist" + nestedIndex + "_" + i + "__";
          }
          res.push(c);
        }
      }
    }
    return res;
  }

  /*  */

  function ensureCtor(comp, base) {
    if (comp.__esModule || hasSymbol && comp[Symbol.toStringTag] === 'Module') {
      comp = comp.default;
    }
    return isObject(comp) ? base.extend(comp) : comp;
  }

  function createAsyncPlaceholder(factory, data, context, children, tag) {
    var node = createEmptyVNode();
    node.asyncFactory = factory;
    node.asyncMeta = { data: data, context: context, children: children, tag: tag };
    return node;
  }

  function resolveAsyncComponent(factory, baseCtor, context) {
    if (isTrue(factory.error) && isDef(factory.errorComp)) {
      return factory.errorComp;
    }

    if (isDef(factory.resolved)) {
      return factory.resolved;
    }

    if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
      return factory.loadingComp;
    }

    if (isDef(factory.contexts)) {
      // already pending
      factory.contexts.push(context);
    } else {
      var contexts = factory.contexts = [context];
      var sync = true;

      var forceRender = function forceRender() {
        for (var i = 0, l = contexts.length; i < l; i++) {
          contexts[i].$forceUpdate();
        }
      };

      var resolve = once(function (res) {
        // cache resolved
        factory.resolved = ensureCtor(res, baseCtor);
        // invoke callbacks only if this is not a synchronous resolve
        // (async resolves are shimmed as synchronous during SSR)
        if (!sync) {
          forceRender();
        }
      });

      var reject = once(function (reason) {
        "development" !== 'production' && warn("Failed to resolve async component: " + String(factory) + (reason ? "\nReason: " + reason : ''));
        if (isDef(factory.errorComp)) {
          factory.error = true;
          forceRender();
        }
      });

      var res = factory(resolve, reject);

      if (isObject(res)) {
        if (typeof res.then === 'function') {
          // () => Promise
          if (isUndef(factory.resolved)) {
            res.then(resolve, reject);
          }
        } else if (isDef(res.component) && typeof res.component.then === 'function') {
          res.component.then(resolve, reject);

          if (isDef(res.error)) {
            factory.errorComp = ensureCtor(res.error, baseCtor);
          }

          if (isDef(res.loading)) {
            factory.loadingComp = ensureCtor(res.loading, baseCtor);
            if (res.delay === 0) {
              factory.loading = true;
            } else {
              setTimeout(function () {
                if (isUndef(factory.resolved) && isUndef(factory.error)) {
                  factory.loading = true;
                  forceRender();
                }
              }, res.delay || 200);
            }
          }

          if (isDef(res.timeout)) {
            setTimeout(function () {
              if (isUndef(factory.resolved)) {
                reject("timeout (" + res.timeout + "ms)");
              }
            }, res.timeout);
          }
        }
      }

      sync = false;
      // return in case resolved synchronously
      return factory.loading ? factory.loadingComp : factory.resolved;
    }
  }

  /*  */

  function isAsyncPlaceholder(node) {
    return node.isComment && node.asyncFactory;
  }

  /*  */

  function getFirstComponentChild(children) {
    if (Array.isArray(children)) {
      for (var i = 0; i < children.length; i++) {
        var c = children[i];
        if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
          return c;
        }
      }
    }
  }

  /*  */

  /*  */

  function initEvents(vm) {
    vm._events = Object.create(null);
    vm._hasHookEvent = false;
    // init parent attached events
    var listeners = vm.$options._parentListeners;
    if (listeners) {
      updateComponentListeners(vm, listeners);
    }
  }

  var target;

  function add(event, fn, once) {
    if (once) {
      target.$once(event, fn);
    } else {
      target.$on(event, fn);
    }
  }

  function remove$1(event, fn) {
    target.$off(event, fn);
  }

  function updateComponentListeners(vm, listeners, oldListeners) {
    target = vm;
    updateListeners(listeners, oldListeners || {}, add, remove$1, vm);
    target = undefined;
  }

  function eventsMixin(Vue) {
    var hookRE = /^hook:/;
    Vue.prototype.$on = function (event, fn) {
      var this$1 = this;

      var vm = this;
      if (Array.isArray(event)) {
        for (var i = 0, l = event.length; i < l; i++) {
          this$1.$on(event[i], fn);
        }
      } else {
        (vm._events[event] || (vm._events[event] = [])).push(fn);
        // optimize hook:event cost by using a boolean flag marked at registration
        // instead of a hash lookup
        if (hookRE.test(event)) {
          vm._hasHookEvent = true;
        }
      }
      return vm;
    };

    Vue.prototype.$once = function (event, fn) {
      var vm = this;
      function on() {
        vm.$off(event, on);
        fn.apply(vm, arguments);
      }
      on.fn = fn;
      vm.$on(event, on);
      return vm;
    };

    Vue.prototype.$off = function (event, fn) {
      var this$1 = this;

      var vm = this;
      // all
      if (!arguments.length) {
        vm._events = Object.create(null);
        return vm;
      }
      // array of events
      if (Array.isArray(event)) {
        for (var i = 0, l = event.length; i < l; i++) {
          this$1.$off(event[i], fn);
        }
        return vm;
      }
      // specific event
      var cbs = vm._events[event];
      if (!cbs) {
        return vm;
      }
      if (!fn) {
        vm._events[event] = null;
        return vm;
      }
      if (fn) {
        // specific handler
        var cb;
        var i$1 = cbs.length;
        while (i$1--) {
          cb = cbs[i$1];
          if (cb === fn || cb.fn === fn) {
            cbs.splice(i$1, 1);
            break;
          }
        }
      }
      return vm;
    };

    Vue.prototype.$emit = function (event) {
      var vm = this;
      {
        var lowerCaseEvent = event.toLowerCase();
        if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
          tip("Event \"" + lowerCaseEvent + "\" is emitted in component " + formatComponentName(vm) + " but the handler is registered for \"" + event + "\". " + "Note that HTML attributes are case-insensitive and you cannot use " + "v-on to listen to camelCase events when using in-DOM templates. " + "You should probably use \"" + hyphenate(event) + "\" instead of \"" + event + "\".");
        }
      }
      var cbs = vm._events[event];
      if (cbs) {
        cbs = cbs.length > 1 ? toArray(cbs) : cbs;
        var args = toArray(arguments, 1);
        for (var i = 0, l = cbs.length; i < l; i++) {
          try {
            cbs[i].apply(vm, args);
          } catch (e) {
            handleError(e, vm, "event handler for \"" + event + "\"");
          }
        }
      }
      return vm;
    };
  }

  /*  */

  /**
   * Runtime helper for resolving raw children VNodes into a slot object.
   */
  function resolveSlots(children, context) {
    var slots = {};
    if (!children) {
      return slots;
    }
    for (var i = 0, l = children.length; i < l; i++) {
      var child = children[i];
      var data = child.data;
      // remove slot attribute if the node is resolved as a Vue slot node
      if (data && data.attrs && data.attrs.slot) {
        delete data.attrs.slot;
      }
      // named slots should only be respected if the vnode was rendered in the
      // same context.
      if ((child.context === context || child.fnContext === context) && data && data.slot != null) {
        var name = data.slot;
        var slot = slots[name] || (slots[name] = []);
        if (child.tag === 'template') {
          slot.push.apply(slot, child.children || []);
        } else {
          slot.push(child);
        }
      } else {
        (slots.default || (slots.default = [])).push(child);
      }
    }
    // ignore slots that contains only whitespace
    for (var name$1 in slots) {
      if (slots[name$1].every(isWhitespace)) {
        delete slots[name$1];
      }
    }
    return slots;
  }

  function isWhitespace(node) {
    return node.isComment && !node.asyncFactory || node.text === ' ';
  }

  function resolveScopedSlots(fns, // see flow/vnode
  res) {
    res = res || {};
    for (var i = 0; i < fns.length; i++) {
      if (Array.isArray(fns[i])) {
        resolveScopedSlots(fns[i], res);
      } else {
        res[fns[i].key] = fns[i].fn;
      }
    }
    return res;
  }

  /*  */

  var activeInstance = null;
  var isUpdatingChildComponent = false;

  function initLifecycle(vm) {
    var options = vm.$options;

    // locate first non-abstract parent
    var parent = options.parent;
    if (parent && !options.abstract) {
      while (parent.$options.abstract && parent.$parent) {
        parent = parent.$parent;
      }
      parent.$children.push(vm);
    }

    vm.$parent = parent;
    vm.$root = parent ? parent.$root : vm;

    vm.$children = [];
    vm.$refs = {};

    vm._watcher = null;
    vm._inactive = null;
    vm._directInactive = false;
    vm._isMounted = false;
    vm._isDestroyed = false;
    vm._isBeingDestroyed = false;
  }

  function lifecycleMixin(Vue) {
    Vue.prototype._update = function (vnode, hydrating) {
      var vm = this;
      if (vm._isMounted) {
        callHook(vm, 'beforeUpdate');
      }
      var prevEl = vm.$el;
      var prevVnode = vm._vnode;
      var prevActiveInstance = activeInstance;
      activeInstance = vm;
      vm._vnode = vnode;
      // Vue.prototype.__patch__ is injected in entry points
      // based on the rendering backend used.
      if (!prevVnode) {
        // initial render
        vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */
        , vm.$options._parentElm, vm.$options._refElm);
        // no need for the ref nodes after initial patch
        // this prevents keeping a detached DOM tree in memory (#5851)
        vm.$options._parentElm = vm.$options._refElm = null;
      } else {
        // updates
        vm.$el = vm.__patch__(prevVnode, vnode);
      }
      activeInstance = prevActiveInstance;
      // update __vue__ reference
      if (prevEl) {
        prevEl.__vue__ = null;
      }
      if (vm.$el) {
        vm.$el.__vue__ = vm;
      }
      // if parent is an HOC, update its $el as well
      if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
        vm.$parent.$el = vm.$el;
      }
      // updated hook is called by the scheduler to ensure that children are
      // updated in a parent's updated hook.
    };

    Vue.prototype.$forceUpdate = function () {
      var vm = this;
      if (vm._watcher) {
        vm._watcher.update();
      }
    };

    Vue.prototype.$destroy = function () {
      var vm = this;
      if (vm._isBeingDestroyed) {
        return;
      }
      callHook(vm, 'beforeDestroy');
      vm._isBeingDestroyed = true;
      // remove self from parent
      var parent = vm.$parent;
      if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
        remove(parent.$children, vm);
      }
      // teardown watchers
      if (vm._watcher) {
        vm._watcher.teardown();
      }
      var i = vm._watchers.length;
      while (i--) {
        vm._watchers[i].teardown();
      }
      // remove reference from data ob
      // frozen object may not have observer.
      if (vm._data.__ob__) {
        vm._data.__ob__.vmCount--;
      }
      // call the last hook...
      vm._isDestroyed = true;
      // invoke destroy hooks on current rendered tree
      vm.__patch__(vm._vnode, null);
      // fire destroyed hook
      callHook(vm, 'destroyed');
      // turn off all instance listeners.
      vm.$off();
      // remove __vue__ reference
      if (vm.$el) {
        vm.$el.__vue__ = null;
      }
      // release circular reference (#6759)
      if (vm.$vnode) {
        vm.$vnode.parent = null;
      }
    };
  }

  function mountComponent(vm, el, hydrating) {
    vm.$el = el;
    if (!vm.$options.render) {
      vm.$options.render = createEmptyVNode;
      {
        /* istanbul ignore if */
        if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {
          warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);
        } else {
          warn('Failed to mount component: template or render function not defined.', vm);
        }
      }
    }
    callHook(vm, 'beforeMount');

    var updateComponent;
    /* istanbul ignore if */
    if ("development" !== 'production' && config.performance && mark) {
      updateComponent = function updateComponent() {
        var name = vm._name;
        var id = vm._uid;
        var startTag = "vue-perf-start:" + id;
        var endTag = "vue-perf-end:" + id;

        mark(startTag);
        var vnode = vm._render();
        mark(endTag);
        measure("vue " + name + " render", startTag, endTag);

        mark(startTag);
        vm._update(vnode, hydrating);
        mark(endTag);
        measure("vue " + name + " patch", startTag, endTag);
      };
    } else {
      updateComponent = function updateComponent() {
        vm._update(vm._render(), hydrating);
      };
    }

    // we set this to vm._watcher inside the watcher's constructor
    // since the watcher's initial patch may call $forceUpdate (e.g. inside child
    // component's mounted hook), which relies on vm._watcher being already defined
    new Watcher(vm, updateComponent, noop, null, true /* isRenderWatcher */);
    hydrating = false;

    // manually mounted instance, call mounted on self
    // mounted is called for render-created child components in its inserted hook
    if (vm.$vnode == null) {
      vm._isMounted = true;
      callHook(vm, 'mounted');
    }
    return vm;
  }

  function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
    {
      isUpdatingChildComponent = true;
    }

    // determine whether component has slot children
    // we need to do this before overwriting $options._renderChildren
    var hasChildren = !!(renderChildren || // has new static slots
    vm.$options._renderChildren || // has old static slots
    parentVnode.data.scopedSlots || // has new scoped slots
    vm.$scopedSlots !== emptyObject // has old scoped slots
    );

    vm.$options._parentVnode = parentVnode;
    vm.$vnode = parentVnode; // update vm's placeholder node without re-render

    if (vm._vnode) {
      // update child tree's parent
      vm._vnode.parent = parentVnode;
    }
    vm.$options._renderChildren = renderChildren;

    // update $attrs and $listeners hash
    // these are also reactive so they may trigger child update if the child
    // used them during render
    vm.$attrs = parentVnode.data.attrs || emptyObject;
    vm.$listeners = listeners || emptyObject;

    // update props
    if (propsData && vm.$options.props) {
      toggleObserving(false);
      var props = vm._props;
      var propKeys = vm.$options._propKeys || [];
      for (var i = 0; i < propKeys.length; i++) {
        var key = propKeys[i];
        var propOptions = vm.$options.props; // wtf flow?
        props[key] = validateProp(key, propOptions, propsData, vm);
      }
      toggleObserving(true);
      // keep a copy of raw propsData
      vm.$options.propsData = propsData;
    }

    // update listeners
    listeners = listeners || emptyObject;
    var oldListeners = vm.$options._parentListeners;
    vm.$options._parentListeners = listeners;
    updateComponentListeners(vm, listeners, oldListeners);

    // resolve slots + force update if has children
    if (hasChildren) {
      vm.$slots = resolveSlots(renderChildren, parentVnode.context);
      vm.$forceUpdate();
    }

    {
      isUpdatingChildComponent = false;
    }
  }

  function isInInactiveTree(vm) {
    while (vm && (vm = vm.$parent)) {
      if (vm._inactive) {
        return true;
      }
    }
    return false;
  }

  function activateChildComponent(vm, direct) {
    if (direct) {
      vm._directInactive = false;
      if (isInInactiveTree(vm)) {
        return;
      }
    } else if (vm._directInactive) {
      return;
    }
    if (vm._inactive || vm._inactive === null) {
      vm._inactive = false;
      for (var i = 0; i < vm.$children.length; i++) {
        activateChildComponent(vm.$children[i]);
      }
      callHook(vm, 'activated');
    }
  }

  function deactivateChildComponent(vm, direct) {
    if (direct) {
      vm._directInactive = true;
      if (isInInactiveTree(vm)) {
        return;
      }
    }
    if (!vm._inactive) {
      vm._inactive = true;
      for (var i = 0; i < vm.$children.length; i++) {
        deactivateChildComponent(vm.$children[i]);
      }
      callHook(vm, 'deactivated');
    }
  }

  function callHook(vm, hook) {
    // #7573 disable dep collection when invoking lifecycle hooks
    pushTarget();
    var handlers = vm.$options[hook];
    if (handlers) {
      for (var i = 0, j = handlers.length; i < j; i++) {
        try {
          handlers[i].call(vm);
        } catch (e) {
          handleError(e, vm, hook + " hook");
        }
      }
    }
    if (vm._hasHookEvent) {
      vm.$emit('hook:' + hook);
    }
    popTarget();
  }

  /*  */

  var MAX_UPDATE_COUNT = 100;

  var queue = [];
  var activatedChildren = [];
  var has = {};
  var circular = {};
  var waiting = false;
  var flushing = false;
  var index = 0;

  /**
   * Reset the scheduler's state.
   */
  function resetSchedulerState() {
    index = queue.length = activatedChildren.length = 0;
    has = {};
    {
      circular = {};
    }
    waiting = flushing = false;
  }

  /**
   * Flush both queues and run the watchers.
   */
  function flushSchedulerQueue() {
    flushing = true;
    var watcher, id;

    // Sort queue before flush.
    // This ensures that:
    // 1. Components are updated from parent to child. (because parent is always
    //    created before the child)
    // 2. A component's user watchers are run before its render watcher (because
    //    user watchers are created before the render watcher)
    // 3. If a component is destroyed during a parent component's watcher run,
    //    its watchers can be skipped.
    queue.sort(function (a, b) {
      return a.id - b.id;
    });

    // do not cache length because more watchers might be pushed
    // as we run existing watchers
    for (index = 0; index < queue.length; index++) {
      watcher = queue[index];
      id = watcher.id;
      has[id] = null;
      watcher.run();
      // in dev build, check and stop circular updates.
      if ("development" !== 'production' && has[id] != null) {
        circular[id] = (circular[id] || 0) + 1;
        if (circular[id] > MAX_UPDATE_COUNT) {
          warn('You may have an infinite update loop ' + (watcher.user ? "in watcher with expression \"" + watcher.expression + "\"" : "in a component render function."), watcher.vm);
          break;
        }
      }
    }

    // keep copies of post queues before resetting state
    var activatedQueue = activatedChildren.slice();
    var updatedQueue = queue.slice();

    resetSchedulerState();

    // call component updated and activated hooks
    callActivatedHooks(activatedQueue);
    callUpdatedHooks(updatedQueue);

    // devtool hook
    /* istanbul ignore if */
    if (devtools && config.devtools) {
      devtools.emit('flush');
    }
  }

  function callUpdatedHooks(queue) {
    var i = queue.length;
    while (i--) {
      var watcher = queue[i];
      var vm = watcher.vm;
      if (vm._watcher === watcher && vm._isMounted) {
        callHook(vm, 'updated');
      }
    }
  }

  /**
   * Queue a kept-alive component that was activated during patch.
   * The queue will be processed after the entire tree has been patched.
   */
  function queueActivatedComponent(vm) {
    // setting _inactive to false here so that a render function can
    // rely on checking whether it's in an inactive tree (e.g. router-view)
    vm._inactive = false;
    activatedChildren.push(vm);
  }

  function callActivatedHooks(queue) {
    for (var i = 0; i < queue.length; i++) {
      queue[i]._inactive = true;
      activateChildComponent(queue[i], true /* true */);
    }
  }

  /**
   * Push a watcher into the watcher queue.
   * Jobs with duplicate IDs will be skipped unless it's
   * pushed when the queue is being flushed.
   */
  function queueWatcher(watcher) {
    var id = watcher.id;
    if (has[id] == null) {
      has[id] = true;
      if (!flushing) {
        queue.push(watcher);
      } else {
        // if already flushing, splice the watcher based on its id
        // if already past its id, it will be run next immediately.
        var i = queue.length - 1;
        while (i > index && queue[i].id > watcher.id) {
          i--;
        }
        queue.splice(i + 1, 0, watcher);
      }
      // queue the flush
      if (!waiting) {
        waiting = true;
        nextTick(flushSchedulerQueue);
      }
    }
  }

  /*  */

  var uid$1 = 0;

  /**
   * A watcher parses an expression, collects dependencies,
   * and fires callback when the expression value changes.
   * This is used for both the $watch() api and directives.
   */
  var Watcher = function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {
    this.vm = vm;
    if (isRenderWatcher) {
      vm._watcher = this;
    }
    vm._watchers.push(this);
    // options
    if (options) {
      this.deep = !!options.deep;
      this.user = !!options.user;
      this.lazy = !!options.lazy;
      this.sync = !!options.sync;
    } else {
      this.deep = this.user = this.lazy = this.sync = false;
    }
    this.cb = cb;
    this.id = ++uid$1; // uid for batching
    this.active = true;
    this.dirty = this.lazy; // for lazy watchers
    this.deps = [];
    this.newDeps = [];
    this.depIds = new _Set();
    this.newDepIds = new _Set();
    this.expression = expOrFn.toString();
    // parse expression for getter
    if (typeof expOrFn === 'function') {
      this.getter = expOrFn;
    } else {
      this.getter = parsePath(expOrFn);
      if (!this.getter) {
        this.getter = function () {};
        "development" !== 'production' && warn("Failed watching path: \"" + expOrFn + "\" " + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);
      }
    }
    this.value = this.lazy ? undefined : this.get();
  };

  /**
   * Evaluate the getter, and re-collect dependencies.
   */
  Watcher.prototype.get = function get() {
    pushTarget(this);
    var value;
    var vm = this.vm;
    try {
      value = this.getter.call(vm, vm);
    } catch (e) {
      if (this.user) {
        handleError(e, vm, "getter for watcher \"" + this.expression + "\"");
      } else {
        throw e;
      }
    } finally {
      // "touch" every property so they are all tracked as
      // dependencies for deep watching
      if (this.deep) {
        traverse(value);
      }
      popTarget();
      this.cleanupDeps();
    }
    return value;
  };

  /**
   * Add a dependency to this directive.
   */
  Watcher.prototype.addDep = function addDep(dep) {
    var id = dep.id;
    if (!this.newDepIds.has(id)) {
      this.newDepIds.add(id);
      this.newDeps.push(dep);
      if (!this.depIds.has(id)) {
        dep.addSub(this);
      }
    }
  };

  /**
   * Clean up for dependency collection.
   */
  Watcher.prototype.cleanupDeps = function cleanupDeps() {
    var this$1 = this;

    var i = this.deps.length;
    while (i--) {
      var dep = this$1.deps[i];
      if (!this$1.newDepIds.has(dep.id)) {
        dep.removeSub(this$1);
      }
    }
    var tmp = this.depIds;
    this.depIds = this.newDepIds;
    this.newDepIds = tmp;
    this.newDepIds.clear();
    tmp = this.deps;
    this.deps = this.newDeps;
    this.newDeps = tmp;
    this.newDeps.length = 0;
  };

  /**
   * Subscriber interface.
   * Will be called when a dependency changes.
   */
  Watcher.prototype.update = function update() {
    /* istanbul ignore else */
    if (this.lazy) {
      this.dirty = true;
    } else if (this.sync) {
      this.run();
    } else {
      queueWatcher(this);
    }
  };

  /**
   * Scheduler job interface.
   * Will be called by the scheduler.
   */
  Watcher.prototype.run = function run() {
    if (this.active) {
      var value = this.get();
      if (value !== this.value ||
      // Deep watchers and watchers on Object/Arrays should fire even
      // when the value is the same, because the value may
      // have mutated.
      isObject(value) || this.deep) {
        // set new value
        var oldValue = this.value;
        this.value = value;
        if (this.user) {
          try {
            this.cb.call(this.vm, value, oldValue);
          } catch (e) {
            handleError(e, this.vm, "callback for watcher \"" + this.expression + "\"");
          }
        } else {
          this.cb.call(this.vm, value, oldValue);
        }
      }
    }
  };

  /**
   * Evaluate the value of the watcher.
   * This only gets called for lazy watchers.
   */
  Watcher.prototype.evaluate = function evaluate() {
    this.value = this.get();
    this.dirty = false;
  };

  /**
   * Depend on all deps collected by this watcher.
   */
  Watcher.prototype.depend = function depend() {
    var this$1 = this;

    var i = this.deps.length;
    while (i--) {
      this$1.deps[i].depend();
    }
  };

  /**
   * Remove self from all dependencies' subscriber list.
   */
  Watcher.prototype.teardown = function teardown() {
    var this$1 = this;

    if (this.active) {
      // remove self from vm's watcher list
      // this is a somewhat expensive operation so we skip it
      // if the vm is being destroyed.
      if (!this.vm._isBeingDestroyed) {
        remove(this.vm._watchers, this);
      }
      var i = this.deps.length;
      while (i--) {
        this$1.deps[i].removeSub(this$1);
      }
      this.active = false;
    }
  };

  /*  */

  var sharedPropertyDefinition = {
    enumerable: true,
    configurable: true,
    get: noop,
    set: noop
  };

  function proxy(target, sourceKey, key) {
    sharedPropertyDefinition.get = function proxyGetter() {
      return this[sourceKey][key];
    };
    sharedPropertyDefinition.set = function proxySetter(val) {
      this[sourceKey][key] = val;
    };
    Object.defineProperty(target, key, sharedPropertyDefinition);
  }

  function initState(vm) {
    vm._watchers = [];
    var opts = vm.$options;
    if (opts.props) {
      initProps(vm, opts.props);
    }
    if (opts.methods) {
      initMethods(vm, opts.methods);
    }
    if (opts.data) {
      initData(vm);
    } else {
      observe(vm._data = {}, true /* asRootData */);
    }
    if (opts.computed) {
      initComputed(vm, opts.computed);
    }
    if (opts.watch && opts.watch !== nativeWatch) {
      initWatch(vm, opts.watch);
    }
  }

  function initProps(vm, propsOptions) {
    var propsData = vm.$options.propsData || {};
    var props = vm._props = {};
    // cache prop keys so that future props updates can iterate using Array
    // instead of dynamic object key enumeration.
    var keys = vm.$options._propKeys = [];
    var isRoot = !vm.$parent;
    // root instance props should be converted
    if (!isRoot) {
      toggleObserving(false);
    }
    var loop = function loop(key) {
      keys.push(key);
      var value = validateProp(key, propsOptions, propsData, vm);
      /* istanbul ignore else */
      {
        var hyphenatedKey = hyphenate(key);
        if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) {
          warn("\"" + hyphenatedKey + "\" is a reserved attribute and cannot be used as component prop.", vm);
        }
        defineReactive(props, key, value, function () {
          if (vm.$parent && !isUpdatingChildComponent) {
            warn("Avoid mutating a prop directly since the value will be " + "overwritten whenever the parent component re-renders. " + "Instead, use a data or computed property based on the prop's " + "value. Prop being mutated: \"" + key + "\"", vm);
          }
        });
      }
      // static props are already proxied on the component's prototype
      // during Vue.extend(). We only need to proxy props defined at
      // instantiation here.
      if (!(key in vm)) {
        proxy(vm, "_props", key);
      }
    };

    for (var key in propsOptions) {
      loop(key);
    }toggleObserving(true);
  }

  function initData(vm) {
    var data = vm.$options.data;
    data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};
    if (!isPlainObject(data)) {
      data = {};
      "development" !== 'production' && warn('data functions should return an object:\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);
    }
    // proxy data on instance
    var keys = Object.keys(data);
    var props = vm.$options.props;
    var methods = vm.$options.methods;
    var i = keys.length;
    while (i--) {
      var key = keys[i];
      {
        if (methods && hasOwn(methods, key)) {
          warn("Method \"" + key + "\" has already been defined as a data property.", vm);
        }
      }
      if (props && hasOwn(props, key)) {
        "development" !== 'production' && warn("The data property \"" + key + "\" is already declared as a prop. " + "Use prop default value instead.", vm);
      } else if (!isReserved(key)) {
        proxy(vm, "_data", key);
      }
    }
    // observe data
    observe(data, true /* asRootData */);
  }

  function getData(data, vm) {
    // #7573 disable dep collection when invoking data getters
    pushTarget();
    try {
      return data.call(vm, vm);
    } catch (e) {
      handleError(e, vm, "data()");
      return {};
    } finally {
      popTarget();
    }
  }

  var computedWatcherOptions = { lazy: true };

  function initComputed(vm, computed) {
    // $flow-disable-line
    var watchers = vm._computedWatchers = Object.create(null);
    // computed properties are just getters during SSR
    var isSSR = isServerRendering();

    for (var key in computed) {
      var userDef = computed[key];
      var getter = typeof userDef === 'function' ? userDef : userDef.get;
      if ("development" !== 'production' && getter == null) {
        warn("Getter is missing for computed property \"" + key + "\".", vm);
      }

      if (!isSSR) {
        // create internal watcher for the computed property.
        watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);
      }

      // component-defined computed properties are already defined on the
      // component prototype. We only need to define computed properties defined
      // at instantiation here.
      if (!(key in vm)) {
        defineComputed(vm, key, userDef);
      } else {
        if (key in vm.$data) {
          warn("The computed property \"" + key + "\" is already defined in data.", vm);
        } else if (vm.$options.props && key in vm.$options.props) {
          warn("The computed property \"" + key + "\" is already defined as a prop.", vm);
        }
      }
    }
  }

  function defineComputed(target, key, userDef) {
    var shouldCache = !isServerRendering();
    if (typeof userDef === 'function') {
      sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : userDef;
      sharedPropertyDefinition.set = noop;
    } else {
      sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : userDef.get : noop;
      sharedPropertyDefinition.set = userDef.set ? userDef.set : noop;
    }
    if ("development" !== 'production' && sharedPropertyDefinition.set === noop) {
      sharedPropertyDefinition.set = function () {
        warn("Computed property \"" + key + "\" was assigned to but it has no setter.", this);
      };
    }
    Object.defineProperty(target, key, sharedPropertyDefinition);
  }

  function createComputedGetter(key) {
    return function computedGetter() {
      var watcher = this._computedWatchers && this._computedWatchers[key];
      if (watcher) {
        if (watcher.dirty) {
          watcher.evaluate();
        }
        if (Dep.target) {
          watcher.depend();
        }
        return watcher.value;
      }
    };
  }

  function initMethods(vm, methods) {
    var props = vm.$options.props;
    for (var key in methods) {
      {
        if (methods[key] == null) {
          warn("Method \"" + key + "\" has an undefined value in the component definition. " + "Did you reference the function correctly?", vm);
        }
        if (props && hasOwn(props, key)) {
          warn("Method \"" + key + "\" has already been defined as a prop.", vm);
        }
        if (key in vm && isReserved(key)) {
          warn("Method \"" + key + "\" conflicts with an existing Vue instance method. " + "Avoid defining component methods that start with _ or $.");
        }
      }
      vm[key] = methods[key] == null ? noop : bind(methods[key], vm);
    }
  }

  function initWatch(vm, watch) {
    for (var key in watch) {
      var handler = watch[key];
      if (Array.isArray(handler)) {
        for (var i = 0; i < handler.length; i++) {
          createWatcher(vm, key, handler[i]);
        }
      } else {
        createWatcher(vm, key, handler);
      }
    }
  }

  function createWatcher(vm, expOrFn, handler, options) {
    if (isPlainObject(handler)) {
      options = handler;
      handler = handler.handler;
    }
    if (typeof handler === 'string') {
      handler = vm[handler];
    }
    return vm.$watch(expOrFn, handler, options);
  }

  function stateMixin(Vue) {
    // flow somehow has problems with directly declared definition object
    // when using Object.defineProperty, so we have to procedurally build up
    // the object here.
    var dataDef = {};
    dataDef.get = function () {
      return this._data;
    };
    var propsDef = {};
    propsDef.get = function () {
      return this._props;
    };
    {
      dataDef.set = function (newData) {
        warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);
      };
      propsDef.set = function () {
        warn("$props is readonly.", this);
      };
    }
    Object.defineProperty(Vue.prototype, '$data', dataDef);
    Object.defineProperty(Vue.prototype, '$props', propsDef);

    Vue.prototype.$set = set;
    Vue.prototype.$delete = del;

    Vue.prototype.$watch = function (expOrFn, cb, options) {
      var vm = this;
      if (isPlainObject(cb)) {
        return createWatcher(vm, expOrFn, cb, options);
      }
      options = options || {};
      options.user = true;
      var watcher = new Watcher(vm, expOrFn, cb, options);
      if (options.immediate) {
        cb.call(vm, watcher.value);
      }
      return function unwatchFn() {
        watcher.teardown();
      };
    };
  }

  /*  */

  function initProvide(vm) {
    var provide = vm.$options.provide;
    if (provide) {
      vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;
    }
  }

  function initInjections(vm) {
    var result = resolveInject(vm.$options.inject, vm);
    if (result) {
      toggleObserving(false);
      Object.keys(result).forEach(function (key) {
        /* istanbul ignore else */
        {
          defineReactive(vm, key, result[key], function () {
            warn("Avoid mutating an injected value directly since the changes will be " + "overwritten whenever the provided component re-renders. " + "injection being mutated: \"" + key + "\"", vm);
          });
        }
      });
      toggleObserving(true);
    }
  }

  function resolveInject(inject, vm) {
    if (inject) {
      // inject is :any because flow is not smart enough to figure out cached
      var result = Object.create(null);
      var keys = hasSymbol ? Reflect.ownKeys(inject).filter(function (key) {
        /* istanbul ignore next */
        return Object.getOwnPropertyDescriptor(inject, key).enumerable;
      }) : Object.keys(inject);

      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var provideKey = inject[key].from;
        var source = vm;
        while (source) {
          if (source._provided && hasOwn(source._provided, provideKey)) {
            result[key] = source._provided[provideKey];
            break;
          }
          source = source.$parent;
        }
        if (!source) {
          if ('default' in inject[key]) {
            var provideDefault = inject[key].default;
            result[key] = typeof provideDefault === 'function' ? provideDefault.call(vm) : provideDefault;
          } else {
            warn("Injection \"" + key + "\" not found", vm);
          }
        }
      }
      return result;
    }
  }

  /*  */

  /**
   * Runtime helper for rendering v-for lists.
   */
  function renderList(val, render) {
    var ret, i, l, keys, key;
    if (Array.isArray(val) || typeof val === 'string') {
      ret = new Array(val.length);
      for (i = 0, l = val.length; i < l; i++) {
        ret[i] = render(val[i], i);
      }
    } else if (typeof val === 'number') {
      ret = new Array(val);
      for (i = 0; i < val; i++) {
        ret[i] = render(i + 1, i);
      }
    } else if (isObject(val)) {
      keys = Object.keys(val);
      ret = new Array(keys.length);
      for (i = 0, l = keys.length; i < l; i++) {
        key = keys[i];
        ret[i] = render(val[key], key, i);
      }
    }
    if (isDef(ret)) {
      ret._isVList = true;
    }
    return ret;
  }

  /*  */

  /**
   * Runtime helper for rendering <slot>
   */
  function renderSlot(name, fallback, props, bindObject) {
    var scopedSlotFn = this.$scopedSlots[name];
    var nodes;
    if (scopedSlotFn) {
      // scoped slot
      props = props || {};
      if (bindObject) {
        if ("development" !== 'production' && !isObject(bindObject)) {
          warn('slot v-bind without argument expects an Object', this);
        }
        props = extend(extend({}, bindObject), props);
      }
      nodes = scopedSlotFn(props) || fallback;
    } else {
      var slotNodes = this.$slots[name];
      // warn duplicate slot usage
      if (slotNodes) {
        if ("development" !== 'production' && slotNodes._rendered) {
          warn("Duplicate presence of slot \"" + name + "\" found in the same render tree " + "- this will likely cause render errors.", this);
        }
        slotNodes._rendered = true;
      }
      nodes = slotNodes || fallback;
    }

    var target = props && props.slot;
    if (target) {
      return this.$createElement('template', { slot: target }, nodes);
    } else {
      return nodes;
    }
  }

  /*  */

  /**
   * Runtime helper for resolving filters
   */
  function resolveFilter(id) {
    return resolveAsset(this.$options, 'filters', id, true) || identity;
  }

  /*  */

  function isKeyNotMatch(expect, actual) {
    if (Array.isArray(expect)) {
      return expect.indexOf(actual) === -1;
    } else {
      return expect !== actual;
    }
  }

  /**
   * Runtime helper for checking keyCodes from config.
   * exposed as Vue.prototype._k
   * passing in eventKeyName as last argument separately for backwards compat
   */
  function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {
    var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;
    if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
      return isKeyNotMatch(builtInKeyName, eventKeyName);
    } else if (mappedKeyCode) {
      return isKeyNotMatch(mappedKeyCode, eventKeyCode);
    } else if (eventKeyName) {
      return hyphenate(eventKeyName) !== key;
    }
  }

  /*  */

  /**
   * Runtime helper for merging v-bind="object" into a VNode's data.
   */
  function bindObjectProps(data, tag, value, asProp, isSync) {
    if (value) {
      if (!isObject(value)) {
        "development" !== 'production' && warn('v-bind without argument expects an Object or Array value', this);
      } else {
        if (Array.isArray(value)) {
          value = toObject(value);
        }
        var hash;
        var loop = function loop(key) {
          if (key === 'class' || key === 'style' || isReservedAttribute(key)) {
            hash = data;
          } else {
            var type = data.attrs && data.attrs.type;
            hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
          }
          if (!(key in hash)) {
            hash[key] = value[key];

            if (isSync) {
              var on = data.on || (data.on = {});
              on["update:" + key] = function ($event) {
                value[key] = $event;
              };
            }
          }
        };

        for (var key in value) {
          loop(key);
        }
      }
    }
    return data;
  }

  /*  */

  /**
   * Runtime helper for rendering static trees.
   */
  function renderStatic(index, isInFor) {
    var cached = this._staticTrees || (this._staticTrees = []);
    var tree = cached[index];
    // if has already-rendered static tree and not inside v-for,
    // we can reuse the same tree.
    if (tree && !isInFor) {
      return tree;
    }
    // otherwise, render a fresh tree.
    tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, null, this // for render fns generated for functional component templates
    );
    markStatic(tree, "__static__" + index, false);
    return tree;
  }

  /**
   * Runtime helper for v-once.
   * Effectively it means marking the node as static with a unique key.
   */
  function markOnce(tree, index, key) {
    markStatic(tree, "__once__" + index + (key ? "_" + key : ""), true);
    return tree;
  }

  function markStatic(tree, key, isOnce) {
    if (Array.isArray(tree)) {
      for (var i = 0; i < tree.length; i++) {
        if (tree[i] && typeof tree[i] !== 'string') {
          markStaticNode(tree[i], key + "_" + i, isOnce);
        }
      }
    } else {
      markStaticNode(tree, key, isOnce);
    }
  }

  function markStaticNode(node, key, isOnce) {
    node.isStatic = true;
    node.key = key;
    node.isOnce = isOnce;
  }

  /*  */

  function bindObjectListeners(data, value) {
    if (value) {
      if (!isPlainObject(value)) {
        "development" !== 'production' && warn('v-on without argument expects an Object value', this);
      } else {
        var on = data.on = data.on ? extend({}, data.on) : {};
        for (var key in value) {
          var existing = on[key];
          var ours = value[key];
          on[key] = existing ? [].concat(existing, ours) : ours;
        }
      }
    }
    return data;
  }

  /*  */

  function installRenderHelpers(target) {
    target._o = markOnce;
    target._n = toNumber;
    target._s = toString;
    target._l = renderList;
    target._t = renderSlot;
    target._q = looseEqual;
    target._i = looseIndexOf;
    target._m = renderStatic;
    target._f = resolveFilter;
    target._k = checkKeyCodes;
    target._b = bindObjectProps;
    target._v = createTextVNode;
    target._e = createEmptyVNode;
    target._u = resolveScopedSlots;
    target._g = bindObjectListeners;
  }

  /*  */

  function FunctionalRenderContext(data, props, children, parent, Ctor) {
    var options = Ctor.options;
    // ensure the createElement function in functional components
    // gets a unique context - this is necessary for correct named slot check
    var contextVm;
    if (hasOwn(parent, '_uid')) {
      contextVm = Object.create(parent);
      // $flow-disable-line
      contextVm._original = parent;
    } else {
      // the context vm passed in is a functional context as well.
      // in this case we want to make sure we are able to get a hold to the
      // real context instance.
      contextVm = parent;
      // $flow-disable-line
      parent = parent._original;
    }
    var isCompiled = isTrue(options._compiled);
    var needNormalization = !isCompiled;

    this.data = data;
    this.props = props;
    this.children = children;
    this.parent = parent;
    this.listeners = data.on || emptyObject;
    this.injections = resolveInject(options.inject, parent);
    this.slots = function () {
      return resolveSlots(children, parent);
    };

    // support for compiled functional template
    if (isCompiled) {
      // exposing $options for renderStatic()
      this.$options = options;
      // pre-resolve slots for renderSlot()
      this.$slots = this.slots();
      this.$scopedSlots = data.scopedSlots || emptyObject;
    }

    if (options._scopeId) {
      this._c = function (a, b, c, d) {
        var vnode = createElement(contextVm, a, b, c, d, needNormalization);
        if (vnode && !Array.isArray(vnode)) {
          vnode.fnScopeId = options._scopeId;
          vnode.fnContext = parent;
        }
        return vnode;
      };
    } else {
      this._c = function (a, b, c, d) {
        return createElement(contextVm, a, b, c, d, needNormalization);
      };
    }
  }

  installRenderHelpers(FunctionalRenderContext.prototype);

  function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {
    var options = Ctor.options;
    var props = {};
    var propOptions = options.props;
    if (isDef(propOptions)) {
      for (var key in propOptions) {
        props[key] = validateProp(key, propOptions, propsData || emptyObject);
      }
    } else {
      if (isDef(data.attrs)) {
        mergeProps(props, data.attrs);
      }
      if (isDef(data.props)) {
        mergeProps(props, data.props);
      }
    }

    var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);

    var vnode = options.render.call(null, renderContext._c, renderContext);

    if (vnode instanceof VNode) {
      return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options);
    } else if (Array.isArray(vnode)) {
      var vnodes = normalizeChildren(vnode) || [];
      var res = new Array(vnodes.length);
      for (var i = 0; i < vnodes.length; i++) {
        res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options);
      }
      return res;
    }
  }

  function cloneAndMarkFunctionalResult(vnode, data, contextVm, options) {
    // #7817 clone node before setting fnContext, otherwise if the node is reused
    // (e.g. it was from a cached normal slot) the fnContext causes named slots
    // that should not be matched to match.
    var clone = cloneVNode(vnode);
    clone.fnContext = contextVm;
    clone.fnOptions = options;
    if (data.slot) {
      (clone.data || (clone.data = {})).slot = data.slot;
    }
    return clone;
  }

  function mergeProps(to, from) {
    for (var key in from) {
      to[camelize(key)] = from[key];
    }
  }

  /*  */

  // Register the component hook to weex native render engine.
  // The hook will be triggered by native, not javascript.


  // Updates the state of the component to weex native render engine.

  /*  */

  // https://github.com/Hanks10100/weex-native-directive/tree/master/component

  // listening on native callback

  /*  */

  /*  */

  // inline hooks to be invoked on component VNodes during patch
  var componentVNodeHooks = {
    init: function init(vnode, hydrating, parentElm, refElm) {
      if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {
        // kept-alive components, treat as a patch
        var mountedNode = vnode; // work around flow
        componentVNodeHooks.prepatch(mountedNode, mountedNode);
      } else {
        var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance, parentElm, refElm);
        child.$mount(hydrating ? vnode.elm : undefined, hydrating);
      }
    },

    prepatch: function prepatch(oldVnode, vnode) {
      var options = vnode.componentOptions;
      var child = vnode.componentInstance = oldVnode.componentInstance;
      updateChildComponent(child, options.propsData, // updated props
      options.listeners, // updated listeners
      vnode, // new parent vnode
      options.children // new children
      );
    },

    insert: function insert(vnode) {
      var context = vnode.context;
      var componentInstance = vnode.componentInstance;
      if (!componentInstance._isMounted) {
        componentInstance._isMounted = true;
        callHook(componentInstance, 'mounted');
      }
      if (vnode.data.keepAlive) {
        if (context._isMounted) {
          // vue-router#1212
          // During updates, a kept-alive component's child components may
          // change, so directly walking the tree here may call activated hooks
          // on incorrect children. Instead we push them into a queue which will
          // be processed after the whole patch process ended.
          queueActivatedComponent(componentInstance);
        } else {
          activateChildComponent(componentInstance, true /* direct */);
        }
      }
    },

    destroy: function destroy(vnode) {
      var componentInstance = vnode.componentInstance;
      if (!componentInstance._isDestroyed) {
        if (!vnode.data.keepAlive) {
          componentInstance.$destroy();
        } else {
          deactivateChildComponent(componentInstance, true /* direct */);
        }
      }
    }
  };

  var hooksToMerge = Object.keys(componentVNodeHooks);

  function createComponent(Ctor, data, context, children, tag) {
    if (isUndef(Ctor)) {
      return;
    }

    var baseCtor = context.$options._base;

    // plain options object: turn it into a constructor
    if (isObject(Ctor)) {
      Ctor = baseCtor.extend(Ctor);
    }

    // if at this stage it's not a constructor or an async component factory,
    // reject.
    if (typeof Ctor !== 'function') {
      {
        warn("Invalid Component definition: " + String(Ctor), context);
      }
      return;
    }

    // async component
    var asyncFactory;
    if (isUndef(Ctor.cid)) {
      asyncFactory = Ctor;
      Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);
      if (Ctor === undefined) {
        // return a placeholder node for async component, which is rendered
        // as a comment node but preserves all the raw information for the node.
        // the information will be used for async server-rendering and hydration.
        return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
      }
    }

    data = data || {};

    // resolve constructor options in case global mixins are applied after
    // component constructor creation
    resolveConstructorOptions(Ctor);

    // transform component v-model data into props & events
    if (isDef(data.model)) {
      transformModel(Ctor.options, data);
    }

    // extract props
    var propsData = extractPropsFromVNodeData(data, Ctor, tag);

    // functional component
    if (isTrue(Ctor.options.functional)) {
      return createFunctionalComponent(Ctor, propsData, data, context, children);
    }

    // extract listeners, since these needs to be treated as
    // child component listeners instead of DOM listeners
    var listeners = data.on;
    // replace with listeners with .native modifier
    // so it gets processed during parent component patch.
    data.on = data.nativeOn;

    if (isTrue(Ctor.options.abstract)) {
      // abstract components do not keep anything
      // other than props & listeners & slot

      // work around flow
      var slot = data.slot;
      data = {};
      if (slot) {
        data.slot = slot;
      }
    }

    // install component management hooks onto the placeholder node
    installComponentHooks(data);

    // return a placeholder vnode
    var name = Ctor.options.name || tag;
    var vnode = new VNode("vue-component-" + Ctor.cid + (name ? "-" + name : ''), data, undefined, undefined, undefined, context, { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }, asyncFactory);

    // Weex specific: invoke recycle-list optimized @render function for
    // extracting cell-slot template.
    // https://github.com/Hanks10100/weex-native-directive/tree/master/component
    /* istanbul ignore if */
    return vnode;
  }

  function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't
  parent, // activeInstance in lifecycle state
  parentElm, refElm) {
    var options = {
      _isComponent: true,
      parent: parent,
      _parentVnode: vnode,
      _parentElm: parentElm || null,
      _refElm: refElm || null
    };
    // check inline-template render functions
    var inlineTemplate = vnode.data.inlineTemplate;
    if (isDef(inlineTemplate)) {
      options.render = inlineTemplate.render;
      options.staticRenderFns = inlineTemplate.staticRenderFns;
    }
    return new vnode.componentOptions.Ctor(options);
  }

  function installComponentHooks(data) {
    var hooks = data.hook || (data.hook = {});
    for (var i = 0; i < hooksToMerge.length; i++) {
      var key = hooksToMerge[i];
      hooks[key] = componentVNodeHooks[key];
    }
  }

  // transform component v-model info (value and callback) into
  // prop and event handler respectively.
  function transformModel(options, data) {
    var prop = options.model && options.model.prop || 'value';
    var event = options.model && options.model.event || 'input';(data.props || (data.props = {}))[prop] = data.model.value;
    var on = data.on || (data.on = {});
    if (isDef(on[event])) {
      on[event] = [data.model.callback].concat(on[event]);
    } else {
      on[event] = data.model.callback;
    }
  }

  /*  */

  var SIMPLE_NORMALIZE = 1;
  var ALWAYS_NORMALIZE = 2;

  // wrapper function for providing a more flexible interface
  // without getting yelled at by flow
  function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {
    if (Array.isArray(data) || isPrimitive(data)) {
      normalizationType = children;
      children = data;
      data = undefined;
    }
    if (isTrue(alwaysNormalize)) {
      normalizationType = ALWAYS_NORMALIZE;
    }
    return _createElement(context, tag, data, children, normalizationType);
  }

  function _createElement(context, tag, data, children, normalizationType) {
    if (isDef(data) && isDef(data.__ob__)) {
      "development" !== 'production' && warn("Avoid using observed data object as vnode data: " + JSON.stringify(data) + "\n" + 'Always create fresh vnode data objects in each render!', context);
      return createEmptyVNode();
    }
    // object syntax in v-bind
    if (isDef(data) && isDef(data.is)) {
      tag = data.is;
    }
    if (!tag) {
      // in case of component :is set to falsy value
      return createEmptyVNode();
    }
    // warn against non-primitive key
    if ("development" !== 'production' && isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {
      {
        warn('Avoid using non-primitive value as key, ' + 'use string/number value instead.', context);
      }
    }
    // support single function children as default scoped slot
    if (Array.isArray(children) && typeof children[0] === 'function') {
      data = data || {};
      data.scopedSlots = { default: children[0] };
      children.length = 0;
    }
    if (normalizationType === ALWAYS_NORMALIZE) {
      children = normalizeChildren(children);
    } else if (normalizationType === SIMPLE_NORMALIZE) {
      children = simpleNormalizeChildren(children);
    }
    var vnode, ns;
    if (typeof tag === 'string') {
      var Ctor;
      ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);
      if (config.isReservedTag(tag)) {
        // platform built-in elements
        vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);
      } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
        // component
        vnode = createComponent(Ctor, data, context, children, tag);
      } else {
        // unknown or unlisted namespaced elements
        // check at runtime because it may get assigned a namespace when its
        // parent normalizes children
        vnode = new VNode(tag, data, children, undefined, undefined, context);
      }
    } else {
      // direct component options / constructor
      vnode = createComponent(tag, data, context, children);
    }
    if (Array.isArray(vnode)) {
      return vnode;
    } else if (isDef(vnode)) {
      if (isDef(ns)) {
        applyNS(vnode, ns);
      }
      if (isDef(data)) {
        registerDeepBindings(data);
      }
      return vnode;
    } else {
      return createEmptyVNode();
    }
  }

  function applyNS(vnode, ns, force) {
    vnode.ns = ns;
    if (vnode.tag === 'foreignObject') {
      // use default namespace inside foreignObject
      ns = undefined;
      force = true;
    }
    if (isDef(vnode.children)) {
      for (var i = 0, l = vnode.children.length; i < l; i++) {
        var child = vnode.children[i];
        if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force) && child.tag !== 'svg')) {
          applyNS(child, ns, force);
        }
      }
    }
  }

  // ref #5318
  // necessary to ensure parent re-render when deep bindings like :style and
  // :class are used on slot nodes
  function registerDeepBindings(data) {
    if (isObject(data.style)) {
      traverse(data.style);
    }
    if (isObject(data.class)) {
      traverse(data.class);
    }
  }

  /*  */

  function initRender(vm) {
    vm._vnode = null; // the root of the child tree
    vm._staticTrees = null; // v-once cached trees
    var options = vm.$options;
    var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree
    var renderContext = parentVnode && parentVnode.context;
    vm.$slots = resolveSlots(options._renderChildren, renderContext);
    vm.$scopedSlots = emptyObject;
    // bind the createElement fn to this instance
    // so that we get proper render context inside it.
    // args order: tag, data, children, normalizationType, alwaysNormalize
    // internal version is used by render functions compiled from templates
    vm._c = function (a, b, c, d) {
      return createElement(vm, a, b, c, d, false);
    };
    // normalization is always applied for the public version, used in
    // user-written render functions.
    vm.$createElement = function (a, b, c, d) {
      return createElement(vm, a, b, c, d, true);
    };

    // $attrs & $listeners are exposed for easier HOC creation.
    // they need to be reactive so that HOCs using them are always updated
    var parentData = parentVnode && parentVnode.data;

    /* istanbul ignore else */
    {
      defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {
        !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
      }, true);
      defineReactive(vm, '$listeners', options._parentListeners || emptyObject, function () {
        !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
      }, true);
    }
  }

  function renderMixin(Vue) {
    // install runtime convenience helpers
    installRenderHelpers(Vue.prototype);

    Vue.prototype.$nextTick = function (fn) {
      return nextTick(fn, this);
    };

    Vue.prototype._render = function () {
      var vm = this;
      var ref = vm.$options;
      var render = ref.render;
      var _parentVnode = ref._parentVnode;

      // reset _rendered flag on slots for duplicate slot check
      {
        for (var key in vm.$slots) {
          // $flow-disable-line
          vm.$slots[key]._rendered = false;
        }
      }

      if (_parentVnode) {
        vm.$scopedSlots = _parentVnode.data.scopedSlots || emptyObject;
      }

      // set parent vnode. this allows render functions to have access
      // to the data on the placeholder node.
      vm.$vnode = _parentVnode;
      // render self
      var vnode;
      try {
        vnode = render.call(vm._renderProxy, vm.$createElement);
      } catch (e) {
        handleError(e, vm, "render");
        // return error render result,
        // or previous vnode to prevent render error causing blank component
        /* istanbul ignore else */
        {
          if (vm.$options.renderError) {
            try {
              vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
            } catch (e) {
              handleError(e, vm, "renderError");
              vnode = vm._vnode;
            }
          } else {
            vnode = vm._vnode;
          }
        }
      }
      // return empty vnode in case the render function errored out
      if (!(vnode instanceof VNode)) {
        if ("development" !== 'production' && Array.isArray(vnode)) {
          warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);
        }
        vnode = createEmptyVNode();
      }
      // set parent
      vnode.parent = _parentVnode;
      return vnode;
    };
  }

  /*  */

  var uid$3 = 0;

  function initMixin(Vue) {
    Vue.prototype._init = function (options) {
      var vm = this;
      // a uid
      vm._uid = uid$3++;

      var startTag, endTag;
      /* istanbul ignore if */
      if ("development" !== 'production' && config.performance && mark) {
        startTag = "vue-perf-start:" + vm._uid;
        endTag = "vue-perf-end:" + vm._uid;
        mark(startTag);
      }

      // a flag to avoid this being observed
      vm._isVue = true;
      // merge options
      if (options && options._isComponent) {
        // optimize internal component instantiation
        // since dynamic options merging is pretty slow, and none of the
        // internal component options needs special treatment.
        initInternalComponent(vm, options);
      } else {
        vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
      }
      /* istanbul ignore else */
      {
        initProxy(vm);
      }
      // expose real self
      vm._self = vm;
      initLifecycle(vm);
      initEvents(vm);
      initRender(vm);
      callHook(vm, 'beforeCreate');
      initInjections(vm); // resolve injections before data/props
      initState(vm);
      initProvide(vm); // resolve provide after data/props
      callHook(vm, 'created');

      /* istanbul ignore if */
      if ("development" !== 'production' && config.performance && mark) {
        vm._name = formatComponentName(vm, false);
        mark(endTag);
        measure("vue " + vm._name + " init", startTag, endTag);
      }

      if (vm.$options.el) {
        vm.$mount(vm.$options.el);
      }
    };
  }

  function initInternalComponent(vm, options) {
    var opts = vm.$options = Object.create(vm.constructor.options);
    // doing this because it's faster than dynamic enumeration.
    var parentVnode = options._parentVnode;
    opts.parent = options.parent;
    opts._parentVnode = parentVnode;
    opts._parentElm = options._parentElm;
    opts._refElm = options._refElm;

    var vnodeComponentOptions = parentVnode.componentOptions;
    opts.propsData = vnodeComponentOptions.propsData;
    opts._parentListeners = vnodeComponentOptions.listeners;
    opts._renderChildren = vnodeComponentOptions.children;
    opts._componentTag = vnodeComponentOptions.tag;

    if (options.render) {
      opts.render = options.render;
      opts.staticRenderFns = options.staticRenderFns;
    }
  }

  function resolveConstructorOptions(Ctor) {
    var options = Ctor.options;
    if (Ctor.super) {
      var superOptions = resolveConstructorOptions(Ctor.super);
      var cachedSuperOptions = Ctor.superOptions;
      if (superOptions !== cachedSuperOptions) {
        // super option changed,
        // need to resolve new options.
        Ctor.superOptions = superOptions;
        // check if there are any late-modified/attached options (#4976)
        var modifiedOptions = resolveModifiedOptions(Ctor);
        // update base extend options
        if (modifiedOptions) {
          extend(Ctor.extendOptions, modifiedOptions);
        }
        options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
        if (options.name) {
          options.components[options.name] = Ctor;
        }
      }
    }
    return options;
  }

  function resolveModifiedOptions(Ctor) {
    var modified;
    var latest = Ctor.options;
    var extended = Ctor.extendOptions;
    var sealed = Ctor.sealedOptions;
    for (var key in latest) {
      if (latest[key] !== sealed[key]) {
        if (!modified) {
          modified = {};
        }
        modified[key] = dedupe(latest[key], extended[key], sealed[key]);
      }
    }
    return modified;
  }

  function dedupe(latest, extended, sealed) {
    // compare latest and sealed to ensure lifecycle hooks won't be duplicated
    // between merges
    if (Array.isArray(latest)) {
      var res = [];
      sealed = Array.isArray(sealed) ? sealed : [sealed];
      extended = Array.isArray(extended) ? extended : [extended];
      for (var i = 0; i < latest.length; i++) {
        // push original options and not sealed options to exclude duplicated options
        if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {
          res.push(latest[i]);
        }
      }
      return res;
    } else {
      return latest;
    }
  }

  function Vue(options) {
    if ("development" !== 'production' && !(this instanceof Vue)) {
      warn('Vue is a constructor and should be called with the `new` keyword');
    }
    this._init(options);
  }

  initMixin(Vue);
  stateMixin(Vue);
  eventsMixin(Vue);
  lifecycleMixin(Vue);
  renderMixin(Vue);

  /*  */

  function initUse(Vue) {
    Vue.use = function (plugin) {
      var installedPlugins = this._installedPlugins || (this._installedPlugins = []);
      if (installedPlugins.indexOf(plugin) > -1) {
        return this;
      }

      // additional parameters
      var args = toArray(arguments, 1);
      args.unshift(this);
      if (typeof plugin.install === 'function') {
        plugin.install.apply(plugin, args);
      } else if (typeof plugin === 'function') {
        plugin.apply(null, args);
      }
      installedPlugins.push(plugin);
      return this;
    };
  }

  /*  */

  function initMixin$1(Vue) {
    Vue.mixin = function (mixin) {
      this.options = mergeOptions(this.options, mixin);
      return this;
    };
  }

  /*  */

  function initExtend(Vue) {
    /**
     * Each instance constructor, including Vue, has a unique
     * cid. This enables us to create wrapped "child
     * constructors" for prototypal inheritance and cache them.
     */
    Vue.cid = 0;
    var cid = 1;

    /**
     * Class inheritance
     */
    Vue.extend = function (extendOptions) {
      extendOptions = extendOptions || {};
      var Super = this;
      var SuperId = Super.cid;
      var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
      if (cachedCtors[SuperId]) {
        return cachedCtors[SuperId];
      }

      var name = extendOptions.name || Super.options.name;
      if ("development" !== 'production' && name) {
        validateComponentName(name);
      }

      var Sub = function VueComponent(options) {
        this._init(options);
      };
      Sub.prototype = Object.create(Super.prototype);
      Sub.prototype.constructor = Sub;
      Sub.cid = cid++;
      Sub.options = mergeOptions(Super.options, extendOptions);
      Sub['super'] = Super;

      // For props and computed properties, we define the proxy getters on
      // the Vue instances at extension time, on the extended prototype. This
      // avoids Object.defineProperty calls for each instance created.
      if (Sub.options.props) {
        initProps$1(Sub);
      }
      if (Sub.options.computed) {
        initComputed$1(Sub);
      }

      // allow further extension/mixin/plugin usage
      Sub.extend = Super.extend;
      Sub.mixin = Super.mixin;
      Sub.use = Super.use;

      // create asset registers, so extended classes
      // can have their private assets too.
      ASSET_TYPES.forEach(function (type) {
        Sub[type] = Super[type];
      });
      // enable recursive self-lookup
      if (name) {
        Sub.options.components[name] = Sub;
      }

      // keep a reference to the super options at extension time.
      // later at instantiation we can check if Super's options have
      // been updated.
      Sub.superOptions = Super.options;
      Sub.extendOptions = extendOptions;
      Sub.sealedOptions = extend({}, Sub.options);

      // cache constructor
      cachedCtors[SuperId] = Sub;
      return Sub;
    };
  }

  function initProps$1(Comp) {
    var props = Comp.options.props;
    for (var key in props) {
      proxy(Comp.prototype, "_props", key);
    }
  }

  function initComputed$1(Comp) {
    var computed = Comp.options.computed;
    for (var key in computed) {
      defineComputed(Comp.prototype, key, computed[key]);
    }
  }

  /*  */

  function initAssetRegisters(Vue) {
    /**
     * Create asset registration methods.
     */
    ASSET_TYPES.forEach(function (type) {
      Vue[type] = function (id, definition) {
        if (!definition) {
          return this.options[type + 's'][id];
        } else {
          /* istanbul ignore if */
          if ("development" !== 'production' && type === 'component') {
            validateComponentName(id);
          }
          if (type === 'component' && isPlainObject(definition)) {
            definition.name = definition.name || id;
            definition = this.options._base.extend(definition);
          }
          if (type === 'directive' && typeof definition === 'function') {
            definition = { bind: definition, update: definition };
          }
          this.options[type + 's'][id] = definition;
          return definition;
        }
      };
    });
  }

  /*  */

  function getComponentName(opts) {
    return opts && (opts.Ctor.options.name || opts.tag);
  }

  function matches(pattern, name) {
    if (Array.isArray(pattern)) {
      return pattern.indexOf(name) > -1;
    } else if (typeof pattern === 'string') {
      return pattern.split(',').indexOf(name) > -1;
    } else if (isRegExp(pattern)) {
      return pattern.test(name);
    }
    /* istanbul ignore next */
    return false;
  }

  function pruneCache(keepAliveInstance, filter) {
    var cache = keepAliveInstance.cache;
    var keys = keepAliveInstance.keys;
    var _vnode = keepAliveInstance._vnode;
    for (var key in cache) {
      var cachedNode = cache[key];
      if (cachedNode) {
        var name = getComponentName(cachedNode.componentOptions);
        if (name && !filter(name)) {
          pruneCacheEntry(cache, key, keys, _vnode);
        }
      }
    }
  }

  function pruneCacheEntry(cache, key, keys, current) {
    var cached$$1 = cache[key];
    if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {
      cached$$1.componentInstance.$destroy();
    }
    cache[key] = null;
    remove(keys, key);
  }

  var patternTypes = [String, RegExp, Array];

  var KeepAlive = {
    name: 'keep-alive',
    abstract: true,

    props: {
      include: patternTypes,
      exclude: patternTypes,
      max: [String, Number]
    },

    created: function created() {
      this.cache = Object.create(null);
      this.keys = [];
    },

    destroyed: function destroyed() {
      var this$1 = this;

      for (var key in this$1.cache) {
        pruneCacheEntry(this$1.cache, key, this$1.keys);
      }
    },

    mounted: function mounted() {
      var this$1 = this;

      this.$watch('include', function (val) {
        pruneCache(this$1, function (name) {
          return matches(val, name);
        });
      });
      this.$watch('exclude', function (val) {
        pruneCache(this$1, function (name) {
          return !matches(val, name);
        });
      });
    },

    render: function render() {
      var slot = this.$slots.default;
      var vnode = getFirstComponentChild(slot);
      var componentOptions = vnode && vnode.componentOptions;
      if (componentOptions) {
        // check pattern
        var name = getComponentName(componentOptions);
        var ref = this;
        var include = ref.include;
        var exclude = ref.exclude;
        if (
        // not included
        include && (!name || !matches(include, name)) ||
        // excluded
        exclude && name && matches(exclude, name)) {
          return vnode;
        }

        var ref$1 = this;
        var cache = ref$1.cache;
        var keys = ref$1.keys;
        var key = vnode.key == null
        // same constructor may get registered as different local components
        // so cid alone is not enough (#3269)
        ? componentOptions.Ctor.cid + (componentOptions.tag ? "::" + componentOptions.tag : '') : vnode.key;
        if (cache[key]) {
          vnode.componentInstance = cache[key].componentInstance;
          // make current key freshest
          remove(keys, key);
          keys.push(key);
        } else {
          cache[key] = vnode;
          keys.push(key);
          // prune oldest entry
          if (this.max && keys.length > parseInt(this.max)) {
            pruneCacheEntry(cache, keys[0], keys, this._vnode);
          }
        }

        vnode.data.keepAlive = true;
      }
      return vnode || slot && slot[0];
    }
  };

  var builtInComponents = {
    KeepAlive: KeepAlive

    /*  */

  };function initGlobalAPI(Vue) {
    // config
    var configDef = {};
    configDef.get = function () {
      return config;
    };
    {
      configDef.set = function () {
        warn('Do not replace the Vue.config object, set individual fields instead.');
      };
    }
    Object.defineProperty(Vue, 'config', configDef);

    // exposed util methods.
    // NOTE: these are not considered part of the public API - avoid relying on
    // them unless you are aware of the risk.
    Vue.util = {
      warn: warn,
      extend: extend,
      mergeOptions: mergeOptions,
      defineReactive: defineReactive
    };

    Vue.set = set;
    Vue.delete = del;
    Vue.nextTick = nextTick;

    Vue.options = Object.create(null);
    ASSET_TYPES.forEach(function (type) {
      Vue.options[type + 's'] = Object.create(null);
    });

    // this is used to identify the "base" constructor to extend all plain-object
    // components with in Weex's multi-instance scenarios.
    Vue.options._base = Vue;

    extend(Vue.options.components, builtInComponents);

    initUse(Vue);
    initMixin$1(Vue);
    initExtend(Vue);
    initAssetRegisters(Vue);
  }

  initGlobalAPI(Vue);

  Object.defineProperty(Vue.prototype, '$isServer', {
    get: isServerRendering
  });

  Object.defineProperty(Vue.prototype, '$ssrContext', {
    get: function get() {
      /* istanbul ignore next */
      return this.$vnode && this.$vnode.ssrContext;
    }
  });

  // expose FunctionalRenderContext for ssr runtime helper installation
  Object.defineProperty(Vue, 'FunctionalRenderContext', {
    value: FunctionalRenderContext
  });

  Vue.version = '2.5.16';

  /*  */

  // these are reserved for web because they are directly compiled away
  // during template compilation
  var isReservedAttr = makeMap('style,class');

  // attributes that should be using props for binding
  var acceptValue = makeMap('input,textarea,option,select,progress');
  var mustUseProp = function mustUseProp(tag, type, attr) {
    return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';
  };

  var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

  var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');

  var xlinkNS = 'http://www.w3.org/1999/xlink';

  var isXlink = function isXlink(name) {
    return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';
  };

  var getXlinkProp = function getXlinkProp(name) {
    return isXlink(name) ? name.slice(6, name.length) : '';
  };

  var isFalsyAttrValue = function isFalsyAttrValue(val) {
    return val == null || val === false;
  };

  /*  */

  function genClassForVnode(vnode) {
    var data = vnode.data;
    var parentNode = vnode;
    var childNode = vnode;
    while (isDef(childNode.componentInstance)) {
      childNode = childNode.componentInstance._vnode;
      if (childNode && childNode.data) {
        data = mergeClassData(childNode.data, data);
      }
    }
    while (isDef(parentNode = parentNode.parent)) {
      if (parentNode && parentNode.data) {
        data = mergeClassData(data, parentNode.data);
      }
    }
    return renderClass(data.staticClass, data.class);
  }

  function mergeClassData(child, parent) {
    return {
      staticClass: concat(child.staticClass, parent.staticClass),
      class: isDef(child.class) ? [child.class, parent.class] : parent.class
    };
  }

  function renderClass(staticClass, dynamicClass) {
    if (isDef(staticClass) || isDef(dynamicClass)) {
      return concat(staticClass, stringifyClass(dynamicClass));
    }
    /* istanbul ignore next */
    return '';
  }

  function concat(a, b) {
    return a ? b ? a + ' ' + b : a : b || '';
  }

  function stringifyClass(value) {
    if (Array.isArray(value)) {
      return stringifyArray(value);
    }
    if (isObject(value)) {
      return stringifyObject(value);
    }
    if (typeof value === 'string') {
      return value;
    }
    /* istanbul ignore next */
    return '';
  }

  function stringifyArray(value) {
    var res = '';
    var stringified;
    for (var i = 0, l = value.length; i < l; i++) {
      if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
        if (res) {
          res += ' ';
        }
        res += stringified;
      }
    }
    return res;
  }

  function stringifyObject(value) {
    var res = '';
    for (var key in value) {
      if (value[key]) {
        if (res) {
          res += ' ';
        }
        res += key;
      }
    }
    return res;
  }

  /*  */

  var namespaceMap = {
    svg: 'http://www.w3.org/2000/svg',
    math: 'http://www.w3.org/1998/Math/MathML'
  };

  var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot');

  // this map is intentionally selective, only covering SVG elements that may
  // contain child elements.
  var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);

  var isPreTag = function isPreTag(tag) {
    return tag === 'pre';
  };

  var isReservedTag = function isReservedTag(tag) {
    return isHTMLTag(tag) || isSVG(tag);
  };

  function getTagNamespace(tag) {
    if (isSVG(tag)) {
      return 'svg';
    }
    // basic support for MathML
    // note it doesn't support other MathML elements being component roots
    if (tag === 'math') {
      return 'math';
    }
  }

  var unknownElementCache = Object.create(null);
  function isUnknownElement(tag) {
    /* istanbul ignore if */
    if (!inBrowser) {
      return true;
    }
    if (isReservedTag(tag)) {
      return false;
    }
    tag = tag.toLowerCase();
    /* istanbul ignore if */
    if (unknownElementCache[tag] != null) {
      return unknownElementCache[tag];
    }
    var el = document.createElement(tag);
    if (tag.indexOf('-') > -1) {
      // http://stackoverflow.com/a/28210364/1070244
      return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
    } else {
      return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());
    }
  }

  var isTextInputType = makeMap('text,number,password,search,email,tel,url');

  /*  */

  /**
   * Query an element selector if it's not an element already.
   */
  function query(el) {
    if (typeof el === 'string') {
      var selected = document.querySelector(el);
      if (!selected) {
        "development" !== 'production' && warn('Cannot find element: ' + el);
        return document.createElement('div');
      }
      return selected;
    } else {
      return el;
    }
  }

  /*  */

  function createElement$1(tagName, vnode) {
    var elm = document.createElement(tagName);
    if (tagName !== 'select') {
      return elm;
    }
    // false or null will remove the attribute but undefined will not
    if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
      elm.setAttribute('multiple', 'multiple');
    }
    return elm;
  }

  function createElementNS(namespace, tagName) {
    return document.createElementNS(namespaceMap[namespace], tagName);
  }

  function createTextNode(text) {
    return document.createTextNode(text);
  }

  function createComment(text) {
    return document.createComment(text);
  }

  function insertBefore(parentNode, newNode, referenceNode) {
    parentNode.insertBefore(newNode, referenceNode);
  }

  function removeChild(node, child) {
    node.removeChild(child);
  }

  function appendChild(node, child) {
    node.appendChild(child);
  }

  function parentNode(node) {
    return node.parentNode;
  }

  function nextSibling(node) {
    return node.nextSibling;
  }

  function tagName(node) {
    return node.tagName;
  }

  function setTextContent(node, text) {
    node.textContent = text;
  }

  function setStyleScope(node, scopeId) {
    node.setAttribute(scopeId, '');
  }

  var nodeOps = Object.freeze({
    createElement: createElement$1,
    createElementNS: createElementNS,
    createTextNode: createTextNode,
    createComment: createComment,
    insertBefore: insertBefore,
    removeChild: removeChild,
    appendChild: appendChild,
    parentNode: parentNode,
    nextSibling: nextSibling,
    tagName: tagName,
    setTextContent: setTextContent,
    setStyleScope: setStyleScope
  });

  /*  */

  var ref = {
    create: function create(_, vnode) {
      registerRef(vnode);
    },
    update: function update(oldVnode, vnode) {
      if (oldVnode.data.ref !== vnode.data.ref) {
        registerRef(oldVnode, true);
        registerRef(vnode);
      }
    },
    destroy: function destroy(vnode) {
      registerRef(vnode, true);
    }
  };

  function registerRef(vnode, isRemoval) {
    var key = vnode.data.ref;
    if (!isDef(key)) {
      return;
    }

    var vm = vnode.context;
    var ref = vnode.componentInstance || vnode.elm;
    var refs = vm.$refs;
    if (isRemoval) {
      if (Array.isArray(refs[key])) {
        remove(refs[key], ref);
      } else if (refs[key] === ref) {
        refs[key] = undefined;
      }
    } else {
      if (vnode.data.refInFor) {
        if (!Array.isArray(refs[key])) {
          refs[key] = [ref];
        } else if (refs[key].indexOf(ref) < 0) {
          // $flow-disable-line
          refs[key].push(ref);
        }
      } else {
        refs[key] = ref;
      }
    }
  }

  /**
   * Virtual DOM patching algorithm based on Snabbdom by
   * Simon Friis Vindum (@paldepind)
   * Licensed under the MIT License
   * https://github.com/paldepind/snabbdom/blob/master/LICENSE
   *
   * modified by Evan You (@yyx990803)
   *
   * Not type-checking this because this file is perf-critical and the cost
   * of making flow understand it is not worth it.
   */

  var emptyNode = new VNode('', {}, []);

  var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

  function sameVnode(a, b) {
    return a.key === b.key && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && a.asyncFactory === b.asyncFactory && isUndef(b.asyncFactory.error));
  }

  function sameInputType(a, b) {
    if (a.tag !== 'input') {
      return true;
    }
    var i;
    var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
    var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
    return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);
  }

  function createKeyToOldIdx(children, beginIdx, endIdx) {
    var i, key;
    var map = {};
    for (i = beginIdx; i <= endIdx; ++i) {
      key = children[i].key;
      if (isDef(key)) {
        map[key] = i;
      }
    }
    return map;
  }

  function createPatchFunction(backend) {
    var i, j;
    var cbs = {};

    var modules = backend.modules;
    var nodeOps = backend.nodeOps;

    for (i = 0; i < hooks.length; ++i) {
      cbs[hooks[i]] = [];
      for (j = 0; j < modules.length; ++j) {
        if (isDef(modules[j][hooks[i]])) {
          cbs[hooks[i]].push(modules[j][hooks[i]]);
        }
      }
    }

    function emptyNodeAt(elm) {
      return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);
    }

    function createRmCb(childElm, listeners) {
      function remove() {
        if (--remove.listeners === 0) {
          removeNode(childElm);
        }
      }
      remove.listeners = listeners;
      return remove;
    }

    function removeNode(el) {
      var parent = nodeOps.parentNode(el);
      // element may have already been removed due to v-html / v-text
      if (isDef(parent)) {
        nodeOps.removeChild(parent, el);
      }
    }

    function isUnknownElement$$1(vnode, inVPre) {
      return !inVPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.some(function (ignore) {
        return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag;
      })) && config.isUnknownElement(vnode.tag);
    }

    var creatingElmInVPre = 0;

    function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {
      if (isDef(vnode.elm) && isDef(ownerArray)) {
        // This vnode was used in a previous render!
        // now it's used as a new node, overwriting its elm would cause
        // potential patch errors down the road when it's used as an insertion
        // reference node. Instead, we clone the node on-demand before creating
        // associated DOM element for it.
        vnode = ownerArray[index] = cloneVNode(vnode);
      }

      vnode.isRootInsert = !nested; // for transition enter check
      if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
        return;
      }

      var data = vnode.data;
      var children = vnode.children;
      var tag = vnode.tag;
      if (isDef(tag)) {
        {
          if (data && data.pre) {
            creatingElmInVPre++;
          }
          if (isUnknownElement$$1(vnode, creatingElmInVPre)) {
            warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.', vnode.context);
          }
        }

        vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);
        setScope(vnode);

        /* istanbul ignore if */
        {
          createChildren(vnode, children, insertedVnodeQueue);
          if (isDef(data)) {
            invokeCreateHooks(vnode, insertedVnodeQueue);
          }
          insert(parentElm, vnode.elm, refElm);
        }

        if ("development" !== 'production' && data && data.pre) {
          creatingElmInVPre--;
        }
      } else if (isTrue(vnode.isComment)) {
        vnode.elm = nodeOps.createComment(vnode.text);
        insert(parentElm, vnode.elm, refElm);
      } else {
        vnode.elm = nodeOps.createTextNode(vnode.text);
        insert(parentElm, vnode.elm, refElm);
      }
    }

    function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
      var i = vnode.data;
      if (isDef(i)) {
        var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
        if (isDef(i = i.hook) && isDef(i = i.init)) {
          i(vnode, false /* hydrating */, parentElm, refElm);
        }
        // after calling the init hook, if the vnode is a child component
        // it should've created a child instance and mounted it. the child
        // component also has set the placeholder vnode's elm.
        // in that case we can just return the element and be done.
        if (isDef(vnode.componentInstance)) {
          initComponent(vnode, insertedVnodeQueue);
          if (isTrue(isReactivated)) {
            reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
          }
          return true;
        }
      }
    }

    function initComponent(vnode, insertedVnodeQueue) {
      if (isDef(vnode.data.pendingInsert)) {
        insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
        vnode.data.pendingInsert = null;
      }
      vnode.elm = vnode.componentInstance.$el;
      if (isPatchable(vnode)) {
        invokeCreateHooks(vnode, insertedVnodeQueue);
        setScope(vnode);
      } else {
        // empty component root.
        // skip all element-related modules except for ref (#3455)
        registerRef(vnode);
        // make sure to invoke the insert hook
        insertedVnodeQueue.push(vnode);
      }
    }

    function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
      var i;
      // hack for #4339: a reactivated component with inner transition
      // does not trigger because the inner node's created hooks are not called
      // again. It's not ideal to involve module-specific logic in here but
      // there doesn't seem to be a better way to do it.
      var innerNode = vnode;
      while (innerNode.componentInstance) {
        innerNode = innerNode.componentInstance._vnode;
        if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
          for (i = 0; i < cbs.activate.length; ++i) {
            cbs.activate[i](emptyNode, innerNode);
          }
          insertedVnodeQueue.push(innerNode);
          break;
        }
      }
      // unlike a newly created component,
      // a reactivated keep-alive component doesn't insert itself
      insert(parentElm, vnode.elm, refElm);
    }

    function insert(parent, elm, ref$$1) {
      if (isDef(parent)) {
        if (isDef(ref$$1)) {
          if (ref$$1.parentNode === parent) {
            nodeOps.insertBefore(parent, elm, ref$$1);
          }
        } else {
          nodeOps.appendChild(parent, elm);
        }
      }
    }

    function createChildren(vnode, children, insertedVnodeQueue) {
      if (Array.isArray(children)) {
        {
          checkDuplicateKeys(children);
        }
        for (var i = 0; i < children.length; ++i) {
          createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);
        }
      } else if (isPrimitive(vnode.text)) {
        nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
      }
    }

    function isPatchable(vnode) {
      while (vnode.componentInstance) {
        vnode = vnode.componentInstance._vnode;
      }
      return isDef(vnode.tag);
    }

    function invokeCreateHooks(vnode, insertedVnodeQueue) {
      for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
        cbs.create[i$1](emptyNode, vnode);
      }
      i = vnode.data.hook; // Reuse variable
      if (isDef(i)) {
        if (isDef(i.create)) {
          i.create(emptyNode, vnode);
        }
        if (isDef(i.insert)) {
          insertedVnodeQueue.push(vnode);
        }
      }
    }

    // set scope id attribute for scoped CSS.
    // this is implemented as a special case to avoid the overhead
    // of going through the normal attribute patching process.
    function setScope(vnode) {
      var i;
      if (isDef(i = vnode.fnScopeId)) {
        nodeOps.setStyleScope(vnode.elm, i);
      } else {
        var ancestor = vnode;
        while (ancestor) {
          if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
            nodeOps.setStyleScope(vnode.elm, i);
          }
          ancestor = ancestor.parent;
        }
      }
      // for slot content they should also get the scopeId from the host instance.
      if (isDef(i = activeInstance) && i !== vnode.context && i !== vnode.fnContext && isDef(i = i.$options._scopeId)) {
        nodeOps.setStyleScope(vnode.elm, i);
      }
    }

    function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
      for (; startIdx <= endIdx; ++startIdx) {
        createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
      }
    }

    function invokeDestroyHook(vnode) {
      var i, j;
      var data = vnode.data;
      if (isDef(data)) {
        if (isDef(i = data.hook) && isDef(i = i.destroy)) {
          i(vnode);
        }
        for (i = 0; i < cbs.destroy.length; ++i) {
          cbs.destroy[i](vnode);
        }
      }
      if (isDef(i = vnode.children)) {
        for (j = 0; j < vnode.children.length; ++j) {
          invokeDestroyHook(vnode.children[j]);
        }
      }
    }

    function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
      for (; startIdx <= endIdx; ++startIdx) {
        var ch = vnodes[startIdx];
        if (isDef(ch)) {
          if (isDef(ch.tag)) {
            removeAndInvokeRemoveHook(ch);
            invokeDestroyHook(ch);
          } else {
            // Text node
            removeNode(ch.elm);
          }
        }
      }
    }

    function removeAndInvokeRemoveHook(vnode, rm) {
      if (isDef(rm) || isDef(vnode.data)) {
        var i;
        var listeners = cbs.remove.length + 1;
        if (isDef(rm)) {
          // we have a recursively passed down rm callback
          // increase the listeners count
          rm.listeners += listeners;
        } else {
          // directly removing
          rm = createRmCb(vnode.elm, listeners);
        }
        // recursively invoke hooks on child component root node
        if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
          removeAndInvokeRemoveHook(i, rm);
        }
        for (i = 0; i < cbs.remove.length; ++i) {
          cbs.remove[i](vnode, rm);
        }
        if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
          i(vnode, rm);
        } else {
          rm();
        }
      } else {
        removeNode(vnode.elm);
      }
    }

    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
      var oldStartIdx = 0;
      var newStartIdx = 0;
      var oldEndIdx = oldCh.length - 1;
      var oldStartVnode = oldCh[0];
      var oldEndVnode = oldCh[oldEndIdx];
      var newEndIdx = newCh.length - 1;
      var newStartVnode = newCh[0];
      var newEndVnode = newCh[newEndIdx];
      var oldKeyToIdx, idxInOld, vnodeToMove, refElm;

      // removeOnly is a special flag used only by <transition-group>
      // to ensure removed elements stay in correct relative positions
      // during leaving transitions
      var canMove = !removeOnly;

      {
        checkDuplicateKeys(newCh);
      }

      while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
        if (isUndef(oldStartVnode)) {
          oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
        } else if (isUndef(oldEndVnode)) {
          oldEndVnode = oldCh[--oldEndIdx];
        } else if (sameVnode(oldStartVnode, newStartVnode)) {
          patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
          oldStartVnode = oldCh[++oldStartIdx];
          newStartVnode = newCh[++newStartIdx];
        } else if (sameVnode(oldEndVnode, newEndVnode)) {
          patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
          oldEndVnode = oldCh[--oldEndIdx];
          newEndVnode = newCh[--newEndIdx];
        } else if (sameVnode(oldStartVnode, newEndVnode)) {
          // Vnode moved right
          patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
          canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
          oldStartVnode = oldCh[++oldStartIdx];
          newEndVnode = newCh[--newEndIdx];
        } else if (sameVnode(oldEndVnode, newStartVnode)) {
          // Vnode moved left
          patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
          canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
          oldEndVnode = oldCh[--oldEndIdx];
          newStartVnode = newCh[++newStartIdx];
        } else {
          if (isUndef(oldKeyToIdx)) {
            oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
          }
          idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
          if (isUndef(idxInOld)) {
            // New element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
          } else {
            vnodeToMove = oldCh[idxInOld];
            if (sameVnode(vnodeToMove, newStartVnode)) {
              patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue);
              oldCh[idxInOld] = undefined;
              canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
            } else {
              // same key but different element. treat as new element
              createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
            }
          }
          newStartVnode = newCh[++newStartIdx];
        }
      }
      if (oldStartIdx > oldEndIdx) {
        refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
        addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
      } else if (newStartIdx > newEndIdx) {
        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
      }
    }

    function checkDuplicateKeys(children) {
      var seenKeys = {};
      for (var i = 0; i < children.length; i++) {
        var vnode = children[i];
        var key = vnode.key;
        if (isDef(key)) {
          if (seenKeys[key]) {
            warn("Duplicate keys detected: '" + key + "'. This may cause an update error.", vnode.context);
          } else {
            seenKeys[key] = true;
          }
        }
      }
    }

    function findIdxInOld(node, oldCh, start, end) {
      for (var i = start; i < end; i++) {
        var c = oldCh[i];
        if (isDef(c) && sameVnode(node, c)) {
          return i;
        }
      }
    }

    function patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) {
      if (oldVnode === vnode) {
        return;
      }

      var elm = vnode.elm = oldVnode.elm;

      if (isTrue(oldVnode.isAsyncPlaceholder)) {
        if (isDef(vnode.asyncFactory.resolved)) {
          hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
        } else {
          vnode.isAsyncPlaceholder = true;
        }
        return;
      }

      // reuse element for static trees.
      // note we only do this if the vnode is cloned -
      // if the new node is not cloned it means the render functions have been
      // reset by the hot-reload-api and we need to do a proper re-render.
      if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
        vnode.componentInstance = oldVnode.componentInstance;
        return;
      }

      var i;
      var data = vnode.data;
      if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
        i(oldVnode, vnode);
      }

      var oldCh = oldVnode.children;
      var ch = vnode.children;
      if (isDef(data) && isPatchable(vnode)) {
        for (i = 0; i < cbs.update.length; ++i) {
          cbs.update[i](oldVnode, vnode);
        }
        if (isDef(i = data.hook) && isDef(i = i.update)) {
          i(oldVnode, vnode);
        }
      }
      if (isUndef(vnode.text)) {
        if (isDef(oldCh) && isDef(ch)) {
          if (oldCh !== ch) {
            updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
          }
        } else if (isDef(ch)) {
          if (isDef(oldVnode.text)) {
            nodeOps.setTextContent(elm, '');
          }
          addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
        } else if (isDef(oldCh)) {
          removeVnodes(elm, oldCh, 0, oldCh.length - 1);
        } else if (isDef(oldVnode.text)) {
          nodeOps.setTextContent(elm, '');
        }
      } else if (oldVnode.text !== vnode.text) {
        nodeOps.setTextContent(elm, vnode.text);
      }
      if (isDef(data)) {
        if (isDef(i = data.hook) && isDef(i = i.postpatch)) {
          i(oldVnode, vnode);
        }
      }
    }

    function invokeInsertHook(vnode, queue, initial) {
      // delay insert hooks for component root nodes, invoke them after the
      // element is really inserted
      if (isTrue(initial) && isDef(vnode.parent)) {
        vnode.parent.data.pendingInsert = queue;
      } else {
        for (var i = 0; i < queue.length; ++i) {
          queue[i].data.hook.insert(queue[i]);
        }
      }
    }

    var hydrationBailed = false;
    // list of modules that can skip create hook during hydration because they
    // are already rendered on the client or has no need for initialization
    // Note: style is excluded because it relies on initial clone for future
    // deep updates (#7063).
    var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');

    // Note: this is a browser-only function so we can assume elms are DOM nodes.
    function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {
      var i;
      var tag = vnode.tag;
      var data = vnode.data;
      var children = vnode.children;
      inVPre = inVPre || data && data.pre;
      vnode.elm = elm;

      if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
        vnode.isAsyncPlaceholder = true;
        return true;
      }
      // assert node match
      {
        if (!assertNodeMatch(elm, vnode, inVPre)) {
          return false;
        }
      }
      if (isDef(data)) {
        if (isDef(i = data.hook) && isDef(i = i.init)) {
          i(vnode, true /* hydrating */);
        }
        if (isDef(i = vnode.componentInstance)) {
          // child component. it should have hydrated its own tree.
          initComponent(vnode, insertedVnodeQueue);
          return true;
        }
      }
      if (isDef(tag)) {
        if (isDef(children)) {
          // empty element, allow client to pick up and populate children
          if (!elm.hasChildNodes()) {
            createChildren(vnode, children, insertedVnodeQueue);
          } else {
            // v-html and domProps: innerHTML
            if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
              if (i !== elm.innerHTML) {
                /* istanbul ignore if */
                if ("development" !== 'production' && typeof console !== 'undefined' && !hydrationBailed) {
                  hydrationBailed = true;
                  console.warn('Parent: ', elm);
                  console.warn('server innerHTML: ', i);
                  console.warn('client innerHTML: ', elm.innerHTML);
                }
                return false;
              }
            } else {
              // iterate and compare children lists
              var childrenMatch = true;
              var childNode = elm.firstChild;
              for (var i$1 = 0; i$1 < children.length; i$1++) {
                if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                  childrenMatch = false;
                  break;
                }
                childNode = childNode.nextSibling;
              }
              // if childNode is not null, it means the actual childNodes list is
              // longer than the virtual children list.
              if (!childrenMatch || childNode) {
                /* istanbul ignore if */
                if ("development" !== 'production' && typeof console !== 'undefined' && !hydrationBailed) {
                  hydrationBailed = true;
                  console.warn('Parent: ', elm);
                  console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
                }
                return false;
              }
            }
          }
        }
        if (isDef(data)) {
          var fullInvoke = false;
          for (var key in data) {
            if (!isRenderedModule(key)) {
              fullInvoke = true;
              invokeCreateHooks(vnode, insertedVnodeQueue);
              break;
            }
          }
          if (!fullInvoke && data['class']) {
            // ensure collecting deps for deep class bindings for future updates
            traverse(data['class']);
          }
        }
      } else if (elm.data !== vnode.text) {
        elm.data = vnode.text;
      }
      return true;
    }

    function assertNodeMatch(node, vnode, inVPre) {
      if (isDef(vnode.tag)) {
        return vnode.tag.indexOf('vue-component') === 0 || !isUnknownElement$$1(vnode, inVPre) && vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());
      } else {
        return node.nodeType === (vnode.isComment ? 8 : 3);
      }
    }

    return function patch(oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
      if (isUndef(vnode)) {
        if (isDef(oldVnode)) {
          invokeDestroyHook(oldVnode);
        }
        return;
      }

      var isInitialPatch = false;
      var insertedVnodeQueue = [];

      if (isUndef(oldVnode)) {
        // empty mount (likely as component), create new root element
        isInitialPatch = true;
        createElm(vnode, insertedVnodeQueue, parentElm, refElm);
      } else {
        var isRealElement = isDef(oldVnode.nodeType);
        if (!isRealElement && sameVnode(oldVnode, vnode)) {
          // patch existing root node
          patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
        } else {
          if (isRealElement) {
            // mounting to a real element
            // check if this is server-rendered content and if we can perform
            // a successful hydration.
            if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
              oldVnode.removeAttribute(SSR_ATTR);
              hydrating = true;
            }
            if (isTrue(hydrating)) {
              if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
                invokeInsertHook(vnode, insertedVnodeQueue, true);
                return oldVnode;
              } else {
                warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');
              }
            }
            // either not server-rendered, or hydration failed.
            // create an empty node and replace it
            oldVnode = emptyNodeAt(oldVnode);
          }

          // replacing existing element
          var oldElm = oldVnode.elm;
          var parentElm$1 = nodeOps.parentNode(oldElm);

          // create new node
          createElm(vnode, insertedVnodeQueue,
          // extremely rare edge case: do not insert if old element is in a
          // leaving transition. Only happens when combining transition +
          // keep-alive + HOCs. (#4590)
          oldElm._leaveCb ? null : parentElm$1, nodeOps.nextSibling(oldElm));

          // update parent placeholder node element, recursively
          if (isDef(vnode.parent)) {
            var ancestor = vnode.parent;
            var patchable = isPatchable(vnode);
            while (ancestor) {
              for (var i = 0; i < cbs.destroy.length; ++i) {
                cbs.destroy[i](ancestor);
              }
              ancestor.elm = vnode.elm;
              if (patchable) {
                for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                  cbs.create[i$1](emptyNode, ancestor);
                }
                // #6513
                // invoke insert hooks that may have been merged by create hooks.
                // e.g. for directives that uses the "inserted" hook.
                var insert = ancestor.data.hook.insert;
                if (insert.merged) {
                  // start at index 1 to avoid re-invoking component mounted hook
                  for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                    insert.fns[i$2]();
                  }
                }
              } else {
                registerRef(ancestor);
              }
              ancestor = ancestor.parent;
            }
          }

          // destroy old node
          if (isDef(parentElm$1)) {
            removeVnodes(parentElm$1, [oldVnode], 0, 0);
          } else if (isDef(oldVnode.tag)) {
            invokeDestroyHook(oldVnode);
          }
        }
      }

      invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
      return vnode.elm;
    };
  }

  /*  */

  var directives = {
    create: updateDirectives,
    update: updateDirectives,
    destroy: function unbindDirectives(vnode) {
      updateDirectives(vnode, emptyNode);
    }
  };

  function updateDirectives(oldVnode, vnode) {
    if (oldVnode.data.directives || vnode.data.directives) {
      _update(oldVnode, vnode);
    }
  }

  function _update(oldVnode, vnode) {
    var isCreate = oldVnode === emptyNode;
    var isDestroy = vnode === emptyNode;
    var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
    var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

    var dirsWithInsert = [];
    var dirsWithPostpatch = [];

    var key, oldDir, dir;
    for (key in newDirs) {
      oldDir = oldDirs[key];
      dir = newDirs[key];
      if (!oldDir) {
        // new directive, bind
        callHook$1(dir, 'bind', vnode, oldVnode);
        if (dir.def && dir.def.inserted) {
          dirsWithInsert.push(dir);
        }
      } else {
        // existing directive, update
        dir.oldValue = oldDir.value;
        callHook$1(dir, 'update', vnode, oldVnode);
        if (dir.def && dir.def.componentUpdated) {
          dirsWithPostpatch.push(dir);
        }
      }
    }

    if (dirsWithInsert.length) {
      var callInsert = function callInsert() {
        for (var i = 0; i < dirsWithInsert.length; i++) {
          callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
        }
      };
      if (isCreate) {
        mergeVNodeHook(vnode, 'insert', callInsert);
      } else {
        callInsert();
      }
    }

    if (dirsWithPostpatch.length) {
      mergeVNodeHook(vnode, 'postpatch', function () {
        for (var i = 0; i < dirsWithPostpatch.length; i++) {
          callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
        }
      });
    }

    if (!isCreate) {
      for (key in oldDirs) {
        if (!newDirs[key]) {
          // no longer present, unbind
          callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
        }
      }
    }
  }

  var emptyModifiers = Object.create(null);

  function normalizeDirectives$1(dirs, vm) {
    var res = Object.create(null);
    if (!dirs) {
      // $flow-disable-line
      return res;
    }
    var i, dir;
    for (i = 0; i < dirs.length; i++) {
      dir = dirs[i];
      if (!dir.modifiers) {
        // $flow-disable-line
        dir.modifiers = emptyModifiers;
      }
      res[getRawDirName(dir)] = dir;
      dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
    }
    // $flow-disable-line
    return res;
  }

  function getRawDirName(dir) {
    return dir.rawName || dir.name + "." + Object.keys(dir.modifiers || {}).join('.');
  }

  function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {
    var fn = dir.def && dir.def[hook];
    if (fn) {
      try {
        fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
      } catch (e) {
        handleError(e, vnode.context, "directive " + dir.name + " " + hook + " hook");
      }
    }
  }

  var baseModules = [ref, directives];

  /*  */

  function updateAttrs(oldVnode, vnode) {
    var opts = vnode.componentOptions;
    if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
      return;
    }
    if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
      return;
    }
    var key, cur, old;
    var elm = vnode.elm;
    var oldAttrs = oldVnode.data.attrs || {};
    var attrs = vnode.data.attrs || {};
    // clone observed objects, as the user probably wants to mutate it
    if (isDef(attrs.__ob__)) {
      attrs = vnode.data.attrs = extend({}, attrs);
    }

    for (key in attrs) {
      cur = attrs[key];
      old = oldAttrs[key];
      if (old !== cur) {
        setAttr(elm, key, cur);
      }
    }
    // #4391: in IE9, setting type can reset value for input[type=radio]
    // #6666: IE/Edge forces progress value down to 1 before setting a max
    /* istanbul ignore if */
    if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {
      setAttr(elm, 'value', attrs.value);
    }
    for (key in oldAttrs) {
      if (isUndef(attrs[key])) {
        if (isXlink(key)) {
          elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
        } else if (!isEnumeratedAttr(key)) {
          elm.removeAttribute(key);
        }
      }
    }
  }

  function setAttr(el, key, value) {
    if (el.tagName.indexOf('-') > -1) {
      baseSetAttr(el, key, value);
    } else if (isBooleanAttr(key)) {
      // set attribute for blank value
      // e.g. <option disabled>Select one</option>
      if (isFalsyAttrValue(value)) {
        el.removeAttribute(key);
      } else {
        // technically allowfullscreen is a boolean attribute for <iframe>,
        // but Flash expects a value of "true" when used on <embed> tag
        value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;
        el.setAttribute(key, value);
      }
    } else if (isEnumeratedAttr(key)) {
      el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');
    } else if (isXlink(key)) {
      if (isFalsyAttrValue(value)) {
        el.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else {
        el.setAttributeNS(xlinkNS, key, value);
      }
    } else {
      baseSetAttr(el, key, value);
    }
  }

  function baseSetAttr(el, key, value) {
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      // #7138: IE10 & 11 fires input event when setting placeholder on
      // <textarea>... block the first input event and remove the blocker
      // immediately.
      /* istanbul ignore if */
      if (isIE && !isIE9 && el.tagName === 'TEXTAREA' && key === 'placeholder' && !el.__ieph) {
        var blocker = function blocker(e) {
          e.stopImmediatePropagation();
          el.removeEventListener('input', blocker);
        };
        el.addEventListener('input', blocker);
        // $flow-disable-line
        el.__ieph = true; /* IE placeholder patched */
      }
      el.setAttribute(key, value);
    }
  }

  var attrs = {
    create: updateAttrs,
    update: updateAttrs

    /*  */

  };function updateClass(oldVnode, vnode) {
    var el = vnode.elm;
    var data = vnode.data;
    var oldData = oldVnode.data;
    if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {
      return;
    }

    var cls = genClassForVnode(vnode);

    // handle transition classes
    var transitionClass = el._transitionClasses;
    if (isDef(transitionClass)) {
      cls = concat(cls, stringifyClass(transitionClass));
    }

    // set the class
    if (cls !== el._prevClass) {
      el.setAttribute('class', cls);
      el._prevClass = cls;
    }
  }

  var klass = {
    create: updateClass,
    update: updateClass

    /*  */

  };var validDivisionCharRE = /[\w).+\-_$\]]/;

  function parseFilters(exp) {
    var inSingle = false;
    var inDouble = false;
    var inTemplateString = false;
    var inRegex = false;
    var curly = 0;
    var square = 0;
    var paren = 0;
    var lastFilterIndex = 0;
    var c, prev, i, expression, filters;

    for (i = 0; i < exp.length; i++) {
      prev = c;
      c = exp.charCodeAt(i);
      if (inSingle) {
        if (c === 0x27 && prev !== 0x5C) {
          inSingle = false;
        }
      } else if (inDouble) {
        if (c === 0x22 && prev !== 0x5C) {
          inDouble = false;
        }
      } else if (inTemplateString) {
        if (c === 0x60 && prev !== 0x5C) {
          inTemplateString = false;
        }
      } else if (inRegex) {
        if (c === 0x2f && prev !== 0x5C) {
          inRegex = false;
        }
      } else if (c === 0x7C && // pipe
      exp.charCodeAt(i + 1) !== 0x7C && exp.charCodeAt(i - 1) !== 0x7C && !curly && !square && !paren) {
        if (expression === undefined) {
          // first filter, end of expression
          lastFilterIndex = i + 1;
          expression = exp.slice(0, i).trim();
        } else {
          pushFilter();
        }
      } else {
        switch (c) {
          case 0x22:
            inDouble = true;break; // "
          case 0x27:
            inSingle = true;break; // '
          case 0x60:
            inTemplateString = true;break; // `
          case 0x28:
            paren++;break; // (
          case 0x29:
            paren--;break; // )
          case 0x5B:
            square++;break; // [
          case 0x5D:
            square--;break; // ]
          case 0x7B:
            curly++;break; // {
          case 0x7D:
            curly--;break; // }
        }
        if (c === 0x2f) {
          // /
          var j = i - 1;
          var p = void 0;
          // find first non-whitespace prev char
          for (; j >= 0; j--) {
            p = exp.charAt(j);
            if (p !== ' ') {
              break;
            }
          }
          if (!p || !validDivisionCharRE.test(p)) {
            inRegex = true;
          }
        }
      }
    }

    if (expression === undefined) {
      expression = exp.slice(0, i).trim();
    } else if (lastFilterIndex !== 0) {
      pushFilter();
    }

    function pushFilter() {
      (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
      lastFilterIndex = i + 1;
    }

    if (filters) {
      for (i = 0; i < filters.length; i++) {
        expression = wrapFilter(expression, filters[i]);
      }
    }

    return expression;
  }

  function wrapFilter(exp, filter) {
    var i = filter.indexOf('(');
    if (i < 0) {
      // _f: resolveFilter
      return "_f(\"" + filter + "\")(" + exp + ")";
    } else {
      var name = filter.slice(0, i);
      var args = filter.slice(i + 1);
      return "_f(\"" + name + "\")(" + exp + (args !== ')' ? ',' + args : args);
    }
  }

  /*  */

  function baseWarn(msg) {
    console.error("[Vue compiler]: " + msg);
  }

  function pluckModuleFunction(modules, key) {
    return modules ? modules.map(function (m) {
      return m[key];
    }).filter(function (_) {
      return _;
    }) : [];
  }

  function addProp(el, name, value) {
    (el.props || (el.props = [])).push({ name: name, value: value });
    el.plain = false;
  }

  function addAttr(el, name, value) {
    (el.attrs || (el.attrs = [])).push({ name: name, value: value });
    el.plain = false;
  }

  // add a raw attr (use this in preTransforms)
  function addRawAttr(el, name, value) {
    el.attrsMap[name] = value;
    el.attrsList.push({ name: name, value: value });
  }

  function addDirective(el, name, rawName, value, arg, modifiers) {
    (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });
    el.plain = false;
  }

  function addHandler(el, name, value, modifiers, important, warn) {
    modifiers = modifiers || emptyObject;
    // warn prevent and passive modifier
    /* istanbul ignore if */
    if ("development" !== 'production' && warn && modifiers.prevent && modifiers.passive) {
      warn('passive and prevent can\'t be used together. ' + 'Passive handler can\'t prevent default event.');
    }

    // check capture modifier
    if (modifiers.capture) {
      delete modifiers.capture;
      name = '!' + name; // mark the event as captured
    }
    if (modifiers.once) {
      delete modifiers.once;
      name = '~' + name; // mark the event as once
    }
    /* istanbul ignore if */
    if (modifiers.passive) {
      delete modifiers.passive;
      name = '&' + name; // mark the event as passive
    }

    // normalize click.right and click.middle since they don't actually fire
    // this is technically browser-specific, but at least for now browsers are
    // the only target envs that have right/middle clicks.
    if (name === 'click') {
      if (modifiers.right) {
        name = 'contextmenu';
        delete modifiers.right;
      } else if (modifiers.middle) {
        name = 'mouseup';
      }
    }

    var events;
    if (modifiers.native) {
      delete modifiers.native;
      events = el.nativeEvents || (el.nativeEvents = {});
    } else {
      events = el.events || (el.events = {});
    }

    var newHandler = {
      value: value.trim()
    };
    if (modifiers !== emptyObject) {
      newHandler.modifiers = modifiers;
    }

    var handlers = events[name];
    /* istanbul ignore if */
    if (Array.isArray(handlers)) {
      important ? handlers.unshift(newHandler) : handlers.push(newHandler);
    } else if (handlers) {
      events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
    } else {
      events[name] = newHandler;
    }

    el.plain = false;
  }

  function getBindingAttr(el, name, getStatic) {
    var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);
    if (dynamicValue != null) {
      return parseFilters(dynamicValue);
    } else if (getStatic !== false) {
      var staticValue = getAndRemoveAttr(el, name);
      if (staticValue != null) {
        return JSON.stringify(staticValue);
      }
    }
  }

  // note: this only removes the attr from the Array (attrsList) so that it
  // doesn't get processed by processAttrs.
  // By default it does NOT remove it from the map (attrsMap) because the map is
  // needed during codegen.
  function getAndRemoveAttr(el, name, removeFromMap) {
    var val;
    if ((val = el.attrsMap[name]) != null) {
      var list = el.attrsList;
      for (var i = 0, l = list.length; i < l; i++) {
        if (list[i].name === name) {
          list.splice(i, 1);
          break;
        }
      }
    }
    if (removeFromMap) {
      delete el.attrsMap[name];
    }
    return val;
  }

  /*  */

  /**
   * Cross-platform code generation for component v-model
   */
  function genComponentModel(el, value, modifiers) {
    var ref = modifiers || {};
    var number = ref.number;
    var trim = ref.trim;

    var baseValueExpression = '$$v';
    var valueExpression = baseValueExpression;
    if (trim) {
      valueExpression = "(typeof " + baseValueExpression + " === 'string'" + "? " + baseValueExpression + ".trim()" + ": " + baseValueExpression + ")";
    }
    if (number) {
      valueExpression = "_n(" + valueExpression + ")";
    }
    var assignment = genAssignmentCode(value, valueExpression);

    el.model = {
      value: "(" + value + ")",
      expression: "\"" + value + "\"",
      callback: "function (" + baseValueExpression + ") {" + assignment + "}"
    };
  }

  /**
   * Cross-platform codegen helper for generating v-model value assignment code.
   */
  function genAssignmentCode(value, assignment) {
    var res = parseModel(value);
    if (res.key === null) {
      return value + "=" + assignment;
    } else {
      return "$set(" + res.exp + ", " + res.key + ", " + assignment + ")";
    }
  }

  /**
   * Parse a v-model expression into a base path and a final key segment.
   * Handles both dot-path and possible square brackets.
   *
   * Possible cases:
   *
   * - test
   * - test[key]
   * - test[test1[key]]
   * - test["a"][key]
   * - xxx.test[a[a].test1[key]]
   * - test.xxx.a["asa"][test1[key]]
   *
   */

  var len;
  var str;
  var chr;
  var index$1;
  var expressionPos;
  var expressionEndPos;

  function parseModel(val) {
    // Fix https://github.com/vuejs/vue/pull/7730
    // allow v-model="obj.val " (trailing whitespace)
    val = val.trim();
    len = val.length;

    if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
      index$1 = val.lastIndexOf('.');
      if (index$1 > -1) {
        return {
          exp: val.slice(0, index$1),
          key: '"' + val.slice(index$1 + 1) + '"'
        };
      } else {
        return {
          exp: val,
          key: null
        };
      }
    }

    str = val;
    index$1 = expressionPos = expressionEndPos = 0;

    while (!eof()) {
      chr = next();
      /* istanbul ignore if */
      if (isStringStart(chr)) {
        parseString(chr);
      } else if (chr === 0x5B) {
        parseBracket(chr);
      }
    }

    return {
      exp: val.slice(0, expressionPos),
      key: val.slice(expressionPos + 1, expressionEndPos)
    };
  }

  function next() {
    return str.charCodeAt(++index$1);
  }

  function eof() {
    return index$1 >= len;
  }

  function isStringStart(chr) {
    return chr === 0x22 || chr === 0x27;
  }

  function parseBracket(chr) {
    var inBracket = 1;
    expressionPos = index$1;
    while (!eof()) {
      chr = next();
      if (isStringStart(chr)) {
        parseString(chr);
        continue;
      }
      if (chr === 0x5B) {
        inBracket++;
      }
      if (chr === 0x5D) {
        inBracket--;
      }
      if (inBracket === 0) {
        expressionEndPos = index$1;
        break;
      }
    }
  }

  function parseString(chr) {
    var stringQuote = chr;
    while (!eof()) {
      chr = next();
      if (chr === stringQuote) {
        break;
      }
    }
  }

  /*  */

  var warn$1;

  // in some cases, the event used has to be determined at runtime
  // so we used some reserved tokens during compile.
  var RANGE_TOKEN = '__r';
  var CHECKBOX_RADIO_TOKEN = '__c';

  function model(el, dir, _warn) {
    warn$1 = _warn;
    var value = dir.value;
    var modifiers = dir.modifiers;
    var tag = el.tag;
    var type = el.attrsMap.type;

    {
      // inputs with type="file" are read only and setting the input's
      // value will throw an error.
      if (tag === 'input' && type === 'file') {
        warn$1("<" + el.tag + " v-model=\"" + value + "\" type=\"file\">:\n" + "File inputs are read only. Use a v-on:change listener instead.");
      }
    }

    if (el.component) {
      genComponentModel(el, value, modifiers);
      // component v-model doesn't need extra runtime
      return false;
    } else if (tag === 'select') {
      genSelect(el, value, modifiers);
    } else if (tag === 'input' && type === 'checkbox') {
      genCheckboxModel(el, value, modifiers);
    } else if (tag === 'input' && type === 'radio') {
      genRadioModel(el, value, modifiers);
    } else if (tag === 'input' || tag === 'textarea') {
      genDefaultModel(el, value, modifiers);
    } else if (!config.isReservedTag(tag)) {
      genComponentModel(el, value, modifiers);
      // component v-model doesn't need extra runtime
      return false;
    } else {
      warn$1("<" + el.tag + " v-model=\"" + value + "\">: " + "v-model is not supported on this element type. " + 'If you are working with contenteditable, it\'s recommended to ' + 'wrap a library dedicated for that purpose inside a custom component.');
    }

    // ensure runtime directive metadata
    return true;
  }

  function genCheckboxModel(el, value, modifiers) {
    var number = modifiers && modifiers.number;
    var valueBinding = getBindingAttr(el, 'value') || 'null';
    var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
    var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
    addProp(el, 'checked', "Array.isArray(" + value + ")" + "?_i(" + value + "," + valueBinding + ")>-1" + (trueValueBinding === 'true' ? ":(" + value + ")" : ":_q(" + value + "," + trueValueBinding + ")"));
    addHandler(el, 'change', "var $$a=" + value + "," + '$$el=$event.target,' + "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" + 'if(Array.isArray($$a)){' + "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," + '$$i=_i($$a,$$v);' + "if($$el.checked){$$i<0&&(" + genAssignmentCode(value, '$$a.concat([$$v])') + ")}" + "else{$$i>-1&&(" + genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))') + ")}" + "}else{" + genAssignmentCode(value, '$$c') + "}", null, true);
  }

  function genRadioModel(el, value, modifiers) {
    var number = modifiers && modifiers.number;
    var valueBinding = getBindingAttr(el, 'value') || 'null';
    valueBinding = number ? "_n(" + valueBinding + ")" : valueBinding;
    addProp(el, 'checked', "_q(" + value + "," + valueBinding + ")");
    addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);
  }

  function genSelect(el, value, modifiers) {
    var number = modifiers && modifiers.number;
    var selectedVal = "Array.prototype.filter" + ".call($event.target.options,function(o){return o.selected})" + ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" + "return " + (number ? '_n(val)' : 'val') + "})";

    var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';
    var code = "var $$selectedVal = " + selectedVal + ";";
    code = code + " " + genAssignmentCode(value, assignment);
    addHandler(el, 'change', code, null, true);
  }

  function genDefaultModel(el, value, modifiers) {
    var type = el.attrsMap.type;

    // warn if v-bind:value conflicts with v-model
    // except for inputs with v-bind:type
    {
      var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];
      var typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];
      if (value$1 && !typeBinding) {
        var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';
        warn$1(binding + "=\"" + value$1 + "\" conflicts with v-model on the same element " + 'because the latter already expands to a value binding internally');
      }
    }

    var ref = modifiers || {};
    var lazy = ref.lazy;
    var number = ref.number;
    var trim = ref.trim;
    var needCompositionGuard = !lazy && type !== 'range';
    var event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';

    var valueExpression = '$event.target.value';
    if (trim) {
      valueExpression = "$event.target.value.trim()";
    }
    if (number) {
      valueExpression = "_n(" + valueExpression + ")";
    }

    var code = genAssignmentCode(value, valueExpression);
    if (needCompositionGuard) {
      code = "if($event.target.composing)return;" + code;
    }

    addProp(el, 'value', "(" + value + ")");
    addHandler(el, event, code, null, true);
    if (trim || number) {
      addHandler(el, 'blur', '$forceUpdate()');
    }
  }

  /*  */

  // normalize v-model event tokens that can only be determined at runtime.
  // it's important to place the event as the first in the array because
  // the whole point is ensuring the v-model callback gets called before
  // user-attached handlers.
  function normalizeEvents(on) {
    /* istanbul ignore if */
    if (isDef(on[RANGE_TOKEN])) {
      // IE input[type=range] only supports `change` event
      var event = isIE ? 'change' : 'input';
      on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
      delete on[RANGE_TOKEN];
    }
    // This was originally intended to fix #4521 but no longer necessary
    // after 2.5. Keeping it for backwards compat with generated code from < 2.4
    /* istanbul ignore if */
    if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
      on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
      delete on[CHECKBOX_RADIO_TOKEN];
    }
  }

  var target$1;

  function createOnceHandler(handler, event, capture) {
    var _target = target$1; // save current target element in closure
    return function onceHandler() {
      var res = handler.apply(null, arguments);
      if (res !== null) {
        remove$2(event, onceHandler, capture, _target);
      }
    };
  }

  function add$1(event, handler, once$$1, capture, passive) {
    handler = withMacroTask(handler);
    if (once$$1) {
      handler = createOnceHandler(handler, event, capture);
    }
    target$1.addEventListener(event, handler, supportsPassive ? { capture: capture, passive: passive } : capture);
  }

  function remove$2(event, handler, capture, _target) {
    (_target || target$1).removeEventListener(event, handler._withTask || handler, capture);
  }

  function updateDOMListeners(oldVnode, vnode) {
    if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
      return;
    }
    var on = vnode.data.on || {};
    var oldOn = oldVnode.data.on || {};
    target$1 = vnode.elm;
    normalizeEvents(on);
    updateListeners(on, oldOn, add$1, remove$2, vnode.context);
    target$1 = undefined;
  }

  var events = {
    create: updateDOMListeners,
    update: updateDOMListeners

    /*  */

  };function updateDOMProps(oldVnode, vnode) {
    if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
      return;
    }
    var key, cur;
    var elm = vnode.elm;
    var oldProps = oldVnode.data.domProps || {};
    var props = vnode.data.domProps || {};
    // clone observed objects, as the user probably wants to mutate it
    if (isDef(props.__ob__)) {
      props = vnode.data.domProps = extend({}, props);
    }

    for (key in oldProps) {
      if (isUndef(props[key])) {
        elm[key] = '';
      }
    }
    for (key in props) {
      cur = props[key];
      // ignore children if the node has textContent or innerHTML,
      // as these will throw away existing DOM nodes and cause removal errors
      // on subsequent patches (#3360)
      if (key === 'textContent' || key === 'innerHTML') {
        if (vnode.children) {
          vnode.children.length = 0;
        }
        if (cur === oldProps[key]) {
          continue;
        }
        // #6601 work around Chrome version <= 55 bug where single textNode
        // replaced by innerHTML/textContent retains its parentNode property
        if (elm.childNodes.length === 1) {
          elm.removeChild(elm.childNodes[0]);
        }
      }

      if (key === 'value') {
        // store value as _value as well since
        // non-string values will be stringified
        elm._value = cur;
        // avoid resetting cursor position when value is the same
        var strCur = isUndef(cur) ? '' : String(cur);
        if (shouldUpdateValue(elm, strCur)) {
          elm.value = strCur;
        }
      } else {
        elm[key] = cur;
      }
    }
  }

  // check platforms/web/util/attrs.js acceptValue


  function shouldUpdateValue(elm, checkVal) {
    return !elm.composing && (elm.tagName === 'OPTION' || isNotInFocusAndDirty(elm, checkVal) || isDirtyWithModifiers(elm, checkVal));
  }

  function isNotInFocusAndDirty(elm, checkVal) {
    // return true when textbox (.number and .trim) loses focus and its value is
    // not equal to the updated value
    var notInFocus = true;
    // #6157
    // work around IE bug when accessing document.activeElement in an iframe
    try {
      notInFocus = document.activeElement !== elm;
    } catch (e) {}
    return notInFocus && elm.value !== checkVal;
  }

  function isDirtyWithModifiers(elm, newVal) {
    var value = elm.value;
    var modifiers = elm._vModifiers; // injected by v-model runtime
    if (isDef(modifiers)) {
      if (modifiers.lazy) {
        // inputs with lazy should only be updated when not in focus
        return false;
      }
      if (modifiers.number) {
        return toNumber(value) !== toNumber(newVal);
      }
      if (modifiers.trim) {
        return value.trim() !== newVal.trim();
      }
    }
    return value !== newVal;
  }

  var domProps = {
    create: updateDOMProps,
    update: updateDOMProps

    /*  */

  };var parseStyleText = cached(function (cssText) {
    var res = {};
    var listDelimiter = /;(?![^(]*\))/g;
    var propertyDelimiter = /:(.+)/;
    cssText.split(listDelimiter).forEach(function (item) {
      if (item) {
        var tmp = item.split(propertyDelimiter);
        tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
      }
    });
    return res;
  });

  // merge static and dynamic style data on the same vnode
  function normalizeStyleData(data) {
    var style = normalizeStyleBinding(data.style);
    // static style is pre-processed into an object during compilation
    // and is always a fresh object, so it's safe to merge into it
    return data.staticStyle ? extend(data.staticStyle, style) : style;
  }

  // normalize possible array / string values into Object
  function normalizeStyleBinding(bindingStyle) {
    if (Array.isArray(bindingStyle)) {
      return toObject(bindingStyle);
    }
    if (typeof bindingStyle === 'string') {
      return parseStyleText(bindingStyle);
    }
    return bindingStyle;
  }

  /**
   * parent component style should be after child's
   * so that parent component's style could override it
   */
  function getStyle(vnode, checkChild) {
    var res = {};
    var styleData;

    if (checkChild) {
      var childNode = vnode;
      while (childNode.componentInstance) {
        childNode = childNode.componentInstance._vnode;
        if (childNode && childNode.data && (styleData = normalizeStyleData(childNode.data))) {
          extend(res, styleData);
        }
      }
    }

    if (styleData = normalizeStyleData(vnode.data)) {
      extend(res, styleData);
    }

    var parentNode = vnode;
    while (parentNode = parentNode.parent) {
      if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
        extend(res, styleData);
      }
    }
    return res;
  }

  /*  */

  var cssVarRE = /^--/;
  var importantRE = /\s*!important$/;
  var setProp = function setProp(el, name, val) {
    /* istanbul ignore if */
    if (cssVarRE.test(name)) {
      el.style.setProperty(name, val);
    } else if (importantRE.test(val)) {
      el.style.setProperty(name, val.replace(importantRE, ''), 'important');
    } else {
      var normalizedName = normalize(name);
      if (Array.isArray(val)) {
        // Support values array created by autoprefixer, e.g.
        // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
        // Set them one by one, and the browser will only set those it can recognize
        for (var i = 0, len = val.length; i < len; i++) {
          el.style[normalizedName] = val[i];
        }
      } else {
        el.style[normalizedName] = val;
      }
    }
  };

  var vendorNames = ['Webkit', 'Moz', 'ms'];

  var emptyStyle;
  var normalize = cached(function (prop) {
    emptyStyle = emptyStyle || document.createElement('div').style;
    prop = camelize(prop);
    if (prop !== 'filter' && prop in emptyStyle) {
      return prop;
    }
    var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
    for (var i = 0; i < vendorNames.length; i++) {
      var name = vendorNames[i] + capName;
      if (name in emptyStyle) {
        return name;
      }
    }
  });

  function updateStyle(oldVnode, vnode) {
    var data = vnode.data;
    var oldData = oldVnode.data;

    if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {
      return;
    }

    var cur, name;
    var el = vnode.elm;
    var oldStaticStyle = oldData.staticStyle;
    var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};

    // if static style exists, stylebinding already merged into it when doing normalizeStyleData
    var oldStyle = oldStaticStyle || oldStyleBinding;

    var style = normalizeStyleBinding(vnode.data.style) || {};

    // store normalized style under a different key for next diff
    // make sure to clone it if it's reactive, since the user likely wants
    // to mutate it.
    vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;

    var newStyle = getStyle(vnode, true);

    for (name in oldStyle) {
      if (isUndef(newStyle[name])) {
        setProp(el, name, '');
      }
    }
    for (name in newStyle) {
      cur = newStyle[name];
      if (cur !== oldStyle[name]) {
        // ie9 setting to null has no effect, must use empty string
        setProp(el, name, cur == null ? '' : cur);
      }
    }
  }

  var style = {
    create: updateStyle,
    update: updateStyle

    /*  */

    /**
     * Add class with compatibility for SVG since classList is not supported on
     * SVG elements in IE
     */
  };function addClass(el, cls) {
    /* istanbul ignore if */
    if (!cls || !(cls = cls.trim())) {
      return;
    }

    /* istanbul ignore else */
    if (el.classList) {
      if (cls.indexOf(' ') > -1) {
        cls.split(/\s+/).forEach(function (c) {
          return el.classList.add(c);
        });
      } else {
        el.classList.add(cls);
      }
    } else {
      var cur = " " + (el.getAttribute('class') || '') + " ";
      if (cur.indexOf(' ' + cls + ' ') < 0) {
        el.setAttribute('class', (cur + cls).trim());
      }
    }
  }

  /**
   * Remove class with compatibility for SVG since classList is not supported on
   * SVG elements in IE
   */
  function removeClass(el, cls) {
    /* istanbul ignore if */
    if (!cls || !(cls = cls.trim())) {
      return;
    }

    /* istanbul ignore else */
    if (el.classList) {
      if (cls.indexOf(' ') > -1) {
        cls.split(/\s+/).forEach(function (c) {
          return el.classList.remove(c);
        });
      } else {
        el.classList.remove(cls);
      }
      if (!el.classList.length) {
        el.removeAttribute('class');
      }
    } else {
      var cur = " " + (el.getAttribute('class') || '') + " ";
      var tar = ' ' + cls + ' ';
      while (cur.indexOf(tar) >= 0) {
        cur = cur.replace(tar, ' ');
      }
      cur = cur.trim();
      if (cur) {
        el.setAttribute('class', cur);
      } else {
        el.removeAttribute('class');
      }
    }
  }

  /*  */

  function resolveTransition(def) {
    if (!def) {
      return;
    }
    /* istanbul ignore else */
    if ((typeof def === 'undefined' ? 'undefined' : _typeof(def)) === 'object') {
      var res = {};
      if (def.css !== false) {
        extend(res, autoCssTransition(def.name || 'v'));
      }
      extend(res, def);
      return res;
    } else if (typeof def === 'string') {
      return autoCssTransition(def);
    }
  }

  var autoCssTransition = cached(function (name) {
    return {
      enterClass: name + "-enter",
      enterToClass: name + "-enter-to",
      enterActiveClass: name + "-enter-active",
      leaveClass: name + "-leave",
      leaveToClass: name + "-leave-to",
      leaveActiveClass: name + "-leave-active"
    };
  });

  var hasTransition = inBrowser && !isIE9;
  var TRANSITION = 'transition';
  var ANIMATION = 'animation';

  // Transition property/event sniffing
  var transitionProp = 'transition';
  var transitionEndEvent = 'transitionend';
  var animationProp = 'animation';
  var animationEndEvent = 'animationend';
  if (hasTransition) {
    /* istanbul ignore if */
    if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
      transitionProp = 'WebkitTransition';
      transitionEndEvent = 'webkitTransitionEnd';
    }
    if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
      animationProp = 'WebkitAnimation';
      animationEndEvent = 'webkitAnimationEnd';
    }
  }

  // binding to window is necessary to make hot reload work in IE in strict mode
  var raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout : /* istanbul ignore next */function (fn) {
    return fn();
  };

  function nextFrame(fn) {
    raf(function () {
      raf(fn);
    });
  }

  function addTransitionClass(el, cls) {
    var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
    if (transitionClasses.indexOf(cls) < 0) {
      transitionClasses.push(cls);
      addClass(el, cls);
    }
  }

  function removeTransitionClass(el, cls) {
    if (el._transitionClasses) {
      remove(el._transitionClasses, cls);
    }
    removeClass(el, cls);
  }

  function whenTransitionEnds(el, expectedType, cb) {
    var ref = getTransitionInfo(el, expectedType);
    var type = ref.type;
    var timeout = ref.timeout;
    var propCount = ref.propCount;
    if (!type) {
      return cb();
    }
    var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
    var ended = 0;
    var end = function end() {
      el.removeEventListener(event, onEnd);
      cb();
    };
    var onEnd = function onEnd(e) {
      if (e.target === el) {
        if (++ended >= propCount) {
          end();
        }
      }
    };
    setTimeout(function () {
      if (ended < propCount) {
        end();
      }
    }, timeout + 1);
    el.addEventListener(event, onEnd);
  }

  var transformRE = /\b(transform|all)(,|$)/;

  function getTransitionInfo(el, expectedType) {
    var styles = window.getComputedStyle(el);
    var transitionDelays = styles[transitionProp + 'Delay'].split(', ');
    var transitionDurations = styles[transitionProp + 'Duration'].split(', ');
    var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    var animationDelays = styles[animationProp + 'Delay'].split(', ');
    var animationDurations = styles[animationProp + 'Duration'].split(', ');
    var animationTimeout = getTimeout(animationDelays, animationDurations);

    var type;
    var timeout = 0;
    var propCount = 0;
    /* istanbul ignore if */
    if (expectedType === TRANSITION) {
      if (transitionTimeout > 0) {
        type = TRANSITION;
        timeout = transitionTimeout;
        propCount = transitionDurations.length;
      }
    } else if (expectedType === ANIMATION) {
      if (animationTimeout > 0) {
        type = ANIMATION;
        timeout = animationTimeout;
        propCount = animationDurations.length;
      }
    } else {
      timeout = Math.max(transitionTimeout, animationTimeout);
      type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
      propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
    }
    var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);
    return {
      type: type,
      timeout: timeout,
      propCount: propCount,
      hasTransform: hasTransform
    };
  }

  function getTimeout(delays, durations) {
    /* istanbul ignore next */
    while (delays.length < durations.length) {
      delays = delays.concat(delays);
    }

    return Math.max.apply(null, durations.map(function (d, i) {
      return toMs(d) + toMs(delays[i]);
    }));
  }

  function toMs(s) {
    return Number(s.slice(0, -1)) * 1000;
  }

  /*  */

  function enter(vnode, toggleDisplay) {
    var el = vnode.elm;

    // call leave callback now
    if (isDef(el._leaveCb)) {
      el._leaveCb.cancelled = true;
      el._leaveCb();
    }

    var data = resolveTransition(vnode.data.transition);
    if (isUndef(data)) {
      return;
    }

    /* istanbul ignore if */
    if (isDef(el._enterCb) || el.nodeType !== 1) {
      return;
    }

    var css = data.css;
    var type = data.type;
    var enterClass = data.enterClass;
    var enterToClass = data.enterToClass;
    var enterActiveClass = data.enterActiveClass;
    var appearClass = data.appearClass;
    var appearToClass = data.appearToClass;
    var appearActiveClass = data.appearActiveClass;
    var beforeEnter = data.beforeEnter;
    var enter = data.enter;
    var afterEnter = data.afterEnter;
    var enterCancelled = data.enterCancelled;
    var beforeAppear = data.beforeAppear;
    var appear = data.appear;
    var afterAppear = data.afterAppear;
    var appearCancelled = data.appearCancelled;
    var duration = data.duration;

    // activeInstance will always be the <transition> component managing this
    // transition. One edge case to check is when the <transition> is placed
    // as the root node of a child component. In that case we need to check
    // <transition>'s parent for appear check.
    var context = activeInstance;
    var transitionNode = activeInstance.$vnode;
    while (transitionNode && transitionNode.parent) {
      transitionNode = transitionNode.parent;
      context = transitionNode.context;
    }

    var isAppear = !context._isMounted || !vnode.isRootInsert;

    if (isAppear && !appear && appear !== '') {
      return;
    }

    var startClass = isAppear && appearClass ? appearClass : enterClass;
    var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
    var toClass = isAppear && appearToClass ? appearToClass : enterToClass;

    var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
    var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;
    var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
    var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;

    var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);

    if ("development" !== 'production' && explicitEnterDuration != null) {
      checkDuration(explicitEnterDuration, 'enter', vnode);
    }

    var expectsCSS = css !== false && !isIE9;
    var userWantsControl = getHookArgumentsLength(enterHook);

    var cb = el._enterCb = once(function () {
      if (expectsCSS) {
        removeTransitionClass(el, toClass);
        removeTransitionClass(el, activeClass);
      }
      if (cb.cancelled) {
        if (expectsCSS) {
          removeTransitionClass(el, startClass);
        }
        enterCancelledHook && enterCancelledHook(el);
      } else {
        afterEnterHook && afterEnterHook(el);
      }
      el._enterCb = null;
    });

    if (!vnode.data.show) {
      // remove pending leave element on enter by injecting an insert hook
      mergeVNodeHook(vnode, 'insert', function () {
        var parent = el.parentNode;
        var pendingNode = parent && parent._pending && parent._pending[vnode.key];
        if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
          pendingNode.elm._leaveCb();
        }
        enterHook && enterHook(el, cb);
      });
    }

    // start enter transition
    beforeEnterHook && beforeEnterHook(el);
    if (expectsCSS) {
      addTransitionClass(el, startClass);
      addTransitionClass(el, activeClass);
      nextFrame(function () {
        removeTransitionClass(el, startClass);
        if (!cb.cancelled) {
          addTransitionClass(el, toClass);
          if (!userWantsControl) {
            if (isValidDuration(explicitEnterDuration)) {
              setTimeout(cb, explicitEnterDuration);
            } else {
              whenTransitionEnds(el, type, cb);
            }
          }
        }
      });
    }

    if (vnode.data.show) {
      toggleDisplay && toggleDisplay();
      enterHook && enterHook(el, cb);
    }

    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }

  function leave(vnode, rm) {
    var el = vnode.elm;

    // call enter callback now
    if (isDef(el._enterCb)) {
      el._enterCb.cancelled = true;
      el._enterCb();
    }

    var data = resolveTransition(vnode.data.transition);
    if (isUndef(data) || el.nodeType !== 1) {
      return rm();
    }

    /* istanbul ignore if */
    if (isDef(el._leaveCb)) {
      return;
    }

    var css = data.css;
    var type = data.type;
    var leaveClass = data.leaveClass;
    var leaveToClass = data.leaveToClass;
    var leaveActiveClass = data.leaveActiveClass;
    var beforeLeave = data.beforeLeave;
    var leave = data.leave;
    var afterLeave = data.afterLeave;
    var leaveCancelled = data.leaveCancelled;
    var delayLeave = data.delayLeave;
    var duration = data.duration;

    var expectsCSS = css !== false && !isIE9;
    var userWantsControl = getHookArgumentsLength(leave);

    var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);

    if ("development" !== 'production' && isDef(explicitLeaveDuration)) {
      checkDuration(explicitLeaveDuration, 'leave', vnode);
    }

    var cb = el._leaveCb = once(function () {
      if (el.parentNode && el.parentNode._pending) {
        el.parentNode._pending[vnode.key] = null;
      }
      if (expectsCSS) {
        removeTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveActiveClass);
      }
      if (cb.cancelled) {
        if (expectsCSS) {
          removeTransitionClass(el, leaveClass);
        }
        leaveCancelled && leaveCancelled(el);
      } else {
        rm();
        afterLeave && afterLeave(el);
      }
      el._leaveCb = null;
    });

    if (delayLeave) {
      delayLeave(performLeave);
    } else {
      performLeave();
    }

    function performLeave() {
      // the delayed leave may have already been cancelled
      if (cb.cancelled) {
        return;
      }
      // record leaving element
      if (!vnode.data.show) {
        (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
      }
      beforeLeave && beforeLeave(el);
      if (expectsCSS) {
        addTransitionClass(el, leaveClass);
        addTransitionClass(el, leaveActiveClass);
        nextFrame(function () {
          removeTransitionClass(el, leaveClass);
          if (!cb.cancelled) {
            addTransitionClass(el, leaveToClass);
            if (!userWantsControl) {
              if (isValidDuration(explicitLeaveDuration)) {
                setTimeout(cb, explicitLeaveDuration);
              } else {
                whenTransitionEnds(el, type, cb);
              }
            }
          }
        });
      }
      leave && leave(el, cb);
      if (!expectsCSS && !userWantsControl) {
        cb();
      }
    }
  }

  // only used in dev mode
  function checkDuration(val, name, vnode) {
    if (typeof val !== 'number') {
      warn("<transition> explicit " + name + " duration is not a valid number - " + "got " + JSON.stringify(val) + ".", vnode.context);
    } else if (isNaN(val)) {
      warn("<transition> explicit " + name + " duration is NaN - " + 'the duration expression might be incorrect.', vnode.context);
    }
  }

  function isValidDuration(val) {
    return typeof val === 'number' && !isNaN(val);
  }

  /**
   * Normalize a transition hook's argument length. The hook may be:
   * - a merged hook (invoker) with the original in .fns
   * - a wrapped component method (check ._length)
   * - a plain function (.length)
   */
  function getHookArgumentsLength(fn) {
    if (isUndef(fn)) {
      return false;
    }
    var invokerFns = fn.fns;
    if (isDef(invokerFns)) {
      // invoker
      return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
    } else {
      return (fn._length || fn.length) > 1;
    }
  }

  function _enter(_, vnode) {
    if (vnode.data.show !== true) {
      enter(vnode);
    }
  }

  var transition = inBrowser ? {
    create: _enter,
    activate: _enter,
    remove: function remove$$1(vnode, rm) {
      /* istanbul ignore else */
      if (vnode.data.show !== true) {
        leave(vnode, rm);
      } else {
        rm();
      }
    }
  } : {};

  var platformModules = [attrs, klass, events, domProps, style, transition];

  /*  */

  // the directive module should be applied last, after all
  // built-in modules have been applied.
  var modules = platformModules.concat(baseModules);

  var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });

  /**
   * Not type checking this file because flow doesn't like attaching
   * properties to Elements.
   */

  /* istanbul ignore if */
  if (isIE9) {
    // http://www.matts411.com/post/internet-explorer-9-oninput/
    document.addEventListener('selectionchange', function () {
      var el = document.activeElement;
      if (el && el.vmodel) {
        trigger(el, 'input');
      }
    });
  }

  var directive = {
    inserted: function inserted(el, binding, vnode, oldVnode) {
      if (vnode.tag === 'select') {
        // #6903
        if (oldVnode.elm && !oldVnode.elm._vOptions) {
          mergeVNodeHook(vnode, 'postpatch', function () {
            directive.componentUpdated(el, binding, vnode);
          });
        } else {
          setSelected(el, binding, vnode.context);
        }
        el._vOptions = [].map.call(el.options, getValue);
      } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
        el._vModifiers = binding.modifiers;
        if (!binding.modifiers.lazy) {
          el.addEventListener('compositionstart', onCompositionStart);
          el.addEventListener('compositionend', onCompositionEnd);
          // Safari < 10.2 & UIWebView doesn't fire compositionend when
          // switching focus before confirming composition choice
          // this also fixes the issue where some browsers e.g. iOS Chrome
          // fires "change" instead of "input" on autocomplete.
          el.addEventListener('change', onCompositionEnd);
          /* istanbul ignore if */
          if (isIE9) {
            el.vmodel = true;
          }
        }
      }
    },

    componentUpdated: function componentUpdated(el, binding, vnode) {
      if (vnode.tag === 'select') {
        setSelected(el, binding, vnode.context);
        // in case the options rendered by v-for have changed,
        // it's possible that the value is out-of-sync with the rendered options.
        // detect such cases and filter out values that no longer has a matching
        // option in the DOM.
        var prevOptions = el._vOptions;
        var curOptions = el._vOptions = [].map.call(el.options, getValue);
        if (curOptions.some(function (o, i) {
          return !looseEqual(o, prevOptions[i]);
        })) {
          // trigger change event if
          // no matching option found for at least one value
          var needReset = el.multiple ? binding.value.some(function (v) {
            return hasNoMatchingOption(v, curOptions);
          }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);
          if (needReset) {
            trigger(el, 'change');
          }
        }
      }
    }
  };

  function setSelected(el, binding, vm) {
    actuallySetSelected(el, binding, vm);
    /* istanbul ignore if */
    if (isIE || isEdge) {
      setTimeout(function () {
        actuallySetSelected(el, binding, vm);
      }, 0);
    }
  }

  function actuallySetSelected(el, binding, vm) {
    var value = binding.value;
    var isMultiple = el.multiple;
    if (isMultiple && !Array.isArray(value)) {
      "development" !== 'production' && warn("<select multiple v-model=\"" + binding.expression + "\"> " + "expects an Array value for its binding, but got " + Object.prototype.toString.call(value).slice(8, -1), vm);
      return;
    }
    var selected, option;
    for (var i = 0, l = el.options.length; i < l; i++) {
      option = el.options[i];
      if (isMultiple) {
        selected = looseIndexOf(value, getValue(option)) > -1;
        if (option.selected !== selected) {
          option.selected = selected;
        }
      } else {
        if (looseEqual(getValue(option), value)) {
          if (el.selectedIndex !== i) {
            el.selectedIndex = i;
          }
          return;
        }
      }
    }
    if (!isMultiple) {
      el.selectedIndex = -1;
    }
  }

  function hasNoMatchingOption(value, options) {
    return options.every(function (o) {
      return !looseEqual(o, value);
    });
  }

  function getValue(option) {
    return '_value' in option ? option._value : option.value;
  }

  function onCompositionStart(e) {
    e.target.composing = true;
  }

  function onCompositionEnd(e) {
    // prevent triggering an input event for no reason
    if (!e.target.composing) {
      return;
    }
    e.target.composing = false;
    trigger(e.target, 'input');
  }

  function trigger(el, type) {
    var e = document.createEvent('HTMLEvents');
    e.initEvent(type, true, true);
    el.dispatchEvent(e);
  }

  /*  */

  // recursively search for possible transition defined inside the component root
  function locateNode(vnode) {
    return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;
  }

  var show = {
    bind: function bind(el, ref, vnode) {
      var value = ref.value;

      vnode = locateNode(vnode);
      var transition$$1 = vnode.data && vnode.data.transition;
      var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;
      if (value && transition$$1) {
        vnode.data.show = true;
        enter(vnode, function () {
          el.style.display = originalDisplay;
        });
      } else {
        el.style.display = value ? originalDisplay : 'none';
      }
    },

    update: function update(el, ref, vnode) {
      var value = ref.value;
      var oldValue = ref.oldValue;

      /* istanbul ignore if */
      if (!value === !oldValue) {
        return;
      }
      vnode = locateNode(vnode);
      var transition$$1 = vnode.data && vnode.data.transition;
      if (transition$$1) {
        vnode.data.show = true;
        if (value) {
          enter(vnode, function () {
            el.style.display = el.__vOriginalDisplay;
          });
        } else {
          leave(vnode, function () {
            el.style.display = 'none';
          });
        }
      } else {
        el.style.display = value ? el.__vOriginalDisplay : 'none';
      }
    },

    unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {
      if (!isDestroy) {
        el.style.display = el.__vOriginalDisplay;
      }
    }
  };

  var platformDirectives = {
    model: directive,
    show: show

    /*  */

    // Provides transition support for a single element/component.
    // supports transition mode (out-in / in-out)

  };var transitionProps = {
    name: String,
    appear: Boolean,
    css: Boolean,
    mode: String,
    type: String,
    enterClass: String,
    leaveClass: String,
    enterToClass: String,
    leaveToClass: String,
    enterActiveClass: String,
    leaveActiveClass: String,
    appearClass: String,
    appearActiveClass: String,
    appearToClass: String,
    duration: [Number, String, Object]
  };

  // in case the child is also an abstract component, e.g. <keep-alive>
  // we want to recursively retrieve the real component to be rendered
  function getRealChild(vnode) {
    var compOptions = vnode && vnode.componentOptions;
    if (compOptions && compOptions.Ctor.options.abstract) {
      return getRealChild(getFirstComponentChild(compOptions.children));
    } else {
      return vnode;
    }
  }

  function extractTransitionData(comp) {
    var data = {};
    var options = comp.$options;
    // props
    for (var key in options.propsData) {
      data[key] = comp[key];
    }
    // events.
    // extract listeners and pass them directly to the transition methods
    var listeners = options._parentListeners;
    for (var key$1 in listeners) {
      data[camelize(key$1)] = listeners[key$1];
    }
    return data;
  }

  function placeholder(h, rawChild) {
    if (/\d-keep-alive$/.test(rawChild.tag)) {
      return h('keep-alive', {
        props: rawChild.componentOptions.propsData
      });
    }
  }

  function hasParentTransition(vnode) {
    while (vnode = vnode.parent) {
      if (vnode.data.transition) {
        return true;
      }
    }
  }

  function isSameChild(child, oldChild) {
    return oldChild.key === child.key && oldChild.tag === child.tag;
  }

  var Transition = {
    name: 'transition',
    props: transitionProps,
    abstract: true,

    render: function render(h) {
      var this$1 = this;

      var children = this.$slots.default;
      if (!children) {
        return;
      }

      // filter out text nodes (possible whitespaces)
      children = children.filter(function (c) {
        return c.tag || isAsyncPlaceholder(c);
      });
      /* istanbul ignore if */
      if (!children.length) {
        return;
      }

      // warn multiple elements
      if ("development" !== 'production' && children.length > 1) {
        warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);
      }

      var mode = this.mode;

      // warn invalid mode
      if ("development" !== 'production' && mode && mode !== 'in-out' && mode !== 'out-in') {
        warn('invalid <transition> mode: ' + mode, this.$parent);
      }

      var rawChild = children[0];

      // if this is a component root node and the component's
      // parent container node also has transition, skip.
      if (hasParentTransition(this.$vnode)) {
        return rawChild;
      }

      // apply transition data to child
      // use getRealChild() to ignore abstract components e.g. keep-alive
      var child = getRealChild(rawChild);
      /* istanbul ignore if */
      if (!child) {
        return rawChild;
      }

      if (this._leaving) {
        return placeholder(h, rawChild);
      }

      // ensure a key that is unique to the vnode type and to this transition
      // component instance. This key will be used to remove pending leaving nodes
      // during entering.
      var id = "__transition-" + this._uid + "-";
      child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;

      var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
      var oldRawChild = this._vnode;
      var oldChild = getRealChild(oldRawChild);

      // mark v-show
      // so that the transition module can hand over the control to the directive
      if (child.data.directives && child.data.directives.some(function (d) {
        return d.name === 'show';
      })) {
        child.data.show = true;
      }

      if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild) &&
      // #6687 component root is a comment node
      !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)) {
        // replace old child transition data with fresh one
        // important for dynamic transitions!
        var oldData = oldChild.data.transition = extend({}, data);
        // handle transition mode
        if (mode === 'out-in') {
          // return placeholder node and queue update when leave finishes
          this._leaving = true;
          mergeVNodeHook(oldData, 'afterLeave', function () {
            this$1._leaving = false;
            this$1.$forceUpdate();
          });
          return placeholder(h, rawChild);
        } else if (mode === 'in-out') {
          if (isAsyncPlaceholder(child)) {
            return oldRawChild;
          }
          var delayedLeave;
          var performLeave = function performLeave() {
            delayedLeave();
          };
          mergeVNodeHook(data, 'afterEnter', performLeave);
          mergeVNodeHook(data, 'enterCancelled', performLeave);
          mergeVNodeHook(oldData, 'delayLeave', function (leave) {
            delayedLeave = leave;
          });
        }
      }

      return rawChild;
    }

    /*  */

    // Provides transition support for list items.
    // supports move transitions using the FLIP technique.

    // Because the vdom's children update algorithm is "unstable" - i.e.
    // it doesn't guarantee the relative positioning of removed elements,
    // we force transition-group to update its children into two passes:
    // in the first pass, we remove all nodes that need to be removed,
    // triggering their leaving transition; in the second pass, we insert/move
    // into the final desired state. This way in the second pass removed
    // nodes will remain where they should be.

  };var props = extend({
    tag: String,
    moveClass: String
  }, transitionProps);

  delete props.mode;

  var TransitionGroup = {
    props: props,

    render: function render(h) {
      var tag = this.tag || this.$vnode.data.tag || 'span';
      var map = Object.create(null);
      var prevChildren = this.prevChildren = this.children;
      var rawChildren = this.$slots.default || [];
      var children = this.children = [];
      var transitionData = extractTransitionData(this);

      for (var i = 0; i < rawChildren.length; i++) {
        var c = rawChildren[i];
        if (c.tag) {
          if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
            children.push(c);
            map[c.key] = c;(c.data || (c.data = {})).transition = transitionData;
          } else {
            var opts = c.componentOptions;
            var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;
            warn("<transition-group> children must be keyed: <" + name + ">");
          }
        }
      }

      if (prevChildren) {
        var kept = [];
        var removed = [];
        for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
          var c$1 = prevChildren[i$1];
          c$1.data.transition = transitionData;
          c$1.data.pos = c$1.elm.getBoundingClientRect();
          if (map[c$1.key]) {
            kept.push(c$1);
          } else {
            removed.push(c$1);
          }
        }
        this.kept = h(tag, null, kept);
        this.removed = removed;
      }

      return h(tag, null, children);
    },

    beforeUpdate: function beforeUpdate() {
      // force removing pass
      this.__patch__(this._vnode, this.kept, false, // hydrating
      true // removeOnly (!important, avoids unnecessary moves)
      );
      this._vnode = this.kept;
    },

    updated: function updated() {
      var children = this.prevChildren;
      var moveClass = this.moveClass || (this.name || 'v') + '-move';
      if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
        return;
      }

      // we divide the work into three loops to avoid mixing DOM reads and writes
      // in each iteration - which helps prevent layout thrashing.
      children.forEach(callPendingCbs);
      children.forEach(recordPosition);
      children.forEach(applyTranslation);

      // force reflow to put everything in position
      // assign to this to avoid being removed in tree-shaking
      // $flow-disable-line
      this._reflow = document.body.offsetHeight;

      children.forEach(function (c) {
        if (c.data.moved) {
          var el = c.elm;
          var s = el.style;
          addTransitionClass(el, moveClass);
          s.transform = s.WebkitTransform = s.transitionDuration = '';
          el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {
            if (!e || /transform$/.test(e.propertyName)) {
              el.removeEventListener(transitionEndEvent, cb);
              el._moveCb = null;
              removeTransitionClass(el, moveClass);
            }
          });
        }
      });
    },

    methods: {
      hasMove: function hasMove(el, moveClass) {
        /* istanbul ignore if */
        if (!hasTransition) {
          return false;
        }
        /* istanbul ignore if */
        if (this._hasMove) {
          return this._hasMove;
        }
        // Detect whether an element with the move class applied has
        // CSS transitions. Since the element may be inside an entering
        // transition at this very moment, we make a clone of it and remove
        // all other transition classes applied to ensure only the move class
        // is applied.
        var clone = el.cloneNode();
        if (el._transitionClasses) {
          el._transitionClasses.forEach(function (cls) {
            removeClass(clone, cls);
          });
        }
        addClass(clone, moveClass);
        clone.style.display = 'none';
        this.$el.appendChild(clone);
        var info = getTransitionInfo(clone);
        this.$el.removeChild(clone);
        return this._hasMove = info.hasTransform;
      }
    }
  };

  function callPendingCbs(c) {
    /* istanbul ignore if */
    if (c.elm._moveCb) {
      c.elm._moveCb();
    }
    /* istanbul ignore if */
    if (c.elm._enterCb) {
      c.elm._enterCb();
    }
  }

  function recordPosition(c) {
    c.data.newPos = c.elm.getBoundingClientRect();
  }

  function applyTranslation(c) {
    var oldPos = c.data.pos;
    var newPos = c.data.newPos;
    var dx = oldPos.left - newPos.left;
    var dy = oldPos.top - newPos.top;
    if (dx || dy) {
      c.data.moved = true;
      var s = c.elm.style;
      s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
      s.transitionDuration = '0s';
    }
  }

  var platformComponents = {
    Transition: Transition,
    TransitionGroup: TransitionGroup

    /*  */

    // install platform specific utils
  };Vue.config.mustUseProp = mustUseProp;
  Vue.config.isReservedTag = isReservedTag;
  Vue.config.isReservedAttr = isReservedAttr;
  Vue.config.getTagNamespace = getTagNamespace;
  Vue.config.isUnknownElement = isUnknownElement;

  // install platform runtime directives & components
  extend(Vue.options.directives, platformDirectives);
  extend(Vue.options.components, platformComponents);

  // install platform patch function
  Vue.prototype.__patch__ = inBrowser ? patch : noop;

  // public mount method
  Vue.prototype.$mount = function (el, hydrating) {
    el = el && inBrowser ? query(el) : undefined;
    return mountComponent(this, el, hydrating);
  };

  // devtools global hook
  /* istanbul ignore next */
  if (inBrowser) {
    setTimeout(function () {
      if (config.devtools) {
        if (devtools) {
          devtools.emit('init', Vue);
        } else if ("development" !== 'production' && "development" !== 'test' && isChrome) {
          console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
        }
      }
      if ("development" !== 'production' && "development" !== 'test' && config.productionTip !== false && typeof console !== 'undefined') {
        console[console.info ? 'info' : 'log']("You are running Vue in development mode.\n" + "Make sure to turn on production mode when deploying for production.\n" + "See more tips at https://vuejs.org/guide/deployment.html");
      }
    }, 0);
  }

  /*  */

  var defaultTagRE = /\{\{((?:.|\n)+?)\}\}/g;
  var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;

  var buildRegex = cached(function (delimiters) {
    var open = delimiters[0].replace(regexEscapeRE, '\\$&');
    var close = delimiters[1].replace(regexEscapeRE, '\\$&');
    return new RegExp(open + '((?:.|\\n)+?)' + close, 'g');
  });

  function parseText(text, delimiters) {
    var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
    if (!tagRE.test(text)) {
      return;
    }
    var tokens = [];
    var rawTokens = [];
    var lastIndex = tagRE.lastIndex = 0;
    var match, index, tokenValue;
    while (match = tagRE.exec(text)) {
      index = match.index;
      // push text token
      if (index > lastIndex) {
        rawTokens.push(tokenValue = text.slice(lastIndex, index));
        tokens.push(JSON.stringify(tokenValue));
      }
      // tag token
      var exp = parseFilters(match[1].trim());
      tokens.push("_s(" + exp + ")");
      rawTokens.push({ '@binding': exp });
      lastIndex = index + match[0].length;
    }
    if (lastIndex < text.length) {
      rawTokens.push(tokenValue = text.slice(lastIndex));
      tokens.push(JSON.stringify(tokenValue));
    }
    return {
      expression: tokens.join('+'),
      tokens: rawTokens
    };
  }

  /*  */

  function transformNode(el, options) {
    var warn = options.warn || baseWarn;
    var staticClass = getAndRemoveAttr(el, 'class');
    if ("development" !== 'production' && staticClass) {
      var res = parseText(staticClass, options.delimiters);
      if (res) {
        warn("class=\"" + staticClass + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div class="{{ val }}">, use <div :class="val">.');
      }
    }
    if (staticClass) {
      el.staticClass = JSON.stringify(staticClass);
    }
    var classBinding = getBindingAttr(el, 'class', false /* getStatic */);
    if (classBinding) {
      el.classBinding = classBinding;
    }
  }

  function genData(el) {
    var data = '';
    if (el.staticClass) {
      data += "staticClass:" + el.staticClass + ",";
    }
    if (el.classBinding) {
      data += "class:" + el.classBinding + ",";
    }
    return data;
  }

  var klass$1 = {
    staticKeys: ['staticClass'],
    transformNode: transformNode,
    genData: genData

    /*  */

  };function transformNode$1(el, options) {
    var warn = options.warn || baseWarn;
    var staticStyle = getAndRemoveAttr(el, 'style');
    if (staticStyle) {
      /* istanbul ignore if */
      {
        var res = parseText(staticStyle, options.delimiters);
        if (res) {
          warn("style=\"" + staticStyle + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div style="{{ val }}">, use <div :style="val">.');
        }
      }
      el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
    }

    var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);
    if (styleBinding) {
      el.styleBinding = styleBinding;
    }
  }

  function genData$1(el) {
    var data = '';
    if (el.staticStyle) {
      data += "staticStyle:" + el.staticStyle + ",";
    }
    if (el.styleBinding) {
      data += "style:(" + el.styleBinding + "),";
    }
    return data;
  }

  var style$1 = {
    staticKeys: ['staticStyle'],
    transformNode: transformNode$1,
    genData: genData$1

    /*  */

  };var decoder;

  var he = {
    decode: function decode(html) {
      decoder = decoder || document.createElement('div');
      decoder.innerHTML = html;
      return decoder.textContent;
    }

    /*  */

  };var isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' + 'link,meta,param,source,track,wbr');

  // Elements that you can, intentionally, leave open
  // (and which close themselves)
  var canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source');

  // HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
  // Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
  var isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' + 'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' + 'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' + 'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' + 'title,tr,track');

  /**
   * Not type-checking this file because it's mostly vendor code.
   */

  /*!
   * HTML Parser By John Resig (ejohn.org)
   * Modified by Juriy "kangax" Zaytsev
   * Original code by Erik Arvidsson, Mozilla Public License
   * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
   */

  // Regular Expressions for parsing tags and attributes
  var attribute = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
  // could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName
  // but for Vue templates we can enforce a simple charset
  var ncname = '[a-zA-Z_][\\w\\-\\.]*';
  var qnameCapture = "((?:" + ncname + "\\:)?" + ncname + ")";
  var startTagOpen = new RegExp("^<" + qnameCapture);
  var startTagClose = /^\s*(\/?)>/;
  var endTag = new RegExp("^<\\/" + qnameCapture + "[^>]*>");
  var doctype = /^<!DOCTYPE [^>]+>/i;
  // #7298: escape - to avoid being pased as HTML comment when inlined in page
  var comment = /^<!\--/;
  var conditionalComment = /^<!\[/;

  var IS_REGEX_CAPTURING_BROKEN = false;
  'x'.replace(/x(.)?/g, function (m, g) {
    IS_REGEX_CAPTURING_BROKEN = g === '';
  });

  // Special Elements (can contain anything)
  var isPlainTextElement = makeMap('script,style,textarea', true);
  var reCache = {};

  var decodingMap = {
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&amp;': '&',
    '&#10;': '\n',
    '&#9;': '\t'
  };
  var encodedAttr = /&(?:lt|gt|quot|amp);/g;
  var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10|#9);/g;

  // #5992
  var isIgnoreNewlineTag = makeMap('pre,textarea', true);
  var shouldIgnoreFirstNewline = function shouldIgnoreFirstNewline(tag, html) {
    return tag && isIgnoreNewlineTag(tag) && html[0] === '\n';
  };

  function decodeAttr(value, shouldDecodeNewlines) {
    var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
    return value.replace(re, function (match) {
      return decodingMap[match];
    });
  }

  function parseHTML(html, options) {
    var stack = [];
    var expectHTML = options.expectHTML;
    var isUnaryTag$$1 = options.isUnaryTag || no;
    var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;
    var index = 0;
    var last, lastTag;
    while (html) {
      last = html;
      // Make sure we're not in a plaintext content element like script/style
      if (!lastTag || !isPlainTextElement(lastTag)) {
        var textEnd = html.indexOf('<');
        if (textEnd === 0) {
          // Comment:
          if (comment.test(html)) {
            var commentEnd = html.indexOf('-->');

            if (commentEnd >= 0) {
              if (options.shouldKeepComment) {
                options.comment(html.substring(4, commentEnd));
              }
              advance(commentEnd + 3);
              continue;
            }
          }

          // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
          if (conditionalComment.test(html)) {
            var conditionalEnd = html.indexOf(']>');

            if (conditionalEnd >= 0) {
              advance(conditionalEnd + 2);
              continue;
            }
          }

          // Doctype:
          var doctypeMatch = html.match(doctype);
          if (doctypeMatch) {
            advance(doctypeMatch[0].length);
            continue;
          }

          // End tag:
          var endTagMatch = html.match(endTag);
          if (endTagMatch) {
            var curIndex = index;
            advance(endTagMatch[0].length);
            parseEndTag(endTagMatch[1], curIndex, index);
            continue;
          }

          // Start tag:
          var startTagMatch = parseStartTag();
          if (startTagMatch) {
            handleStartTag(startTagMatch);
            if (shouldIgnoreFirstNewline(lastTag, html)) {
              advance(1);
            }
            continue;
          }
        }

        var text = void 0,
            rest = void 0,
            next = void 0;
        if (textEnd >= 0) {
          rest = html.slice(textEnd);
          while (!endTag.test(rest) && !startTagOpen.test(rest) && !comment.test(rest) && !conditionalComment.test(rest)) {
            // < in plain text, be forgiving and treat it as text
            next = rest.indexOf('<', 1);
            if (next < 0) {
              break;
            }
            textEnd += next;
            rest = html.slice(textEnd);
          }
          text = html.substring(0, textEnd);
          advance(textEnd);
        }

        if (textEnd < 0) {
          text = html;
          html = '';
        }

        if (options.chars && text) {
          options.chars(text);
        }
      } else {
        var endTagLength = 0;
        var stackedTag = lastTag.toLowerCase();
        var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
        var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {
          endTagLength = endTag.length;
          if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
            text = text.replace(/<!\--([\s\S]*?)-->/g, '$1') // #7298
            .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
          }
          if (shouldIgnoreFirstNewline(stackedTag, text)) {
            text = text.slice(1);
          }
          if (options.chars) {
            options.chars(text);
          }
          return '';
        });
        index += html.length - rest$1.length;
        html = rest$1;
        parseEndTag(stackedTag, index - endTagLength, index);
      }

      if (html === last) {
        options.chars && options.chars(html);
        if ("development" !== 'production' && !stack.length && options.warn) {
          options.warn("Mal-formatted tag at end of template: \"" + html + "\"");
        }
        break;
      }
    }

    // Clean up any remaining tags
    parseEndTag();

    function advance(n) {
      index += n;
      html = html.substring(n);
    }

    function parseStartTag() {
      var start = html.match(startTagOpen);
      if (start) {
        var match = {
          tagName: start[1],
          attrs: [],
          start: index
        };
        advance(start[0].length);
        var end, attr;
        while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {
          advance(attr[0].length);
          match.attrs.push(attr);
        }
        if (end) {
          match.unarySlash = end[1];
          advance(end[0].length);
          match.end = index;
          return match;
        }
      }
    }

    function handleStartTag(match) {
      var tagName = match.tagName;
      var unarySlash = match.unarySlash;

      if (expectHTML) {
        if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
          parseEndTag(lastTag);
        }
        if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {
          parseEndTag(tagName);
        }
      }

      var unary = isUnaryTag$$1(tagName) || !!unarySlash;

      var l = match.attrs.length;
      var attrs = new Array(l);
      for (var i = 0; i < l; i++) {
        var args = match.attrs[i];
        // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778
        if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('""') === -1) {
          if (args[3] === '') {
            delete args[3];
          }
          if (args[4] === '') {
            delete args[4];
          }
          if (args[5] === '') {
            delete args[5];
          }
        }
        var value = args[3] || args[4] || args[5] || '';
        var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href' ? options.shouldDecodeNewlinesForHref : options.shouldDecodeNewlines;
        attrs[i] = {
          name: args[1],
          value: decodeAttr(value, shouldDecodeNewlines)
        };
      }

      if (!unary) {
        stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });
        lastTag = tagName;
      }

      if (options.start) {
        options.start(tagName, attrs, unary, match.start, match.end);
      }
    }

    function parseEndTag(tagName, start, end) {
      var pos, lowerCasedTagName;
      if (start == null) {
        start = index;
      }
      if (end == null) {
        end = index;
      }

      if (tagName) {
        lowerCasedTagName = tagName.toLowerCase();
      }

      // Find the closest opened tag of the same type
      if (tagName) {
        for (pos = stack.length - 1; pos >= 0; pos--) {
          if (stack[pos].lowerCasedTag === lowerCasedTagName) {
            break;
          }
        }
      } else {
        // If no tag name is provided, clean shop
        pos = 0;
      }

      if (pos >= 0) {
        // Close all the open elements, up the stack
        for (var i = stack.length - 1; i >= pos; i--) {
          if ("development" !== 'production' && (i > pos || !tagName) && options.warn) {
            options.warn("tag <" + stack[i].tag + "> has no matching end tag.");
          }
          if (options.end) {
            options.end(stack[i].tag, start, end);
          }
        }

        // Remove the open elements from the stack
        stack.length = pos;
        lastTag = pos && stack[pos - 1].tag;
      } else if (lowerCasedTagName === 'br') {
        if (options.start) {
          options.start(tagName, [], true, start, end);
        }
      } else if (lowerCasedTagName === 'p') {
        if (options.start) {
          options.start(tagName, [], false, start, end);
        }
        if (options.end) {
          options.end(tagName, start, end);
        }
      }
    }
  }

  /*  */

  var onRE = /^@|^v-on:/;
  var dirRE = /^v-|^@|^:/;
  var forAliasRE = /([^]*?)\s+(?:in|of)\s+([^]*)/;
  var forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
  var stripParensRE = /^\(|\)$/g;

  var argRE = /:(.*)$/;
  var bindRE = /^:|^v-bind:/;
  var modifierRE = /\.[^.]+/g;

  var decodeHTMLCached = cached(he.decode);

  // configurable state
  var warn$2;
  var delimiters;
  var transforms;
  var preTransforms;
  var postTransforms;
  var platformIsPreTag;
  var platformMustUseProp;
  var platformGetTagNamespace;

  function createASTElement(tag, attrs, parent) {
    return {
      type: 1,
      tag: tag,
      attrsList: attrs,
      attrsMap: makeAttrsMap(attrs),
      parent: parent,
      children: []
    };
  }

  /**
   * Convert HTML string to AST.
   */
  function parse(template, options) {
    warn$2 = options.warn || baseWarn;

    platformIsPreTag = options.isPreTag || no;
    platformMustUseProp = options.mustUseProp || no;
    platformGetTagNamespace = options.getTagNamespace || no;

    transforms = pluckModuleFunction(options.modules, 'transformNode');
    preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
    postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');

    delimiters = options.delimiters;

    var stack = [];
    var preserveWhitespace = options.preserveWhitespace !== false;
    var root;
    var currentParent;
    var inVPre = false;
    var inPre = false;
    var warned = false;

    function warnOnce(msg) {
      if (!warned) {
        warned = true;
        warn$2(msg);
      }
    }

    function closeElement(element) {
      // check pre state
      if (element.pre) {
        inVPre = false;
      }
      if (platformIsPreTag(element.tag)) {
        inPre = false;
      }
      // apply post-transforms
      for (var i = 0; i < postTransforms.length; i++) {
        postTransforms[i](element, options);
      }
    }

    parseHTML(template, {
      warn: warn$2,
      expectHTML: options.expectHTML,
      isUnaryTag: options.isUnaryTag,
      canBeLeftOpenTag: options.canBeLeftOpenTag,
      shouldDecodeNewlines: options.shouldDecodeNewlines,
      shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
      shouldKeepComment: options.comments,
      start: function start(tag, attrs, unary) {
        // check namespace.
        // inherit parent ns if there is one
        var ns = currentParent && currentParent.ns || platformGetTagNamespace(tag);

        // handle IE svg bug
        /* istanbul ignore if */
        if (isIE && ns === 'svg') {
          attrs = guardIESVGBug(attrs);
        }

        var element = createASTElement(tag, attrs, currentParent);
        if (ns) {
          element.ns = ns;
        }

        if (isForbiddenTag(element) && !isServerRendering()) {
          element.forbidden = true;
          "development" !== 'production' && warn$2('Templates should only be responsible for mapping the state to the ' + 'UI. Avoid placing tags with side-effects in your templates, such as ' + "<" + tag + ">" + ', as they will not be parsed.');
        }

        // apply pre-transforms
        for (var i = 0; i < preTransforms.length; i++) {
          element = preTransforms[i](element, options) || element;
        }

        if (!inVPre) {
          processPre(element);
          if (element.pre) {
            inVPre = true;
          }
        }
        if (platformIsPreTag(element.tag)) {
          inPre = true;
        }
        if (inVPre) {
          processRawAttrs(element);
        } else if (!element.processed) {
          // structural directives
          processFor(element);
          processIf(element);
          processOnce(element);
          // element-scope stuff
          processElement(element, options);
        }

        function checkRootConstraints(el) {
          {
            if (el.tag === 'slot' || el.tag === 'template') {
              warnOnce("Cannot use <" + el.tag + "> as component root element because it may " + 'contain multiple nodes.');
            }
            if (el.attrsMap.hasOwnProperty('v-for')) {
              warnOnce('Cannot use v-for on stateful component root element because ' + 'it renders multiple elements.');
            }
          }
        }

        // tree management
        if (!root) {
          root = element;
          checkRootConstraints(root);
        } else if (!stack.length) {
          // allow root elements with v-if, v-else-if and v-else
          if (root.if && (element.elseif || element.else)) {
            checkRootConstraints(element);
            addIfCondition(root, {
              exp: element.elseif,
              block: element
            });
          } else {
            warnOnce("Component template should contain exactly one root element. " + "If you are using v-if on multiple elements, " + "use v-else-if to chain them instead.");
          }
        }
        if (currentParent && !element.forbidden) {
          if (element.elseif || element.else) {
            processIfConditions(element, currentParent);
          } else if (element.slotScope) {
            // scoped slot
            currentParent.plain = false;
            var name = element.slotTarget || '"default"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
          } else {
            currentParent.children.push(element);
            element.parent = currentParent;
          }
        }
        if (!unary) {
          currentParent = element;
          stack.push(element);
        } else {
          closeElement(element);
        }
      },

      end: function end() {
        // remove trailing whitespace
        var element = stack[stack.length - 1];
        var lastNode = element.children[element.children.length - 1];
        if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {
          element.children.pop();
        }
        // pop stack
        stack.length -= 1;
        currentParent = stack[stack.length - 1];
        closeElement(element);
      },

      chars: function chars(text) {
        if (!currentParent) {
          {
            if (text === template) {
              warnOnce('Component template requires a root element, rather than just text.');
            } else if (text = text.trim()) {
              warnOnce("text \"" + text + "\" outside root element will be ignored.");
            }
          }
          return;
        }
        // IE textarea placeholder bug
        /* istanbul ignore if */
        if (isIE && currentParent.tag === 'textarea' && currentParent.attrsMap.placeholder === text) {
          return;
        }
        var children = currentParent.children;
        text = inPre || text.trim() ? isTextTag(currentParent) ? text : decodeHTMLCached(text)
        // only preserve whitespace if its not right after a starting tag
        : preserveWhitespace && children.length ? ' ' : '';
        if (text) {
          var res;
          if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {
            children.push({
              type: 2,
              expression: res.expression,
              tokens: res.tokens,
              text: text
            });
          } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
            children.push({
              type: 3,
              text: text
            });
          }
        }
      },
      comment: function comment(text) {
        currentParent.children.push({
          type: 3,
          text: text,
          isComment: true
        });
      }
    });
    return root;
  }

  function processPre(el) {
    if (getAndRemoveAttr(el, 'v-pre') != null) {
      el.pre = true;
    }
  }

  function processRawAttrs(el) {
    var l = el.attrsList.length;
    if (l) {
      var attrs = el.attrs = new Array(l);
      for (var i = 0; i < l; i++) {
        attrs[i] = {
          name: el.attrsList[i].name,
          value: JSON.stringify(el.attrsList[i].value)
        };
      }
    } else if (!el.pre) {
      // non root node in pre blocks with no attributes
      el.plain = true;
    }
  }

  function processElement(element, options) {
    processKey(element);

    // determine whether this is a plain element after
    // removing structural attributes
    element.plain = !element.key && !element.attrsList.length;

    processRef(element);
    processSlot(element);
    processComponent(element);
    for (var i = 0; i < transforms.length; i++) {
      element = transforms[i](element, options) || element;
    }
    processAttrs(element);
  }

  function processKey(el) {
    var exp = getBindingAttr(el, 'key');
    if (exp) {
      if ("development" !== 'production' && el.tag === 'template') {
        warn$2("<template> cannot be keyed. Place the key on real elements instead.");
      }
      el.key = exp;
    }
  }

  function processRef(el) {
    var ref = getBindingAttr(el, 'ref');
    if (ref) {
      el.ref = ref;
      el.refInFor = checkInFor(el);
    }
  }

  function processFor(el) {
    var exp;
    if (exp = getAndRemoveAttr(el, 'v-for')) {
      var res = parseFor(exp);
      if (res) {
        extend(el, res);
      } else {
        warn$2("Invalid v-for expression: " + exp);
      }
    }
  }

  function parseFor(exp) {
    var inMatch = exp.match(forAliasRE);
    if (!inMatch) {
      return;
    }
    var res = {};
    res.for = inMatch[2].trim();
    var alias = inMatch[1].trim().replace(stripParensRE, '');
    var iteratorMatch = alias.match(forIteratorRE);
    if (iteratorMatch) {
      res.alias = alias.replace(forIteratorRE, '');
      res.iterator1 = iteratorMatch[1].trim();
      if (iteratorMatch[2]) {
        res.iterator2 = iteratorMatch[2].trim();
      }
    } else {
      res.alias = alias;
    }
    return res;
  }

  function processIf(el) {
    var exp = getAndRemoveAttr(el, 'v-if');
    if (exp) {
      el.if = exp;
      addIfCondition(el, {
        exp: exp,
        block: el
      });
    } else {
      if (getAndRemoveAttr(el, 'v-else') != null) {
        el.else = true;
      }
      var elseif = getAndRemoveAttr(el, 'v-else-if');
      if (elseif) {
        el.elseif = elseif;
      }
    }
  }

  function processIfConditions(el, parent) {
    var prev = findPrevElement(parent.children);
    if (prev && prev.if) {
      addIfCondition(prev, {
        exp: el.elseif,
        block: el
      });
    } else {
      warn$2("v-" + (el.elseif ? 'else-if="' + el.elseif + '"' : 'else') + " " + "used on element <" + el.tag + "> without corresponding v-if.");
    }
  }

  function findPrevElement(children) {
    var i = children.length;
    while (i--) {
      if (children[i].type === 1) {
        return children[i];
      } else {
        if ("development" !== 'production' && children[i].text !== ' ') {
          warn$2("text \"" + children[i].text.trim() + "\" between v-if and v-else(-if) " + "will be ignored.");
        }
        children.pop();
      }
    }
  }

  function addIfCondition(el, condition) {
    if (!el.ifConditions) {
      el.ifConditions = [];
    }
    el.ifConditions.push(condition);
  }

  function processOnce(el) {
    var once$$1 = getAndRemoveAttr(el, 'v-once');
    if (once$$1 != null) {
      el.once = true;
    }
  }

  function processSlot(el) {
    if (el.tag === 'slot') {
      el.slotName = getBindingAttr(el, 'name');
      if ("development" !== 'production' && el.key) {
        warn$2("`key` does not work on <slot> because slots are abstract outlets " + "and can possibly expand into multiple elements. " + "Use the key on a wrapping element instead.");
      }
    } else {
      var slotScope;
      if (el.tag === 'template') {
        slotScope = getAndRemoveAttr(el, 'scope');
        /* istanbul ignore if */
        if ("development" !== 'production' && slotScope) {
          warn$2("the \"scope\" attribute for scoped slots have been deprecated and " + "replaced by \"slot-scope\" since 2.5. The new \"slot-scope\" attribute " + "can also be used on plain elements in addition to <template> to " + "denote scoped slots.", true);
        }
        el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');
      } else if (slotScope = getAndRemoveAttr(el, 'slot-scope')) {
        /* istanbul ignore if */
        if ("development" !== 'production' && el.attrsMap['v-for']) {
          warn$2("Ambiguous combined usage of slot-scope and v-for on <" + el.tag + "> " + "(v-for takes higher priority). Use a wrapper <template> for the " + "scoped slot to make it clearer.", true);
        }
        el.slotScope = slotScope;
      }
      var slotTarget = getBindingAttr(el, 'slot');
      if (slotTarget) {
        el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
        // preserve slot as an attribute for native shadow DOM compat
        // only for non-scoped slots.
        if (el.tag !== 'template' && !el.slotScope) {
          addAttr(el, 'slot', slotTarget);
        }
      }
    }
  }

  function processComponent(el) {
    var binding;
    if (binding = getBindingAttr(el, 'is')) {
      el.component = binding;
    }
    if (getAndRemoveAttr(el, 'inline-template') != null) {
      el.inlineTemplate = true;
    }
  }

  function processAttrs(el) {
    var list = el.attrsList;
    var i, l, name, rawName, value, modifiers, isProp;
    for (i = 0, l = list.length; i < l; i++) {
      name = rawName = list[i].name;
      value = list[i].value;
      if (dirRE.test(name)) {
        // mark element as dynamic
        el.hasBindings = true;
        // modifiers
        modifiers = parseModifiers(name);
        if (modifiers) {
          name = name.replace(modifierRE, '');
        }
        if (bindRE.test(name)) {
          // v-bind
          name = name.replace(bindRE, '');
          value = parseFilters(value);
          isProp = false;
          if (modifiers) {
            if (modifiers.prop) {
              isProp = true;
              name = camelize(name);
              if (name === 'innerHtml') {
                name = 'innerHTML';
              }
            }
            if (modifiers.camel) {
              name = camelize(name);
            }
            if (modifiers.sync) {
              addHandler(el, "update:" + camelize(name), genAssignmentCode(value, "$event"));
            }
          }
          if (isProp || !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)) {
            addProp(el, name, value);
          } else {
            addAttr(el, name, value);
          }
        } else if (onRE.test(name)) {
          // v-on
          name = name.replace(onRE, '');
          addHandler(el, name, value, modifiers, false, warn$2);
        } else {
          // normal directives
          name = name.replace(dirRE, '');
          // parse arg
          var argMatch = name.match(argRE);
          var arg = argMatch && argMatch[1];
          if (arg) {
            name = name.slice(0, -(arg.length + 1));
          }
          addDirective(el, name, rawName, value, arg, modifiers);
          if ("development" !== 'production' && name === 'model') {
            checkForAliasModel(el, value);
          }
        }
      } else {
        // literal attribute
        {
          var res = parseText(value, delimiters);
          if (res) {
            warn$2(name + "=\"" + value + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div id="{{ val }}">, use <div :id="val">.');
          }
        }
        addAttr(el, name, JSON.stringify(value));
        // #6887 firefox doesn't update muted state if set via attribute
        // even immediately after element creation
        if (!el.component && name === 'muted' && platformMustUseProp(el.tag, el.attrsMap.type, name)) {
          addProp(el, name, 'true');
        }
      }
    }
  }

  function checkInFor(el) {
    var parent = el;
    while (parent) {
      if (parent.for !== undefined) {
        return true;
      }
      parent = parent.parent;
    }
    return false;
  }

  function parseModifiers(name) {
    var match = name.match(modifierRE);
    if (match) {
      var ret = {};
      match.forEach(function (m) {
        ret[m.slice(1)] = true;
      });
      return ret;
    }
  }

  function makeAttrsMap(attrs) {
    var map = {};
    for (var i = 0, l = attrs.length; i < l; i++) {
      if ("development" !== 'production' && map[attrs[i].name] && !isIE && !isEdge) {
        warn$2('duplicate attribute: ' + attrs[i].name);
      }
      map[attrs[i].name] = attrs[i].value;
    }
    return map;
  }

  // for script (e.g. type="x/template") or style, do not decode content
  function isTextTag(el) {
    return el.tag === 'script' || el.tag === 'style';
  }

  function isForbiddenTag(el) {
    return el.tag === 'style' || el.tag === 'script' && (!el.attrsMap.type || el.attrsMap.type === 'text/javascript');
  }

  var ieNSBug = /^xmlns:NS\d+/;
  var ieNSPrefix = /^NS\d+:/;

  /* istanbul ignore next */
  function guardIESVGBug(attrs) {
    var res = [];
    for (var i = 0; i < attrs.length; i++) {
      var attr = attrs[i];
      if (!ieNSBug.test(attr.name)) {
        attr.name = attr.name.replace(ieNSPrefix, '');
        res.push(attr);
      }
    }
    return res;
  }

  function checkForAliasModel(el, value) {
    var _el = el;
    while (_el) {
      if (_el.for && _el.alias === value) {
        warn$2("<" + el.tag + " v-model=\"" + value + "\">: " + "You are binding v-model directly to a v-for iteration alias. " + "This will not be able to modify the v-for source array because " + "writing to the alias is like modifying a function local variable. " + "Consider using an array of objects and use v-model on an object property instead.");
      }
      _el = _el.parent;
    }
  }

  /*  */

  /**
   * Expand input[v-model] with dyanmic type bindings into v-if-else chains
   * Turn this:
   *   <input v-model="data[type]" :type="type">
   * into this:
   *   <input v-if="type === 'checkbox'" type="checkbox" v-model="data[type]">
   *   <input v-else-if="type === 'radio'" type="radio" v-model="data[type]">
   *   <input v-else :type="type" v-model="data[type]">
   */

  function preTransformNode(el, options) {
    if (el.tag === 'input') {
      var map = el.attrsMap;
      if (!map['v-model']) {
        return;
      }

      var typeBinding;
      if (map[':type'] || map['v-bind:type']) {
        typeBinding = getBindingAttr(el, 'type');
      }
      if (!map.type && !typeBinding && map['v-bind']) {
        typeBinding = "(" + map['v-bind'] + ").type";
      }

      if (typeBinding) {
        var ifCondition = getAndRemoveAttr(el, 'v-if', true);
        var ifConditionExtra = ifCondition ? "&&(" + ifCondition + ")" : "";
        var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;
        var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true);
        // 1. checkbox
        var branch0 = cloneASTElement(el);
        // process for on the main node
        processFor(branch0);
        addRawAttr(branch0, 'type', 'checkbox');
        processElement(branch0, options);
        branch0.processed = true; // prevent it from double-processed
        branch0.if = "(" + typeBinding + ")==='checkbox'" + ifConditionExtra;
        addIfCondition(branch0, {
          exp: branch0.if,
          block: branch0
        });
        // 2. add radio else-if condition
        var branch1 = cloneASTElement(el);
        getAndRemoveAttr(branch1, 'v-for', true);
        addRawAttr(branch1, 'type', 'radio');
        processElement(branch1, options);
        addIfCondition(branch0, {
          exp: "(" + typeBinding + ")==='radio'" + ifConditionExtra,
          block: branch1
        });
        // 3. other
        var branch2 = cloneASTElement(el);
        getAndRemoveAttr(branch2, 'v-for', true);
        addRawAttr(branch2, ':type', typeBinding);
        processElement(branch2, options);
        addIfCondition(branch0, {
          exp: ifCondition,
          block: branch2
        });

        if (hasElse) {
          branch0.else = true;
        } else if (elseIfCondition) {
          branch0.elseif = elseIfCondition;
        }

        return branch0;
      }
    }
  }

  function cloneASTElement(el) {
    return createASTElement(el.tag, el.attrsList.slice(), el.parent);
  }

  var model$2 = {
    preTransformNode: preTransformNode
  };

  var modules$1 = [klass$1, style$1, model$2];

  /*  */

  function text(el, dir) {
    if (dir.value) {
      addProp(el, 'textContent', "_s(" + dir.value + ")");
    }
  }

  /*  */

  function html(el, dir) {
    if (dir.value) {
      addProp(el, 'innerHTML', "_s(" + dir.value + ")");
    }
  }

  var directives$1 = {
    model: model,
    text: text,
    html: html

    /*  */

  };var baseOptions = {
    expectHTML: true,
    modules: modules$1,
    directives: directives$1,
    isPreTag: isPreTag,
    isUnaryTag: isUnaryTag,
    mustUseProp: mustUseProp,
    canBeLeftOpenTag: canBeLeftOpenTag,
    isReservedTag: isReservedTag,
    getTagNamespace: getTagNamespace,
    staticKeys: genStaticKeys(modules$1)
  };

  /*  */

  var isStaticKey;
  var isPlatformReservedTag;

  var genStaticKeysCached = cached(genStaticKeys$1);

  /**
   * Goal of the optimizer: walk the generated template AST tree
   * and detect sub-trees that are purely static, i.e. parts of
   * the DOM that never needs to change.
   *
   * Once we detect these sub-trees, we can:
   *
   * 1. Hoist them into constants, so that we no longer need to
   *    create fresh nodes for them on each re-render;
   * 2. Completely skip them in the patching process.
   */
  function optimize(root, options) {
    if (!root) {
      return;
    }
    isStaticKey = genStaticKeysCached(options.staticKeys || '');
    isPlatformReservedTag = options.isReservedTag || no;
    // first pass: mark all non-static nodes.
    markStatic$1(root);
    // second pass: mark static roots.
    markStaticRoots(root, false);
  }

  function genStaticKeys$1(keys) {
    return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs' + (keys ? ',' + keys : ''));
  }

  function markStatic$1(node) {
    node.static = isStatic(node);
    if (node.type === 1) {
      // do not make component slot content static. this avoids
      // 1. components not able to mutate slot nodes
      // 2. static slot content fails for hot-reloading
      if (!isPlatformReservedTag(node.tag) && node.tag !== 'slot' && node.attrsMap['inline-template'] == null) {
        return;
      }
      for (var i = 0, l = node.children.length; i < l; i++) {
        var child = node.children[i];
        markStatic$1(child);
        if (!child.static) {
          node.static = false;
        }
      }
      if (node.ifConditions) {
        for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
          var block = node.ifConditions[i$1].block;
          markStatic$1(block);
          if (!block.static) {
            node.static = false;
          }
        }
      }
    }
  }

  function markStaticRoots(node, isInFor) {
    if (node.type === 1) {
      if (node.static || node.once) {
        node.staticInFor = isInFor;
      }
      // For a node to qualify as a static root, it should have children that
      // are not just static text. Otherwise the cost of hoisting out will
      // outweigh the benefits and it's better off to just always render it fresh.
      if (node.static && node.children.length && !(node.children.length === 1 && node.children[0].type === 3)) {
        node.staticRoot = true;
        return;
      } else {
        node.staticRoot = false;
      }
      if (node.children) {
        for (var i = 0, l = node.children.length; i < l; i++) {
          markStaticRoots(node.children[i], isInFor || !!node.for);
        }
      }
      if (node.ifConditions) {
        for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
          markStaticRoots(node.ifConditions[i$1].block, isInFor);
        }
      }
    }
  }

  function isStatic(node) {
    if (node.type === 2) {
      // expression
      return false;
    }
    if (node.type === 3) {
      // text
      return true;
    }
    return !!(node.pre || !node.hasBindings && // no dynamic bindings
    !node.if && !node.for && // not v-if or v-for or v-else
    !isBuiltInTag(node.tag) && // not a built-in
    isPlatformReservedTag(node.tag) && // not a component
    !isDirectChildOfTemplateFor(node) && Object.keys(node).every(isStaticKey));
  }

  function isDirectChildOfTemplateFor(node) {
    while (node.parent) {
      node = node.parent;
      if (node.tag !== 'template') {
        return false;
      }
      if (node.for) {
        return true;
      }
    }
    return false;
  }

  /*  */

  var fnExpRE = /^([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(/;
  var simplePathRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/;

  // KeyboardEvent.keyCode aliases
  var keyCodes = {
    esc: 27,
    tab: 9,
    enter: 13,
    space: 32,
    up: 38,
    left: 37,
    right: 39,
    down: 40,
    'delete': [8, 46]
  };

  // KeyboardEvent.key aliases
  var keyNames = {
    esc: 'Escape',
    tab: 'Tab',
    enter: 'Enter',
    space: ' ',
    // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.
    up: ['Up', 'ArrowUp'],
    left: ['Left', 'ArrowLeft'],
    right: ['Right', 'ArrowRight'],
    down: ['Down', 'ArrowDown'],
    'delete': ['Backspace', 'Delete']
  };

  // #4868: modifiers that prevent the execution of the listener
  // need to explicitly return null so that we can determine whether to remove
  // the listener for .once
  var genGuard = function genGuard(condition) {
    return "if(" + condition + ")return null;";
  };

  var modifierCode = {
    stop: '$event.stopPropagation();',
    prevent: '$event.preventDefault();',
    self: genGuard("$event.target !== $event.currentTarget"),
    ctrl: genGuard("!$event.ctrlKey"),
    shift: genGuard("!$event.shiftKey"),
    alt: genGuard("!$event.altKey"),
    meta: genGuard("!$event.metaKey"),
    left: genGuard("'button' in $event && $event.button !== 0"),
    middle: genGuard("'button' in $event && $event.button !== 1"),
    right: genGuard("'button' in $event && $event.button !== 2")
  };

  function genHandlers(events, isNative, warn) {
    var res = isNative ? 'nativeOn:{' : 'on:{';
    for (var name in events) {
      res += "\"" + name + "\":" + genHandler(name, events[name]) + ",";
    }
    return res.slice(0, -1) + '}';
  }

  function genHandler(name, handler) {
    if (!handler) {
      return 'function(){}';
    }

    if (Array.isArray(handler)) {
      return "[" + handler.map(function (handler) {
        return genHandler(name, handler);
      }).join(',') + "]";
    }

    var isMethodPath = simplePathRE.test(handler.value);
    var isFunctionExpression = fnExpRE.test(handler.value);

    if (!handler.modifiers) {
      if (isMethodPath || isFunctionExpression) {
        return handler.value;
      }
      /* istanbul ignore if */
      return "function($event){" + handler.value + "}"; // inline statement
    } else {
      var code = '';
      var genModifierCode = '';
      var keys = [];
      for (var key in handler.modifiers) {
        if (modifierCode[key]) {
          genModifierCode += modifierCode[key];
          // left/right
          if (keyCodes[key]) {
            keys.push(key);
          }
        } else if (key === 'exact') {
          var modifiers = handler.modifiers;
          genModifierCode += genGuard(['ctrl', 'shift', 'alt', 'meta'].filter(function (keyModifier) {
            return !modifiers[keyModifier];
          }).map(function (keyModifier) {
            return "$event." + keyModifier + "Key";
          }).join('||'));
        } else {
          keys.push(key);
        }
      }
      if (keys.length) {
        code += genKeyFilter(keys);
      }
      // Make sure modifiers like prevent and stop get executed after key filtering
      if (genModifierCode) {
        code += genModifierCode;
      }
      var handlerCode = isMethodPath ? "return " + handler.value + "($event)" : isFunctionExpression ? "return (" + handler.value + ")($event)" : handler.value;
      /* istanbul ignore if */
      return "function($event){" + code + handlerCode + "}";
    }
  }

  function genKeyFilter(keys) {
    return "if(!('button' in $event)&&" + keys.map(genFilterCode).join('&&') + ")return null;";
  }

  function genFilterCode(key) {
    var keyVal = parseInt(key, 10);
    if (keyVal) {
      return "$event.keyCode!==" + keyVal;
    }
    var keyCode = keyCodes[key];
    var keyName = keyNames[key];
    return "_k($event.keyCode," + JSON.stringify(key) + "," + JSON.stringify(keyCode) + "," + "$event.key," + "" + JSON.stringify(keyName) + ")";
  }

  /*  */

  function on(el, dir) {
    if ("development" !== 'production' && dir.modifiers) {
      warn("v-on without argument does not support modifiers.");
    }
    el.wrapListeners = function (code) {
      return "_g(" + code + "," + dir.value + ")";
    };
  }

  /*  */

  function bind$1(el, dir) {
    el.wrapData = function (code) {
      return "_b(" + code + ",'" + el.tag + "'," + dir.value + "," + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + ")";
    };
  }

  /*  */

  var baseDirectives = {
    on: on,
    bind: bind$1,
    cloak: noop

    /*  */

  };var CodegenState = function CodegenState(options) {
    this.options = options;
    this.warn = options.warn || baseWarn;
    this.transforms = pluckModuleFunction(options.modules, 'transformCode');
    this.dataGenFns = pluckModuleFunction(options.modules, 'genData');
    this.directives = extend(extend({}, baseDirectives), options.directives);
    var isReservedTag = options.isReservedTag || no;
    this.maybeComponent = function (el) {
      return !isReservedTag(el.tag);
    };
    this.onceId = 0;
    this.staticRenderFns = [];
  };

  function generate(ast, options) {
    var state = new CodegenState(options);
    var code = ast ? genElement(ast, state) : '_c("div")';
    return {
      render: "with(this){return " + code + "}",
      staticRenderFns: state.staticRenderFns
    };
  }

  function genElement(el, state) {
    if (el.staticRoot && !el.staticProcessed) {
      return genStatic(el, state);
    } else if (el.once && !el.onceProcessed) {
      return genOnce(el, state);
    } else if (el.for && !el.forProcessed) {
      return genFor(el, state);
    } else if (el.if && !el.ifProcessed) {
      return genIf(el, state);
    } else if (el.tag === 'template' && !el.slotTarget) {
      return genChildren(el, state) || 'void 0';
    } else if (el.tag === 'slot') {
      return genSlot(el, state);
    } else {
      // component or element
      var code;
      if (el.component) {
        code = genComponent(el.component, el, state);
      } else {
        var data = el.plain ? undefined : genData$2(el, state);

        var children = el.inlineTemplate ? null : genChildren(el, state, true);
        code = "_c('" + el.tag + "'" + (data ? "," + data : '') + (children ? "," + children : '') + ")";
      }
      // module transforms
      for (var i = 0; i < state.transforms.length; i++) {
        code = state.transforms[i](el, code);
      }
      return code;
    }
  }

  // hoist static sub-trees out
  function genStatic(el, state) {
    el.staticProcessed = true;
    state.staticRenderFns.push("with(this){return " + genElement(el, state) + "}");
    return "_m(" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")";
  }

  // v-once
  function genOnce(el, state) {
    el.onceProcessed = true;
    if (el.if && !el.ifProcessed) {
      return genIf(el, state);
    } else if (el.staticInFor) {
      var key = '';
      var parent = el.parent;
      while (parent) {
        if (parent.for) {
          key = parent.key;
          break;
        }
        parent = parent.parent;
      }
      if (!key) {
        "development" !== 'production' && state.warn("v-once can only be used inside v-for that is keyed. ");
        return genElement(el, state);
      }
      return "_o(" + genElement(el, state) + "," + state.onceId++ + "," + key + ")";
    } else {
      return genStatic(el, state);
    }
  }

  function genIf(el, state, altGen, altEmpty) {
    el.ifProcessed = true; // avoid recursion
    return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty);
  }

  function genIfConditions(conditions, state, altGen, altEmpty) {
    if (!conditions.length) {
      return altEmpty || '_e()';
    }

    var condition = conditions.shift();
    if (condition.exp) {
      return "(" + condition.exp + ")?" + genTernaryExp(condition.block) + ":" + genIfConditions(conditions, state, altGen, altEmpty);
    } else {
      return "" + genTernaryExp(condition.block);
    }

    // v-if with v-once should generate code like (a)?_m(0):_m(1)
    function genTernaryExp(el) {
      return altGen ? altGen(el, state) : el.once ? genOnce(el, state) : genElement(el, state);
    }
  }

  function genFor(el, state, altGen, altHelper) {
    var exp = el.for;
    var alias = el.alias;
    var iterator1 = el.iterator1 ? "," + el.iterator1 : '';
    var iterator2 = el.iterator2 ? "," + el.iterator2 : '';

    if ("development" !== 'production' && state.maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key) {
      state.warn("<" + el.tag + " v-for=\"" + alias + " in " + exp + "\">: component lists rendered with " + "v-for should have explicit keys. " + "See https://vuejs.org/guide/list.html#key for more info.", true /* tip */
      );
    }

    el.forProcessed = true; // avoid recursion
    return (altHelper || '_l') + "((" + exp + ")," + "function(" + alias + iterator1 + iterator2 + "){" + "return " + (altGen || genElement)(el, state) + '})';
  }

  function genData$2(el, state) {
    var data = '{';

    // directives first.
    // directives may mutate the el's other properties before they are generated.
    var dirs = genDirectives(el, state);
    if (dirs) {
      data += dirs + ',';
    }

    // key
    if (el.key) {
      data += "key:" + el.key + ",";
    }
    // ref
    if (el.ref) {
      data += "ref:" + el.ref + ",";
    }
    if (el.refInFor) {
      data += "refInFor:true,";
    }
    // pre
    if (el.pre) {
      data += "pre:true,";
    }
    // record original tag name for components using "is" attribute
    if (el.component) {
      data += "tag:\"" + el.tag + "\",";
    }
    // module data generation functions
    for (var i = 0; i < state.dataGenFns.length; i++) {
      data += state.dataGenFns[i](el);
    }
    // attributes
    if (el.attrs) {
      data += "attrs:{" + genProps(el.attrs) + "},";
    }
    // DOM props
    if (el.props) {
      data += "domProps:{" + genProps(el.props) + "},";
    }
    // event handlers
    if (el.events) {
      data += genHandlers(el.events, false, state.warn) + ",";
    }
    if (el.nativeEvents) {
      data += genHandlers(el.nativeEvents, true, state.warn) + ",";
    }
    // slot target
    // only for non-scoped slots
    if (el.slotTarget && !el.slotScope) {
      data += "slot:" + el.slotTarget + ",";
    }
    // scoped slots
    if (el.scopedSlots) {
      data += genScopedSlots(el.scopedSlots, state) + ",";
    }
    // component v-model
    if (el.model) {
      data += "model:{value:" + el.model.value + ",callback:" + el.model.callback + ",expression:" + el.model.expression + "},";
    }
    // inline-template
    if (el.inlineTemplate) {
      var inlineTemplate = genInlineTemplate(el, state);
      if (inlineTemplate) {
        data += inlineTemplate + ",";
      }
    }
    data = data.replace(/,$/, '') + '}';
    // v-bind data wrap
    if (el.wrapData) {
      data = el.wrapData(data);
    }
    // v-on data wrap
    if (el.wrapListeners) {
      data = el.wrapListeners(data);
    }
    return data;
  }

  function genDirectives(el, state) {
    var dirs = el.directives;
    if (!dirs) {
      return;
    }
    var res = 'directives:[';
    var hasRuntime = false;
    var i, l, dir, needRuntime;
    for (i = 0, l = dirs.length; i < l; i++) {
      dir = dirs[i];
      needRuntime = true;
      var gen = state.directives[dir.name];
      if (gen) {
        // compile-time directive that manipulates AST.
        // returns true if it also needs a runtime counterpart.
        needRuntime = !!gen(el, dir, state.warn);
      }
      if (needRuntime) {
        hasRuntime = true;
        res += "{name:\"" + dir.name + "\",rawName:\"" + dir.rawName + "\"" + (dir.value ? ",value:(" + dir.value + "),expression:" + JSON.stringify(dir.value) : '') + (dir.arg ? ",arg:\"" + dir.arg + "\"" : '') + (dir.modifiers ? ",modifiers:" + JSON.stringify(dir.modifiers) : '') + "},";
      }
    }
    if (hasRuntime) {
      return res.slice(0, -1) + ']';
    }
  }

  function genInlineTemplate(el, state) {
    var ast = el.children[0];
    if ("development" !== 'production' && (el.children.length !== 1 || ast.type !== 1)) {
      state.warn('Inline-template components must have exactly one child element.');
    }
    if (ast.type === 1) {
      var inlineRenderFns = generate(ast, state.options);
      return "inlineTemplate:{render:function(){" + inlineRenderFns.render + "},staticRenderFns:[" + inlineRenderFns.staticRenderFns.map(function (code) {
        return "function(){" + code + "}";
      }).join(',') + "]}";
    }
  }

  function genScopedSlots(slots, state) {
    return "scopedSlots:_u([" + Object.keys(slots).map(function (key) {
      return genScopedSlot(key, slots[key], state);
    }).join(',') + "])";
  }

  function genScopedSlot(key, el, state) {
    if (el.for && !el.forProcessed) {
      return genForScopedSlot(key, el, state);
    }
    var fn = "function(" + String(el.slotScope) + "){" + "return " + (el.tag === 'template' ? el.if ? el.if + "?" + (genChildren(el, state) || 'undefined') + ":undefined" : genChildren(el, state) || 'undefined' : genElement(el, state)) + "}";
    return "{key:" + key + ",fn:" + fn + "}";
  }

  function genForScopedSlot(key, el, state) {
    var exp = el.for;
    var alias = el.alias;
    var iterator1 = el.iterator1 ? "," + el.iterator1 : '';
    var iterator2 = el.iterator2 ? "," + el.iterator2 : '';
    el.forProcessed = true; // avoid recursion
    return "_l((" + exp + ")," + "function(" + alias + iterator1 + iterator2 + "){" + "return " + genScopedSlot(key, el, state) + '})';
  }

  function genChildren(el, state, checkSkip, altGenElement, altGenNode) {
    var children = el.children;
    if (children.length) {
      var el$1 = children[0];
      // optimize single v-for
      if (children.length === 1 && el$1.for && el$1.tag !== 'template' && el$1.tag !== 'slot') {
        return (altGenElement || genElement)(el$1, state);
      }
      var normalizationType = checkSkip ? getNormalizationType(children, state.maybeComponent) : 0;
      var gen = altGenNode || genNode;
      return "[" + children.map(function (c) {
        return gen(c, state);
      }).join(',') + "]" + (normalizationType ? "," + normalizationType : '');
    }
  }

  // determine the normalization needed for the children array.
  // 0: no normalization needed
  // 1: simple normalization needed (possible 1-level deep nested array)
  // 2: full normalization needed
  function getNormalizationType(children, maybeComponent) {
    var res = 0;
    for (var i = 0; i < children.length; i++) {
      var el = children[i];
      if (el.type !== 1) {
        continue;
      }
      if (needsNormalization(el) || el.ifConditions && el.ifConditions.some(function (c) {
        return needsNormalization(c.block);
      })) {
        res = 2;
        break;
      }
      if (maybeComponent(el) || el.ifConditions && el.ifConditions.some(function (c) {
        return maybeComponent(c.block);
      })) {
        res = 1;
      }
    }
    return res;
  }

  function needsNormalization(el) {
    return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';
  }

  function genNode(node, state) {
    if (node.type === 1) {
      return genElement(node, state);
    }if (node.type === 3 && node.isComment) {
      return genComment(node);
    } else {
      return genText(node);
    }
  }

  function genText(text) {
    return "_v(" + (text.type === 2 ? text.expression // no need for () because already wrapped in _s()
    : transformSpecialNewlines(JSON.stringify(text.text))) + ")";
  }

  function genComment(comment) {
    return "_e(" + JSON.stringify(comment.text) + ")";
  }

  function genSlot(el, state) {
    var slotName = el.slotName || '"default"';
    var children = genChildren(el, state);
    var res = "_t(" + slotName + (children ? "," + children : '');
    var attrs = el.attrs && "{" + el.attrs.map(function (a) {
      return camelize(a.name) + ":" + a.value;
    }).join(',') + "}";
    var bind$$1 = el.attrsMap['v-bind'];
    if ((attrs || bind$$1) && !children) {
      res += ",null";
    }
    if (attrs) {
      res += "," + attrs;
    }
    if (bind$$1) {
      res += (attrs ? '' : ',null') + "," + bind$$1;
    }
    return res + ')';
  }

  // componentName is el.component, take it as argument to shun flow's pessimistic refinement
  function genComponent(componentName, el, state) {
    var children = el.inlineTemplate ? null : genChildren(el, state, true);
    return "_c(" + componentName + "," + genData$2(el, state) + (children ? "," + children : '') + ")";
  }

  function genProps(props) {
    var res = '';
    for (var i = 0; i < props.length; i++) {
      var prop = props[i];
      /* istanbul ignore if */
      {
        res += "\"" + prop.name + "\":" + transformSpecialNewlines(prop.value) + ",";
      }
    }
    return res.slice(0, -1);
  }

  // #3895, #4268
  function transformSpecialNewlines(text) {
    return text.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
  }

  /*  */

  // these keywords should not appear inside expressions, but operators like
  // typeof, instanceof and in are allowed
  var prohibitedKeywordRE = new RegExp('\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments').split(',').join('\\b|\\b') + '\\b');

  // these unary operators should not be used as property/method names
  var unaryOperatorsRE = new RegExp('\\b' + 'delete,typeof,void'.split(',').join('\\s*\\([^\\)]*\\)|\\b') + '\\s*\\([^\\)]*\\)');

  // strip strings in expressions
  var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;

  // detect problematic expressions in a template
  function detectErrors(ast) {
    var errors = [];
    if (ast) {
      checkNode(ast, errors);
    }
    return errors;
  }

  function checkNode(node, errors) {
    if (node.type === 1) {
      for (var name in node.attrsMap) {
        if (dirRE.test(name)) {
          var value = node.attrsMap[name];
          if (value) {
            if (name === 'v-for') {
              checkFor(node, "v-for=\"" + value + "\"", errors);
            } else if (onRE.test(name)) {
              checkEvent(value, name + "=\"" + value + "\"", errors);
            } else {
              checkExpression(value, name + "=\"" + value + "\"", errors);
            }
          }
        }
      }
      if (node.children) {
        for (var i = 0; i < node.children.length; i++) {
          checkNode(node.children[i], errors);
        }
      }
    } else if (node.type === 2) {
      checkExpression(node.expression, node.text, errors);
    }
  }

  function checkEvent(exp, text, errors) {
    var stipped = exp.replace(stripStringRE, '');
    var keywordMatch = stipped.match(unaryOperatorsRE);
    if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {
      errors.push("avoid using JavaScript unary operator as property name: " + "\"" + keywordMatch[0] + "\" in expression " + text.trim());
    }
    checkExpression(exp, text, errors);
  }

  function checkFor(node, text, errors) {
    checkExpression(node.for || '', text, errors);
    checkIdentifier(node.alias, 'v-for alias', text, errors);
    checkIdentifier(node.iterator1, 'v-for iterator', text, errors);
    checkIdentifier(node.iterator2, 'v-for iterator', text, errors);
  }

  function checkIdentifier(ident, type, text, errors) {
    if (typeof ident === 'string') {
      try {
        new Function("var " + ident + "=_");
      } catch (e) {
        errors.push("invalid " + type + " \"" + ident + "\" in expression: " + text.trim());
      }
    }
  }

  function checkExpression(exp, text, errors) {
    try {
      new Function("return " + exp);
    } catch (e) {
      var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);
      if (keywordMatch) {
        errors.push("avoid using JavaScript keyword as property name: " + "\"" + keywordMatch[0] + "\"\n  Raw expression: " + text.trim());
      } else {
        errors.push("invalid expression: " + e.message + " in\n\n" + "    " + exp + "\n\n" + "  Raw expression: " + text.trim() + "\n");
      }
    }
  }

  /*  */

  function createFunction(code, errors) {
    try {
      return new Function(code);
    } catch (err) {
      errors.push({ err: err, code: code });
      return noop;
    }
  }

  function createCompileToFunctionFn(compile) {
    var cache = Object.create(null);

    return function compileToFunctions(template, options, vm) {
      options = extend({}, options);
      var warn$$1 = options.warn || warn;
      delete options.warn;

      /* istanbul ignore if */
      {
        // detect possible CSP restriction
        try {
          new Function('return 1');
        } catch (e) {
          if (e.toString().match(/unsafe-eval|CSP/)) {
            warn$$1('It seems you are using the standalone build of Vue.js in an ' + 'environment with Content Security Policy that prohibits unsafe-eval. ' + 'The template compiler cannot work in this environment. Consider ' + 'relaxing the policy to allow unsafe-eval or pre-compiling your ' + 'templates into render functions.');
          }
        }
      }

      // check cache
      var key = options.delimiters ? String(options.delimiters) + template : template;
      if (cache[key]) {
        return cache[key];
      }

      // compile
      var compiled = compile(template, options);

      // check compilation errors/tips
      {
        if (compiled.errors && compiled.errors.length) {
          warn$$1("Error compiling template:\n\n" + template + "\n\n" + compiled.errors.map(function (e) {
            return "- " + e;
          }).join('\n') + '\n', vm);
        }
        if (compiled.tips && compiled.tips.length) {
          compiled.tips.forEach(function (msg) {
            return tip(msg, vm);
          });
        }
      }

      // turn code into functions
      var res = {};
      var fnGenErrors = [];
      res.render = createFunction(compiled.render, fnGenErrors);
      res.staticRenderFns = compiled.staticRenderFns.map(function (code) {
        return createFunction(code, fnGenErrors);
      });

      // check function generation errors.
      // this should only happen if there is a bug in the compiler itself.
      // mostly for codegen development use
      /* istanbul ignore if */
      {
        if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
          warn$$1("Failed to generate render function:\n\n" + fnGenErrors.map(function (ref) {
            var err = ref.err;
            var code = ref.code;

            return err.toString() + " in\n\n" + code + "\n";
          }).join('\n'), vm);
        }
      }

      return cache[key] = res;
    };
  }

  /*  */

  function createCompilerCreator(baseCompile) {
    return function createCompiler(baseOptions) {
      function compile(template, options) {
        var finalOptions = Object.create(baseOptions);
        var errors = [];
        var tips = [];
        finalOptions.warn = function (msg, tip) {
          (tip ? tips : errors).push(msg);
        };

        if (options) {
          // merge custom modules
          if (options.modules) {
            finalOptions.modules = (baseOptions.modules || []).concat(options.modules);
          }
          // merge custom directives
          if (options.directives) {
            finalOptions.directives = extend(Object.create(baseOptions.directives || null), options.directives);
          }
          // copy other options
          for (var key in options) {
            if (key !== 'modules' && key !== 'directives') {
              finalOptions[key] = options[key];
            }
          }
        }

        var compiled = baseCompile(template, finalOptions);
        {
          errors.push.apply(errors, detectErrors(compiled.ast));
        }
        compiled.errors = errors;
        compiled.tips = tips;
        return compiled;
      }

      return {
        compile: compile,
        compileToFunctions: createCompileToFunctionFn(compile)
      };
    };
  }

  /*  */

  // `createCompilerCreator` allows creating compilers that use alternative
  // parser/optimizer/codegen, e.g the SSR optimizing compiler.
  // Here we just export a default compiler using the default parts.
  var createCompiler = createCompilerCreator(function baseCompile(template, options) {
    var ast = parse(template.trim(), options);
    if (options.optimize !== false) {
      optimize(ast, options);
    }
    var code = generate(ast, options);
    return {
      ast: ast,
      render: code.render,
      staticRenderFns: code.staticRenderFns
    };
  });

  /*  */

  var ref$1 = createCompiler(baseOptions);
  var compileToFunctions = ref$1.compileToFunctions;

  /*  */

  // check whether current browser encodes a char inside attribute values
  var div;
  function getShouldDecode(href) {
    div = div || document.createElement('div');
    div.innerHTML = href ? "<a href=\"\n\"/>" : "<div a=\"\n\"/>";
    return div.innerHTML.indexOf('&#10;') > 0;
  }

  // #3663: IE encodes newlines inside attribute values while other browsers don't
  var shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false;
  // #6828: chrome encodes content in a[href]
  var shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;

  /*  */

  var idToTemplate = cached(function (id) {
    var el = query(id);
    return el && el.innerHTML;
  });

  var mount = Vue.prototype.$mount;
  Vue.prototype.$mount = function (el, hydrating) {
    el = el && query(el);

    /* istanbul ignore if */
    if (el === document.body || el === document.documentElement) {
      "development" !== 'production' && warn("Do not mount Vue to <html> or <body> - mount to normal elements instead.");
      return this;
    }

    var options = this.$options;
    // resolve template/el and convert to render function
    if (!options.render) {
      var template = options.template;
      if (template) {
        if (typeof template === 'string') {
          if (template.charAt(0) === '#') {
            template = idToTemplate(template);
            /* istanbul ignore if */
            if ("development" !== 'production' && !template) {
              warn("Template element not found or is empty: " + options.template, this);
            }
          }
        } else if (template.nodeType) {
          template = template.innerHTML;
        } else {
          {
            warn('invalid template option:' + template, this);
          }
          return this;
        }
      } else if (el) {
        template = getOuterHTML(el);
      }
      if (template) {
        /* istanbul ignore if */
        if ("development" !== 'production' && config.performance && mark) {
          mark('compile');
        }

        var ref = compileToFunctions(template, {
          shouldDecodeNewlines: shouldDecodeNewlines,
          shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,
          delimiters: options.delimiters,
          comments: options.comments
        }, this);
        var render = ref.render;
        var staticRenderFns = ref.staticRenderFns;
        options.render = render;
        options.staticRenderFns = staticRenderFns;

        /* istanbul ignore if */
        if ("development" !== 'production' && config.performance && mark) {
          mark('compile end');
          measure("vue " + this._name + " compile", 'compile', 'compile end');
        }
      }
    }
    return mount.call(this, el, hydrating);
  };

  /**
   * Get outerHTML of elements, taking care
   * of SVG elements in IE as well.
   */
  function getOuterHTML(el) {
    if (el.outerHTML) {
      return el.outerHTML;
    } else {
      var container = document.createElement('div');
      container.appendChild(el.cloneNode(true));
      return container.innerHTML;
    }
  }

  Vue.compile = compileToFunctions;

  return Vue;
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../../node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../node_modules/timers-browserify/main.js */ "./node_modules/timers-browserify/main.js").setImmediate))

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
    return [];
};

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function () {
    return 0;
};

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
        // Callback can either be a function or a string
        if (typeof callback !== "function") {
            callback = new Function("" + callback);
        }
        // Copy function arguments
        var args = new Array(arguments.length - 1);
        for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i + 1];
        }
        // Store and register the task
        var task = { callback: callback, args: args };
        tasksByHandle[nextHandle] = task;
        registerImmediate(nextHandle);
        return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
            case 0:
                callback();
                break;
            case 1:
                callback(args[0]);
                break;
            case 2:
                callback(args[0], args[1]);
                break;
            case 3:
                callback(args[0], args[1], args[2]);
                break;
            default:
                callback.apply(undefined, args);
                break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function registerImmediate(handle) {
            process.nextTick(function () {
                runIfPresent(handle);
            });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function () {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function onGlobalMessage(event) {
            if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function registerImmediate(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function (event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function registerImmediate(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function registerImmediate(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function registerImmediate(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();
    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();
    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();
    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 68
        installReadyStateChangeImplementation();
    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
})(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function () {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function () {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout = exports.clearInterval = function (timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function () {};
Timeout.prototype.close = function () {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function (item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function (item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function (item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout) item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(/*! setimmediate */ "./node_modules/setimmediate/setImmediate.js");
exports.setImmediate = setImmediate;
exports.clearImmediate = clearImmediate;

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var g;

// This works in non-strict mode
g = function () {
	return this;
}();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMmI3OTA2YWZkN2FmZWU1MzA1NTEiLCJ3ZWJwYWNrOi8vLy4vYXNzZXRzL2pzL3Z1ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiXSwibmFtZXMiOlsiZ2xvYmFsIiwiZmFjdG9yeSIsImV4cG9ydHMiLCJtb2R1bGUiLCJWdWUiLCJlbXB0eU9iamVjdCIsIk9iamVjdCIsImZyZWV6ZSIsImlzVW5kZWYiLCJ2IiwidW5kZWZpbmVkIiwiaXNEZWYiLCJpc1RydWUiLCJpc0ZhbHNlIiwiaXNQcmltaXRpdmUiLCJ2YWx1ZSIsImlzT2JqZWN0Iiwib2JqIiwiX3RvU3RyaW5nIiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJ0b1Jhd1R5cGUiLCJjYWxsIiwic2xpY2UiLCJpc1BsYWluT2JqZWN0IiwiaXNSZWdFeHAiLCJpc1ZhbGlkQXJyYXlJbmRleCIsInZhbCIsIm4iLCJwYXJzZUZsb2F0IiwiU3RyaW5nIiwiTWF0aCIsImZsb29yIiwiaXNGaW5pdGUiLCJKU09OIiwic3RyaW5naWZ5IiwidG9OdW1iZXIiLCJpc05hTiIsIm1ha2VNYXAiLCJzdHIiLCJleHBlY3RzTG93ZXJDYXNlIiwibWFwIiwiY3JlYXRlIiwibGlzdCIsInNwbGl0IiwiaSIsImxlbmd0aCIsInRvTG93ZXJDYXNlIiwiaXNCdWlsdEluVGFnIiwiaXNSZXNlcnZlZEF0dHJpYnV0ZSIsInJlbW92ZSIsImFyciIsIml0ZW0iLCJpbmRleCIsImluZGV4T2YiLCJzcGxpY2UiLCJoYXNPd25Qcm9wZXJ0eSIsImhhc093biIsImtleSIsImNhY2hlZCIsImZuIiwiY2FjaGUiLCJjYWNoZWRGbiIsImhpdCIsImNhbWVsaXplUkUiLCJjYW1lbGl6ZSIsInJlcGxhY2UiLCJfIiwiYyIsInRvVXBwZXJDYXNlIiwiY2FwaXRhbGl6ZSIsImNoYXJBdCIsImh5cGhlbmF0ZVJFIiwiaHlwaGVuYXRlIiwicG9seWZpbGxCaW5kIiwiY3R4IiwiYm91bmRGbiIsImEiLCJsIiwiYXJndW1lbnRzIiwiYXBwbHkiLCJfbGVuZ3RoIiwibmF0aXZlQmluZCIsImJpbmQiLCJGdW5jdGlvbiIsInRvQXJyYXkiLCJzdGFydCIsInJldCIsIkFycmF5IiwiZXh0ZW5kIiwidG8iLCJfZnJvbSIsInRvT2JqZWN0IiwicmVzIiwibm9vcCIsImIiLCJubyIsImlkZW50aXR5IiwiZ2VuU3RhdGljS2V5cyIsIm1vZHVsZXMiLCJyZWR1Y2UiLCJrZXlzIiwibSIsImNvbmNhdCIsInN0YXRpY0tleXMiLCJqb2luIiwibG9vc2VFcXVhbCIsImlzT2JqZWN0QSIsImlzT2JqZWN0QiIsImlzQXJyYXlBIiwiaXNBcnJheSIsImlzQXJyYXlCIiwiZXZlcnkiLCJlIiwia2V5c0EiLCJrZXlzQiIsImxvb3NlSW5kZXhPZiIsIm9uY2UiLCJjYWxsZWQiLCJTU1JfQVRUUiIsIkFTU0VUX1RZUEVTIiwiTElGRUNZQ0xFX0hPT0tTIiwiY29uZmlnIiwib3B0aW9uTWVyZ2VTdHJhdGVnaWVzIiwic2lsZW50IiwicHJvZHVjdGlvblRpcCIsImRldnRvb2xzIiwicGVyZm9ybWFuY2UiLCJlcnJvckhhbmRsZXIiLCJ3YXJuSGFuZGxlciIsImlnbm9yZWRFbGVtZW50cyIsImtleUNvZGVzIiwiaXNSZXNlcnZlZFRhZyIsImlzUmVzZXJ2ZWRBdHRyIiwiaXNVbmtub3duRWxlbWVudCIsImdldFRhZ05hbWVzcGFjZSIsInBhcnNlUGxhdGZvcm1UYWdOYW1lIiwibXVzdFVzZVByb3AiLCJfbGlmZWN5Y2xlSG9va3MiLCJpc1Jlc2VydmVkIiwiY2hhckNvZGVBdCIsImRlZiIsImVudW1lcmFibGUiLCJkZWZpbmVQcm9wZXJ0eSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiYmFpbFJFIiwicGFyc2VQYXRoIiwicGF0aCIsInRlc3QiLCJzZWdtZW50cyIsImhhc1Byb3RvIiwiaW5Ccm93c2VyIiwid2luZG93IiwiaW5XZWV4IiwiV1hFbnZpcm9ubWVudCIsInBsYXRmb3JtIiwid2VleFBsYXRmb3JtIiwiVUEiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpc0lFIiwiaXNJRTkiLCJpc0VkZ2UiLCJpc0FuZHJvaWQiLCJpc0lPUyIsImlzQ2hyb21lIiwibmF0aXZlV2F0Y2giLCJ3YXRjaCIsInN1cHBvcnRzUGFzc2l2ZSIsIm9wdHMiLCJnZXQiLCJhZGRFdmVudExpc3RlbmVyIiwiX2lzU2VydmVyIiwiaXNTZXJ2ZXJSZW5kZXJpbmciLCJlbnYiLCJWVUVfRU5WIiwiX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyIsImlzTmF0aXZlIiwiQ3RvciIsImhhc1N5bWJvbCIsIlN5bWJvbCIsIlJlZmxlY3QiLCJvd25LZXlzIiwiX1NldCIsIlNldCIsInNldCIsImhhcyIsImFkZCIsImNsZWFyIiwid2FybiIsInRpcCIsImdlbmVyYXRlQ29tcG9uZW50VHJhY2UiLCJmb3JtYXRDb21wb25lbnROYW1lIiwiaGFzQ29uc29sZSIsImNvbnNvbGUiLCJjbGFzc2lmeVJFIiwiY2xhc3NpZnkiLCJtc2ciLCJ2bSIsInRyYWNlIiwiZXJyb3IiLCJpbmNsdWRlRmlsZSIsIiRyb290Iiwib3B0aW9ucyIsImNpZCIsIl9pc1Z1ZSIsIiRvcHRpb25zIiwiY29uc3RydWN0b3IiLCJuYW1lIiwiX2NvbXBvbmVudFRhZyIsImZpbGUiLCJfX2ZpbGUiLCJtYXRjaCIsInJlcGVhdCIsIiRwYXJlbnQiLCJ0cmVlIiwiY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlIiwibGFzdCIsInB1c2giLCJ1aWQiLCJEZXAiLCJpZCIsInN1YnMiLCJhZGRTdWIiLCJzdWIiLCJyZW1vdmVTdWIiLCJkZXBlbmQiLCJ0YXJnZXQiLCJhZGREZXAiLCJub3RpZnkiLCJ1cGRhdGUiLCJ0YXJnZXRTdGFjayIsInB1c2hUYXJnZXQiLCJfdGFyZ2V0IiwicG9wVGFyZ2V0IiwicG9wIiwiVk5vZGUiLCJ0YWciLCJkYXRhIiwiY2hpbGRyZW4iLCJ0ZXh0IiwiZWxtIiwiY29udGV4dCIsImNvbXBvbmVudE9wdGlvbnMiLCJhc3luY0ZhY3RvcnkiLCJucyIsImZuQ29udGV4dCIsImZuT3B0aW9ucyIsImZuU2NvcGVJZCIsImNvbXBvbmVudEluc3RhbmNlIiwicGFyZW50IiwicmF3IiwiaXNTdGF0aWMiLCJpc1Jvb3RJbnNlcnQiLCJpc0NvbW1lbnQiLCJpc0Nsb25lZCIsImlzT25jZSIsImFzeW5jTWV0YSIsImlzQXN5bmNQbGFjZWhvbGRlciIsInByb3RvdHlwZUFjY2Vzc29ycyIsImNoaWxkIiwiZGVmaW5lUHJvcGVydGllcyIsImNyZWF0ZUVtcHR5Vk5vZGUiLCJub2RlIiwiY3JlYXRlVGV4dFZOb2RlIiwiY2xvbmVWTm9kZSIsInZub2RlIiwiY2xvbmVkIiwiYXJyYXlQcm90byIsImFycmF5TWV0aG9kcyIsIm1ldGhvZHNUb1BhdGNoIiwiZm9yRWFjaCIsIm1ldGhvZCIsIm9yaWdpbmFsIiwibXV0YXRvciIsImFyZ3MiLCJsZW4iLCJyZXN1bHQiLCJvYiIsIl9fb2JfXyIsImluc2VydGVkIiwib2JzZXJ2ZUFycmF5IiwiZGVwIiwiYXJyYXlLZXlzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsInNob3VsZE9ic2VydmUiLCJ0b2dnbGVPYnNlcnZpbmciLCJPYnNlcnZlciIsInZtQ291bnQiLCJhdWdtZW50IiwicHJvdG9BdWdtZW50IiwiY29weUF1Z21lbnQiLCJ3YWxrIiwiZGVmaW5lUmVhY3RpdmUiLCJpdGVtcyIsIm9ic2VydmUiLCJzcmMiLCJfX3Byb3RvX18iLCJhc1Jvb3REYXRhIiwiaXNFeHRlbnNpYmxlIiwiY3VzdG9tU2V0dGVyIiwic2hhbGxvdyIsInByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0dGVyIiwic2V0dGVyIiwiY2hpbGRPYiIsInJlYWN0aXZlR2V0dGVyIiwiZGVwZW5kQXJyYXkiLCJyZWFjdGl2ZVNldHRlciIsIm5ld1ZhbCIsIm1heCIsImRlbCIsInN0cmF0cyIsImVsIiwicHJvcHNEYXRhIiwiZGVmYXVsdFN0cmF0IiwibWVyZ2VEYXRhIiwiZnJvbSIsInRvVmFsIiwiZnJvbVZhbCIsIm1lcmdlRGF0YU9yRm4iLCJwYXJlbnRWYWwiLCJjaGlsZFZhbCIsIm1lcmdlZERhdGFGbiIsIm1lcmdlZEluc3RhbmNlRGF0YUZuIiwiaW5zdGFuY2VEYXRhIiwiZGVmYXVsdERhdGEiLCJtZXJnZUhvb2siLCJob29rIiwibWVyZ2VBc3NldHMiLCJhc3NlcnRPYmplY3RUeXBlIiwidHlwZSIsImtleSQxIiwicHJvcHMiLCJtZXRob2RzIiwiaW5qZWN0IiwiY29tcHV0ZWQiLCJwcm92aWRlIiwiY2hlY2tDb21wb25lbnRzIiwiY29tcG9uZW50cyIsInZhbGlkYXRlQ29tcG9uZW50TmFtZSIsIm5vcm1hbGl6ZVByb3BzIiwibm9ybWFsaXplSW5qZWN0Iiwibm9ybWFsaXplZCIsIm5vcm1hbGl6ZURpcmVjdGl2ZXMiLCJkaXJzIiwiZGlyZWN0aXZlcyIsIm1lcmdlT3B0aW9ucyIsImV4dGVuZHNGcm9tIiwiZXh0ZW5kcyIsIm1peGlucyIsIm1lcmdlRmllbGQiLCJzdHJhdCIsInJlc29sdmVBc3NldCIsIndhcm5NaXNzaW5nIiwiYXNzZXRzIiwiY2FtZWxpemVkSWQiLCJQYXNjYWxDYXNlSWQiLCJ2YWxpZGF0ZVByb3AiLCJwcm9wT3B0aW9ucyIsInByb3AiLCJhYnNlbnQiLCJib29sZWFuSW5kZXgiLCJnZXRUeXBlSW5kZXgiLCJCb29sZWFuIiwic3RyaW5nSW5kZXgiLCJnZXRQcm9wRGVmYXVsdFZhbHVlIiwicHJldlNob3VsZE9ic2VydmUiLCJhc3NlcnRQcm9wIiwiZGVmYXVsdCIsIl9wcm9wcyIsImdldFR5cGUiLCJyZXF1aXJlZCIsInZhbGlkIiwiZXhwZWN0ZWRUeXBlcyIsImFzc2VydGVkVHlwZSIsImFzc2VydFR5cGUiLCJleHBlY3RlZFR5cGUiLCJ2YWxpZGF0b3IiLCJzaW1wbGVDaGVja1JFIiwidCIsImlzU2FtZVR5cGUiLCJoYW5kbGVFcnJvciIsImVyciIsImluZm8iLCJjdXIiLCJob29rcyIsImVycm9yQ2FwdHVyZWQiLCJjYXB0dXJlIiwiZ2xvYmFsSGFuZGxlRXJyb3IiLCJsb2dFcnJvciIsImNhbGxiYWNrcyIsInBlbmRpbmciLCJmbHVzaENhbGxiYWNrcyIsImNvcGllcyIsIm1pY3JvVGltZXJGdW5jIiwibWFjcm9UaW1lckZ1bmMiLCJ1c2VNYWNyb1Rhc2siLCJzZXRJbW1lZGlhdGUiLCJNZXNzYWdlQ2hhbm5lbCIsImNoYW5uZWwiLCJwb3J0IiwicG9ydDIiLCJwb3J0MSIsIm9ubWVzc2FnZSIsInBvc3RNZXNzYWdlIiwic2V0VGltZW91dCIsIlByb21pc2UiLCJwIiwicmVzb2x2ZSIsInRoZW4iLCJ3aXRoTWFjcm9UYXNrIiwiX3dpdGhUYXNrIiwibmV4dFRpY2siLCJjYiIsIl9yZXNvbHZlIiwibWFyayIsIm1lYXN1cmUiLCJwZXJmIiwiY2xlYXJNYXJrcyIsImNsZWFyTWVhc3VyZXMiLCJzdGFydFRhZyIsImVuZFRhZyIsImluaXRQcm94eSIsImFsbG93ZWRHbG9iYWxzIiwid2Fybk5vblByZXNlbnQiLCJoYXNQcm94eSIsIlByb3h5IiwiaXNCdWlsdEluTW9kaWZpZXIiLCJoYXNIYW5kbGVyIiwiaXNBbGxvd2VkIiwiZ2V0SGFuZGxlciIsImhhbmRsZXJzIiwicmVuZGVyIiwiX3dpdGhTdHJpcHBlZCIsIl9yZW5kZXJQcm94eSIsInNlZW5PYmplY3RzIiwidHJhdmVyc2UiLCJfdHJhdmVyc2UiLCJzZWVuIiwiaXNBIiwiaXNGcm96ZW4iLCJkZXBJZCIsIm5vcm1hbGl6ZUV2ZW50IiwicGFzc2l2ZSIsIm9uY2UkJDEiLCJjcmVhdGVGbkludm9rZXIiLCJmbnMiLCJpbnZva2VyIiwiYXJndW1lbnRzJDEiLCJ1cGRhdGVMaXN0ZW5lcnMiLCJvbiIsIm9sZE9uIiwicmVtb3ZlJCQxIiwib2xkIiwiZXZlbnQiLCJwYXJhbXMiLCJtZXJnZVZOb2RlSG9vayIsImhvb2tLZXkiLCJvbGRIb29rIiwid3JhcHBlZEhvb2siLCJtZXJnZWQiLCJleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhIiwiYXR0cnMiLCJhbHRLZXkiLCJrZXlJbkxvd2VyQ2FzZSIsImNoZWNrUHJvcCIsImhhc2giLCJwcmVzZXJ2ZSIsInNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIiwibm9ybWFsaXplQ2hpbGRyZW4iLCJub3JtYWxpemVBcnJheUNoaWxkcmVuIiwiaXNUZXh0Tm9kZSIsIm5lc3RlZEluZGV4IiwibGFzdEluZGV4Iiwic2hpZnQiLCJfaXNWTGlzdCIsImVuc3VyZUN0b3IiLCJjb21wIiwiYmFzZSIsIl9fZXNNb2R1bGUiLCJ0b1N0cmluZ1RhZyIsImNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIiLCJyZXNvbHZlQXN5bmNDb21wb25lbnQiLCJiYXNlQ3RvciIsImVycm9yQ29tcCIsInJlc29sdmVkIiwibG9hZGluZyIsImxvYWRpbmdDb21wIiwiY29udGV4dHMiLCJzeW5jIiwiZm9yY2VSZW5kZXIiLCIkZm9yY2VVcGRhdGUiLCJyZWplY3QiLCJyZWFzb24iLCJjb21wb25lbnQiLCJkZWxheSIsInRpbWVvdXQiLCJnZXRGaXJzdENvbXBvbmVudENoaWxkIiwiaW5pdEV2ZW50cyIsIl9ldmVudHMiLCJfaGFzSG9va0V2ZW50IiwibGlzdGVuZXJzIiwiX3BhcmVudExpc3RlbmVycyIsInVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyIsIiRvbmNlIiwiJG9uIiwicmVtb3ZlJDEiLCIkb2ZmIiwib2xkTGlzdGVuZXJzIiwiZXZlbnRzTWl4aW4iLCJob29rUkUiLCJ0aGlzJDEiLCJjYnMiLCJpJDEiLCIkZW1pdCIsImxvd2VyQ2FzZUV2ZW50IiwicmVzb2x2ZVNsb3RzIiwic2xvdHMiLCJzbG90IiwibmFtZSQxIiwiaXNXaGl0ZXNwYWNlIiwicmVzb2x2ZVNjb3BlZFNsb3RzIiwiYWN0aXZlSW5zdGFuY2UiLCJpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQiLCJpbml0TGlmZWN5Y2xlIiwiYWJzdHJhY3QiLCIkY2hpbGRyZW4iLCIkcmVmcyIsIl93YXRjaGVyIiwiX2luYWN0aXZlIiwiX2RpcmVjdEluYWN0aXZlIiwiX2lzTW91bnRlZCIsIl9pc0Rlc3Ryb3llZCIsIl9pc0JlaW5nRGVzdHJveWVkIiwibGlmZWN5Y2xlTWl4aW4iLCJfdXBkYXRlIiwiaHlkcmF0aW5nIiwiY2FsbEhvb2siLCJwcmV2RWwiLCIkZWwiLCJwcmV2Vm5vZGUiLCJfdm5vZGUiLCJwcmV2QWN0aXZlSW5zdGFuY2UiLCJfX3BhdGNoX18iLCJfcGFyZW50RWxtIiwiX3JlZkVsbSIsIl9fdnVlX18iLCIkdm5vZGUiLCIkZGVzdHJveSIsInRlYXJkb3duIiwiX3dhdGNoZXJzIiwiX2RhdGEiLCJtb3VudENvbXBvbmVudCIsInRlbXBsYXRlIiwidXBkYXRlQ29tcG9uZW50IiwiX25hbWUiLCJfdWlkIiwiX3JlbmRlciIsIldhdGNoZXIiLCJ1cGRhdGVDaGlsZENvbXBvbmVudCIsInBhcmVudFZub2RlIiwicmVuZGVyQ2hpbGRyZW4iLCJoYXNDaGlsZHJlbiIsIl9yZW5kZXJDaGlsZHJlbiIsInNjb3BlZFNsb3RzIiwiJHNjb3BlZFNsb3RzIiwiX3BhcmVudFZub2RlIiwiJGF0dHJzIiwiJGxpc3RlbmVycyIsInByb3BLZXlzIiwiX3Byb3BLZXlzIiwiJHNsb3RzIiwiaXNJbkluYWN0aXZlVHJlZSIsImFjdGl2YXRlQ2hpbGRDb21wb25lbnQiLCJkaXJlY3QiLCJkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQiLCJqIiwiTUFYX1VQREFURV9DT1VOVCIsInF1ZXVlIiwiYWN0aXZhdGVkQ2hpbGRyZW4iLCJjaXJjdWxhciIsIndhaXRpbmciLCJmbHVzaGluZyIsInJlc2V0U2NoZWR1bGVyU3RhdGUiLCJmbHVzaFNjaGVkdWxlclF1ZXVlIiwid2F0Y2hlciIsInNvcnQiLCJydW4iLCJ1c2VyIiwiZXhwcmVzc2lvbiIsImFjdGl2YXRlZFF1ZXVlIiwidXBkYXRlZFF1ZXVlIiwiY2FsbEFjdGl2YXRlZEhvb2tzIiwiY2FsbFVwZGF0ZWRIb29rcyIsImVtaXQiLCJxdWV1ZUFjdGl2YXRlZENvbXBvbmVudCIsInF1ZXVlV2F0Y2hlciIsInVpZCQxIiwiZXhwT3JGbiIsImlzUmVuZGVyV2F0Y2hlciIsImRlZXAiLCJsYXp5IiwiYWN0aXZlIiwiZGlydHkiLCJkZXBzIiwibmV3RGVwcyIsImRlcElkcyIsIm5ld0RlcElkcyIsImNsZWFudXBEZXBzIiwidG1wIiwib2xkVmFsdWUiLCJldmFsdWF0ZSIsInNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbiIsInByb3h5Iiwic291cmNlS2V5IiwicHJveHlHZXR0ZXIiLCJwcm94eVNldHRlciIsImluaXRTdGF0ZSIsImluaXRQcm9wcyIsImluaXRNZXRob2RzIiwiaW5pdERhdGEiLCJpbml0Q29tcHV0ZWQiLCJpbml0V2F0Y2giLCJwcm9wc09wdGlvbnMiLCJpc1Jvb3QiLCJsb29wIiwiaHlwaGVuYXRlZEtleSIsImdldERhdGEiLCJjb21wdXRlZFdhdGNoZXJPcHRpb25zIiwid2F0Y2hlcnMiLCJfY29tcHV0ZWRXYXRjaGVycyIsImlzU1NSIiwidXNlckRlZiIsImRlZmluZUNvbXB1dGVkIiwiJGRhdGEiLCJzaG91bGRDYWNoZSIsImNyZWF0ZUNvbXB1dGVkR2V0dGVyIiwiY29tcHV0ZWRHZXR0ZXIiLCJoYW5kbGVyIiwiY3JlYXRlV2F0Y2hlciIsIiR3YXRjaCIsInN0YXRlTWl4aW4iLCJkYXRhRGVmIiwicHJvcHNEZWYiLCJuZXdEYXRhIiwiJHNldCIsIiRkZWxldGUiLCJpbW1lZGlhdGUiLCJ1bndhdGNoRm4iLCJpbml0UHJvdmlkZSIsIl9wcm92aWRlZCIsImluaXRJbmplY3Rpb25zIiwicmVzb2x2ZUluamVjdCIsImZpbHRlciIsInByb3ZpZGVLZXkiLCJzb3VyY2UiLCJwcm92aWRlRGVmYXVsdCIsInJlbmRlckxpc3QiLCJyZW5kZXJTbG90IiwiZmFsbGJhY2siLCJiaW5kT2JqZWN0Iiwic2NvcGVkU2xvdEZuIiwibm9kZXMiLCJzbG90Tm9kZXMiLCJfcmVuZGVyZWQiLCIkY3JlYXRlRWxlbWVudCIsInJlc29sdmVGaWx0ZXIiLCJpc0tleU5vdE1hdGNoIiwiZXhwZWN0IiwiYWN0dWFsIiwiY2hlY2tLZXlDb2RlcyIsImV2ZW50S2V5Q29kZSIsImJ1aWx0SW5LZXlDb2RlIiwiZXZlbnRLZXlOYW1lIiwiYnVpbHRJbktleU5hbWUiLCJtYXBwZWRLZXlDb2RlIiwiYmluZE9iamVjdFByb3BzIiwiYXNQcm9wIiwiaXNTeW5jIiwiZG9tUHJvcHMiLCIkZXZlbnQiLCJyZW5kZXJTdGF0aWMiLCJpc0luRm9yIiwiX3N0YXRpY1RyZWVzIiwic3RhdGljUmVuZGVyRm5zIiwibWFya1N0YXRpYyIsIm1hcmtPbmNlIiwibWFya1N0YXRpY05vZGUiLCJiaW5kT2JqZWN0TGlzdGVuZXJzIiwiZXhpc3RpbmciLCJvdXJzIiwiaW5zdGFsbFJlbmRlckhlbHBlcnMiLCJfbyIsIl9uIiwiX3MiLCJfbCIsIl90IiwiX3EiLCJfaSIsIl9tIiwiX2YiLCJfayIsIl9iIiwiX3YiLCJfZSIsIl91IiwiX2ciLCJGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCIsImNvbnRleHRWbSIsIl9vcmlnaW5hbCIsImlzQ29tcGlsZWQiLCJfY29tcGlsZWQiLCJuZWVkTm9ybWFsaXphdGlvbiIsImluamVjdGlvbnMiLCJfc2NvcGVJZCIsIl9jIiwiZCIsImNyZWF0ZUVsZW1lbnQiLCJjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50IiwibWVyZ2VQcm9wcyIsInJlbmRlckNvbnRleHQiLCJjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0Iiwidm5vZGVzIiwiY2xvbmUiLCJjb21wb25lbnRWTm9kZUhvb2tzIiwiaW5pdCIsInBhcmVudEVsbSIsInJlZkVsbSIsImtlZXBBbGl2ZSIsIm1vdW50ZWROb2RlIiwicHJlcGF0Y2giLCJjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlIiwiJG1vdW50Iiwib2xkVm5vZGUiLCJpbnNlcnQiLCJkZXN0cm95IiwiaG9va3NUb01lcmdlIiwiY3JlYXRlQ29tcG9uZW50IiwiX2Jhc2UiLCJyZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zIiwibW9kZWwiLCJ0cmFuc2Zvcm1Nb2RlbCIsImZ1bmN0aW9uYWwiLCJuYXRpdmVPbiIsImluc3RhbGxDb21wb25lbnRIb29rcyIsIl9pc0NvbXBvbmVudCIsImlubGluZVRlbXBsYXRlIiwiY2FsbGJhY2siLCJTSU1QTEVfTk9STUFMSVpFIiwiQUxXQVlTX05PUk1BTElaRSIsIm5vcm1hbGl6YXRpb25UeXBlIiwiYWx3YXlzTm9ybWFsaXplIiwiX2NyZWF0ZUVsZW1lbnQiLCJpcyIsImFwcGx5TlMiLCJyZWdpc3RlckRlZXBCaW5kaW5ncyIsImZvcmNlIiwic3R5bGUiLCJjbGFzcyIsImluaXRSZW5kZXIiLCJwYXJlbnREYXRhIiwicmVuZGVyTWl4aW4iLCIkbmV4dFRpY2siLCJyZWYiLCJyZW5kZXJFcnJvciIsInVpZCQzIiwiaW5pdE1peGluIiwiX2luaXQiLCJpbml0SW50ZXJuYWxDb21wb25lbnQiLCJfc2VsZiIsInZub2RlQ29tcG9uZW50T3B0aW9ucyIsInN1cGVyIiwic3VwZXJPcHRpb25zIiwiY2FjaGVkU3VwZXJPcHRpb25zIiwibW9kaWZpZWRPcHRpb25zIiwicmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyIsImV4dGVuZE9wdGlvbnMiLCJtb2RpZmllZCIsImxhdGVzdCIsImV4dGVuZGVkIiwic2VhbGVkIiwic2VhbGVkT3B0aW9ucyIsImRlZHVwZSIsImluaXRVc2UiLCJ1c2UiLCJwbHVnaW4iLCJpbnN0YWxsZWRQbHVnaW5zIiwiX2luc3RhbGxlZFBsdWdpbnMiLCJ1bnNoaWZ0IiwiaW5zdGFsbCIsImluaXRNaXhpbiQxIiwibWl4aW4iLCJpbml0RXh0ZW5kIiwiU3VwZXIiLCJTdXBlcklkIiwiY2FjaGVkQ3RvcnMiLCJfQ3RvciIsIlN1YiIsIlZ1ZUNvbXBvbmVudCIsImluaXRQcm9wcyQxIiwiaW5pdENvbXB1dGVkJDEiLCJDb21wIiwiaW5pdEFzc2V0UmVnaXN0ZXJzIiwiZGVmaW5pdGlvbiIsImdldENvbXBvbmVudE5hbWUiLCJtYXRjaGVzIiwicGF0dGVybiIsInBydW5lQ2FjaGUiLCJrZWVwQWxpdmVJbnN0YW5jZSIsImNhY2hlZE5vZGUiLCJwcnVuZUNhY2hlRW50cnkiLCJjdXJyZW50IiwiY2FjaGVkJCQxIiwicGF0dGVyblR5cGVzIiwiUmVnRXhwIiwiS2VlcEFsaXZlIiwiaW5jbHVkZSIsImV4Y2x1ZGUiLCJOdW1iZXIiLCJjcmVhdGVkIiwiZGVzdHJveWVkIiwibW91bnRlZCIsInJlZiQxIiwicGFyc2VJbnQiLCJidWlsdEluQ29tcG9uZW50cyIsImluaXRHbG9iYWxBUEkiLCJjb25maWdEZWYiLCJ1dGlsIiwiZGVsZXRlIiwic3NyQ29udGV4dCIsInZlcnNpb24iLCJhY2NlcHRWYWx1ZSIsImF0dHIiLCJpc0VudW1lcmF0ZWRBdHRyIiwiaXNCb29sZWFuQXR0ciIsInhsaW5rTlMiLCJpc1hsaW5rIiwiZ2V0WGxpbmtQcm9wIiwiaXNGYWxzeUF0dHJWYWx1ZSIsImdlbkNsYXNzRm9yVm5vZGUiLCJwYXJlbnROb2RlIiwiY2hpbGROb2RlIiwibWVyZ2VDbGFzc0RhdGEiLCJyZW5kZXJDbGFzcyIsInN0YXRpY0NsYXNzIiwiZHluYW1pY0NsYXNzIiwic3RyaW5naWZ5Q2xhc3MiLCJzdHJpbmdpZnlBcnJheSIsInN0cmluZ2lmeU9iamVjdCIsInN0cmluZ2lmaWVkIiwibmFtZXNwYWNlTWFwIiwic3ZnIiwibWF0aCIsImlzSFRNTFRhZyIsImlzU1ZHIiwiaXNQcmVUYWciLCJ1bmtub3duRWxlbWVudENhY2hlIiwiZG9jdW1lbnQiLCJIVE1MVW5rbm93bkVsZW1lbnQiLCJIVE1MRWxlbWVudCIsImlzVGV4dElucHV0VHlwZSIsInF1ZXJ5Iiwic2VsZWN0ZWQiLCJxdWVyeVNlbGVjdG9yIiwiY3JlYXRlRWxlbWVudCQxIiwidGFnTmFtZSIsIm11bHRpcGxlIiwic2V0QXR0cmlidXRlIiwiY3JlYXRlRWxlbWVudE5TIiwibmFtZXNwYWNlIiwiY3JlYXRlVGV4dE5vZGUiLCJjcmVhdGVDb21tZW50IiwiaW5zZXJ0QmVmb3JlIiwibmV3Tm9kZSIsInJlZmVyZW5jZU5vZGUiLCJyZW1vdmVDaGlsZCIsImFwcGVuZENoaWxkIiwibmV4dFNpYmxpbmciLCJzZXRUZXh0Q29udGVudCIsInRleHRDb250ZW50Iiwic2V0U3R5bGVTY29wZSIsInNjb3BlSWQiLCJub2RlT3BzIiwicmVnaXN0ZXJSZWYiLCJpc1JlbW92YWwiLCJyZWZzIiwicmVmSW5Gb3IiLCJlbXB0eU5vZGUiLCJzYW1lVm5vZGUiLCJzYW1lSW5wdXRUeXBlIiwidHlwZUEiLCJ0eXBlQiIsImNyZWF0ZUtleVRvT2xkSWR4IiwiYmVnaW5JZHgiLCJlbmRJZHgiLCJjcmVhdGVQYXRjaEZ1bmN0aW9uIiwiYmFja2VuZCIsImVtcHR5Tm9kZUF0IiwiY3JlYXRlUm1DYiIsImNoaWxkRWxtIiwicmVtb3ZlTm9kZSIsImlzVW5rbm93bkVsZW1lbnQkJDEiLCJpblZQcmUiLCJzb21lIiwiaWdub3JlIiwiY3JlYXRpbmdFbG1JblZQcmUiLCJjcmVhdGVFbG0iLCJpbnNlcnRlZFZub2RlUXVldWUiLCJuZXN0ZWQiLCJvd25lckFycmF5IiwicHJlIiwic2V0U2NvcGUiLCJjcmVhdGVDaGlsZHJlbiIsImludm9rZUNyZWF0ZUhvb2tzIiwiaXNSZWFjdGl2YXRlZCIsImluaXRDb21wb25lbnQiLCJyZWFjdGl2YXRlQ29tcG9uZW50IiwicGVuZGluZ0luc2VydCIsImlzUGF0Y2hhYmxlIiwiaW5uZXJOb2RlIiwidHJhbnNpdGlvbiIsImFjdGl2YXRlIiwicmVmJCQxIiwiY2hlY2tEdXBsaWNhdGVLZXlzIiwiYW5jZXN0b3IiLCJhZGRWbm9kZXMiLCJzdGFydElkeCIsImludm9rZURlc3Ryb3lIb29rIiwicmVtb3ZlVm5vZGVzIiwiY2giLCJyZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rIiwicm0iLCJ1cGRhdGVDaGlsZHJlbiIsIm9sZENoIiwibmV3Q2giLCJyZW1vdmVPbmx5Iiwib2xkU3RhcnRJZHgiLCJuZXdTdGFydElkeCIsIm9sZEVuZElkeCIsIm9sZFN0YXJ0Vm5vZGUiLCJvbGRFbmRWbm9kZSIsIm5ld0VuZElkeCIsIm5ld1N0YXJ0Vm5vZGUiLCJuZXdFbmRWbm9kZSIsIm9sZEtleVRvSWR4IiwiaWR4SW5PbGQiLCJ2bm9kZVRvTW92ZSIsImNhbk1vdmUiLCJwYXRjaFZub2RlIiwiZmluZElkeEluT2xkIiwic2VlbktleXMiLCJlbmQiLCJoeWRyYXRlIiwicG9zdHBhdGNoIiwiaW52b2tlSW5zZXJ0SG9vayIsImluaXRpYWwiLCJoeWRyYXRpb25CYWlsZWQiLCJpc1JlbmRlcmVkTW9kdWxlIiwiYXNzZXJ0Tm9kZU1hdGNoIiwiaGFzQ2hpbGROb2RlcyIsImlubmVySFRNTCIsImNoaWxkcmVuTWF0Y2giLCJmaXJzdENoaWxkIiwiY2hpbGROb2RlcyIsImZ1bGxJbnZva2UiLCJub2RlVHlwZSIsInBhdGNoIiwiaXNJbml0aWFsUGF0Y2giLCJpc1JlYWxFbGVtZW50IiwiaGFzQXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwib2xkRWxtIiwicGFyZW50RWxtJDEiLCJfbGVhdmVDYiIsInBhdGNoYWJsZSIsImkkMiIsInVwZGF0ZURpcmVjdGl2ZXMiLCJ1bmJpbmREaXJlY3RpdmVzIiwiaXNDcmVhdGUiLCJpc0Rlc3Ryb3kiLCJvbGREaXJzIiwibm9ybWFsaXplRGlyZWN0aXZlcyQxIiwibmV3RGlycyIsImRpcnNXaXRoSW5zZXJ0IiwiZGlyc1dpdGhQb3N0cGF0Y2giLCJvbGREaXIiLCJkaXIiLCJjYWxsSG9vayQxIiwiY29tcG9uZW50VXBkYXRlZCIsImNhbGxJbnNlcnQiLCJlbXB0eU1vZGlmaWVycyIsIm1vZGlmaWVycyIsImdldFJhd0Rpck5hbWUiLCJyYXdOYW1lIiwiYmFzZU1vZHVsZXMiLCJ1cGRhdGVBdHRycyIsImluaGVyaXRBdHRycyIsIm9sZEF0dHJzIiwic2V0QXR0ciIsInJlbW92ZUF0dHJpYnV0ZU5TIiwiYmFzZVNldEF0dHIiLCJzZXRBdHRyaWJ1dGVOUyIsIl9faWVwaCIsImJsb2NrZXIiLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJyZW1vdmVFdmVudExpc3RlbmVyIiwidXBkYXRlQ2xhc3MiLCJvbGREYXRhIiwiY2xzIiwidHJhbnNpdGlvbkNsYXNzIiwiX3RyYW5zaXRpb25DbGFzc2VzIiwiX3ByZXZDbGFzcyIsImtsYXNzIiwidmFsaWREaXZpc2lvbkNoYXJSRSIsInBhcnNlRmlsdGVycyIsImV4cCIsImluU2luZ2xlIiwiaW5Eb3VibGUiLCJpblRlbXBsYXRlU3RyaW5nIiwiaW5SZWdleCIsImN1cmx5Iiwic3F1YXJlIiwicGFyZW4iLCJsYXN0RmlsdGVySW5kZXgiLCJwcmV2IiwiZmlsdGVycyIsInRyaW0iLCJwdXNoRmlsdGVyIiwid3JhcEZpbHRlciIsImJhc2VXYXJuIiwicGx1Y2tNb2R1bGVGdW5jdGlvbiIsImFkZFByb3AiLCJwbGFpbiIsImFkZEF0dHIiLCJhZGRSYXdBdHRyIiwiYXR0cnNNYXAiLCJhdHRyc0xpc3QiLCJhZGREaXJlY3RpdmUiLCJhcmciLCJhZGRIYW5kbGVyIiwiaW1wb3J0YW50IiwicHJldmVudCIsInJpZ2h0IiwibWlkZGxlIiwiZXZlbnRzIiwibmF0aXZlIiwibmF0aXZlRXZlbnRzIiwibmV3SGFuZGxlciIsImdldEJpbmRpbmdBdHRyIiwiZ2V0U3RhdGljIiwiZHluYW1pY1ZhbHVlIiwiZ2V0QW5kUmVtb3ZlQXR0ciIsInN0YXRpY1ZhbHVlIiwicmVtb3ZlRnJvbU1hcCIsImdlbkNvbXBvbmVudE1vZGVsIiwibnVtYmVyIiwiYmFzZVZhbHVlRXhwcmVzc2lvbiIsInZhbHVlRXhwcmVzc2lvbiIsImFzc2lnbm1lbnQiLCJnZW5Bc3NpZ25tZW50Q29kZSIsInBhcnNlTW9kZWwiLCJjaHIiLCJpbmRleCQxIiwiZXhwcmVzc2lvblBvcyIsImV4cHJlc3Npb25FbmRQb3MiLCJsYXN0SW5kZXhPZiIsImVvZiIsIm5leHQiLCJpc1N0cmluZ1N0YXJ0IiwicGFyc2VTdHJpbmciLCJwYXJzZUJyYWNrZXQiLCJpbkJyYWNrZXQiLCJzdHJpbmdRdW90ZSIsIndhcm4kMSIsIlJBTkdFX1RPS0VOIiwiQ0hFQ0tCT1hfUkFESU9fVE9LRU4iLCJfd2FybiIsImdlblNlbGVjdCIsImdlbkNoZWNrYm94TW9kZWwiLCJnZW5SYWRpb01vZGVsIiwiZ2VuRGVmYXVsdE1vZGVsIiwidmFsdWVCaW5kaW5nIiwidHJ1ZVZhbHVlQmluZGluZyIsImZhbHNlVmFsdWVCaW5kaW5nIiwic2VsZWN0ZWRWYWwiLCJjb2RlIiwidmFsdWUkMSIsInR5cGVCaW5kaW5nIiwiYmluZGluZyIsIm5lZWRDb21wb3NpdGlvbkd1YXJkIiwibm9ybWFsaXplRXZlbnRzIiwiY2hhbmdlIiwidGFyZ2V0JDEiLCJjcmVhdGVPbmNlSGFuZGxlciIsIm9uY2VIYW5kbGVyIiwicmVtb3ZlJDIiLCJhZGQkMSIsInVwZGF0ZURPTUxpc3RlbmVycyIsInVwZGF0ZURPTVByb3BzIiwib2xkUHJvcHMiLCJfdmFsdWUiLCJzdHJDdXIiLCJzaG91bGRVcGRhdGVWYWx1ZSIsImNoZWNrVmFsIiwiY29tcG9zaW5nIiwiaXNOb3RJbkZvY3VzQW5kRGlydHkiLCJpc0RpcnR5V2l0aE1vZGlmaWVycyIsIm5vdEluRm9jdXMiLCJhY3RpdmVFbGVtZW50IiwiX3ZNb2RpZmllcnMiLCJwYXJzZVN0eWxlVGV4dCIsImNzc1RleHQiLCJsaXN0RGVsaW1pdGVyIiwicHJvcGVydHlEZWxpbWl0ZXIiLCJub3JtYWxpemVTdHlsZURhdGEiLCJub3JtYWxpemVTdHlsZUJpbmRpbmciLCJzdGF0aWNTdHlsZSIsImJpbmRpbmdTdHlsZSIsImdldFN0eWxlIiwiY2hlY2tDaGlsZCIsInN0eWxlRGF0YSIsImNzc1ZhclJFIiwiaW1wb3J0YW50UkUiLCJzZXRQcm9wIiwic2V0UHJvcGVydHkiLCJub3JtYWxpemVkTmFtZSIsIm5vcm1hbGl6ZSIsInZlbmRvck5hbWVzIiwiZW1wdHlTdHlsZSIsImNhcE5hbWUiLCJ1cGRhdGVTdHlsZSIsIm9sZFN0YXRpY1N0eWxlIiwib2xkU3R5bGVCaW5kaW5nIiwibm9ybWFsaXplZFN0eWxlIiwib2xkU3R5bGUiLCJuZXdTdHlsZSIsImFkZENsYXNzIiwiY2xhc3NMaXN0IiwiZ2V0QXR0cmlidXRlIiwicmVtb3ZlQ2xhc3MiLCJ0YXIiLCJyZXNvbHZlVHJhbnNpdGlvbiIsImNzcyIsImF1dG9Dc3NUcmFuc2l0aW9uIiwiZW50ZXJDbGFzcyIsImVudGVyVG9DbGFzcyIsImVudGVyQWN0aXZlQ2xhc3MiLCJsZWF2ZUNsYXNzIiwibGVhdmVUb0NsYXNzIiwibGVhdmVBY3RpdmVDbGFzcyIsImhhc1RyYW5zaXRpb24iLCJUUkFOU0lUSU9OIiwiQU5JTUFUSU9OIiwidHJhbnNpdGlvblByb3AiLCJ0cmFuc2l0aW9uRW5kRXZlbnQiLCJhbmltYXRpb25Qcm9wIiwiYW5pbWF0aW9uRW5kRXZlbnQiLCJvbnRyYW5zaXRpb25lbmQiLCJvbndlYmtpdHRyYW5zaXRpb25lbmQiLCJvbmFuaW1hdGlvbmVuZCIsIm9ud2Via2l0YW5pbWF0aW9uZW5kIiwicmFmIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibmV4dEZyYW1lIiwiYWRkVHJhbnNpdGlvbkNsYXNzIiwidHJhbnNpdGlvbkNsYXNzZXMiLCJyZW1vdmVUcmFuc2l0aW9uQ2xhc3MiLCJ3aGVuVHJhbnNpdGlvbkVuZHMiLCJnZXRUcmFuc2l0aW9uSW5mbyIsInByb3BDb3VudCIsImVuZGVkIiwib25FbmQiLCJ0cmFuc2Zvcm1SRSIsInN0eWxlcyIsImdldENvbXB1dGVkU3R5bGUiLCJ0cmFuc2l0aW9uRGVsYXlzIiwidHJhbnNpdGlvbkR1cmF0aW9ucyIsInRyYW5zaXRpb25UaW1lb3V0IiwiZ2V0VGltZW91dCIsImFuaW1hdGlvbkRlbGF5cyIsImFuaW1hdGlvbkR1cmF0aW9ucyIsImFuaW1hdGlvblRpbWVvdXQiLCJoYXNUcmFuc2Zvcm0iLCJkZWxheXMiLCJkdXJhdGlvbnMiLCJ0b01zIiwicyIsImVudGVyIiwidG9nZ2xlRGlzcGxheSIsImNhbmNlbGxlZCIsIl9lbnRlckNiIiwiYXBwZWFyQ2xhc3MiLCJhcHBlYXJUb0NsYXNzIiwiYXBwZWFyQWN0aXZlQ2xhc3MiLCJiZWZvcmVFbnRlciIsImFmdGVyRW50ZXIiLCJlbnRlckNhbmNlbGxlZCIsImJlZm9yZUFwcGVhciIsImFwcGVhciIsImFmdGVyQXBwZWFyIiwiYXBwZWFyQ2FuY2VsbGVkIiwiZHVyYXRpb24iLCJ0cmFuc2l0aW9uTm9kZSIsImlzQXBwZWFyIiwic3RhcnRDbGFzcyIsImFjdGl2ZUNsYXNzIiwidG9DbGFzcyIsImJlZm9yZUVudGVySG9vayIsImVudGVySG9vayIsImFmdGVyRW50ZXJIb29rIiwiZW50ZXJDYW5jZWxsZWRIb29rIiwiZXhwbGljaXRFbnRlckR1cmF0aW9uIiwiY2hlY2tEdXJhdGlvbiIsImV4cGVjdHNDU1MiLCJ1c2VyV2FudHNDb250cm9sIiwiZ2V0SG9va0FyZ3VtZW50c0xlbmd0aCIsInNob3ciLCJwZW5kaW5nTm9kZSIsIl9wZW5kaW5nIiwiaXNWYWxpZER1cmF0aW9uIiwibGVhdmUiLCJiZWZvcmVMZWF2ZSIsImFmdGVyTGVhdmUiLCJsZWF2ZUNhbmNlbGxlZCIsImRlbGF5TGVhdmUiLCJleHBsaWNpdExlYXZlRHVyYXRpb24iLCJwZXJmb3JtTGVhdmUiLCJpbnZva2VyRm5zIiwiX2VudGVyIiwicGxhdGZvcm1Nb2R1bGVzIiwidm1vZGVsIiwidHJpZ2dlciIsImRpcmVjdGl2ZSIsIl92T3B0aW9ucyIsInNldFNlbGVjdGVkIiwiZ2V0VmFsdWUiLCJvbkNvbXBvc2l0aW9uU3RhcnQiLCJvbkNvbXBvc2l0aW9uRW5kIiwicHJldk9wdGlvbnMiLCJjdXJPcHRpb25zIiwibyIsIm5lZWRSZXNldCIsImhhc05vTWF0Y2hpbmdPcHRpb24iLCJhY3R1YWxseVNldFNlbGVjdGVkIiwiaXNNdWx0aXBsZSIsIm9wdGlvbiIsInNlbGVjdGVkSW5kZXgiLCJjcmVhdGVFdmVudCIsImluaXRFdmVudCIsImRpc3BhdGNoRXZlbnQiLCJsb2NhdGVOb2RlIiwidHJhbnNpdGlvbiQkMSIsIm9yaWdpbmFsRGlzcGxheSIsIl9fdk9yaWdpbmFsRGlzcGxheSIsImRpc3BsYXkiLCJ1bmJpbmQiLCJwbGF0Zm9ybURpcmVjdGl2ZXMiLCJ0cmFuc2l0aW9uUHJvcHMiLCJtb2RlIiwiZ2V0UmVhbENoaWxkIiwiY29tcE9wdGlvbnMiLCJleHRyYWN0VHJhbnNpdGlvbkRhdGEiLCJwbGFjZWhvbGRlciIsImgiLCJyYXdDaGlsZCIsImhhc1BhcmVudFRyYW5zaXRpb24iLCJpc1NhbWVDaGlsZCIsIm9sZENoaWxkIiwiVHJhbnNpdGlvbiIsIl9sZWF2aW5nIiwib2xkUmF3Q2hpbGQiLCJkZWxheWVkTGVhdmUiLCJtb3ZlQ2xhc3MiLCJUcmFuc2l0aW9uR3JvdXAiLCJwcmV2Q2hpbGRyZW4iLCJyYXdDaGlsZHJlbiIsInRyYW5zaXRpb25EYXRhIiwia2VwdCIsInJlbW92ZWQiLCJjJDEiLCJwb3MiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJiZWZvcmVVcGRhdGUiLCJ1cGRhdGVkIiwiaGFzTW92ZSIsImNhbGxQZW5kaW5nQ2JzIiwicmVjb3JkUG9zaXRpb24iLCJhcHBseVRyYW5zbGF0aW9uIiwiX3JlZmxvdyIsImJvZHkiLCJvZmZzZXRIZWlnaHQiLCJtb3ZlZCIsInRyYW5zZm9ybSIsIldlYmtpdFRyYW5zZm9ybSIsInRyYW5zaXRpb25EdXJhdGlvbiIsIl9tb3ZlQ2IiLCJwcm9wZXJ0eU5hbWUiLCJfaGFzTW92ZSIsImNsb25lTm9kZSIsIm5ld1BvcyIsIm9sZFBvcyIsImR4IiwibGVmdCIsImR5IiwidG9wIiwicGxhdGZvcm1Db21wb25lbnRzIiwiZGVmYXVsdFRhZ1JFIiwicmVnZXhFc2NhcGVSRSIsImJ1aWxkUmVnZXgiLCJkZWxpbWl0ZXJzIiwib3BlbiIsImNsb3NlIiwicGFyc2VUZXh0IiwidGFnUkUiLCJ0b2tlbnMiLCJyYXdUb2tlbnMiLCJ0b2tlblZhbHVlIiwiZXhlYyIsInRyYW5zZm9ybU5vZGUiLCJjbGFzc0JpbmRpbmciLCJnZW5EYXRhIiwia2xhc3MkMSIsInRyYW5zZm9ybU5vZGUkMSIsInN0eWxlQmluZGluZyIsImdlbkRhdGEkMSIsInN0eWxlJDEiLCJkZWNvZGVyIiwiaGUiLCJkZWNvZGUiLCJodG1sIiwiaXNVbmFyeVRhZyIsImNhbkJlTGVmdE9wZW5UYWciLCJpc05vblBocmFzaW5nVGFnIiwiYXR0cmlidXRlIiwibmNuYW1lIiwicW5hbWVDYXB0dXJlIiwic3RhcnRUYWdPcGVuIiwic3RhcnRUYWdDbG9zZSIsImRvY3R5cGUiLCJjb21tZW50IiwiY29uZGl0aW9uYWxDb21tZW50IiwiSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiIsImciLCJpc1BsYWluVGV4dEVsZW1lbnQiLCJyZUNhY2hlIiwiZGVjb2RpbmdNYXAiLCJlbmNvZGVkQXR0ciIsImVuY29kZWRBdHRyV2l0aE5ld0xpbmVzIiwiaXNJZ25vcmVOZXdsaW5lVGFnIiwic2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lIiwiZGVjb2RlQXR0ciIsInNob3VsZERlY29kZU5ld2xpbmVzIiwicmUiLCJwYXJzZUhUTUwiLCJzdGFjayIsImV4cGVjdEhUTUwiLCJpc1VuYXJ5VGFnJCQxIiwiY2FuQmVMZWZ0T3BlblRhZyQkMSIsImxhc3RUYWciLCJ0ZXh0RW5kIiwiY29tbWVudEVuZCIsInNob3VsZEtlZXBDb21tZW50Iiwic3Vic3RyaW5nIiwiYWR2YW5jZSIsImNvbmRpdGlvbmFsRW5kIiwiZG9jdHlwZU1hdGNoIiwiZW5kVGFnTWF0Y2giLCJjdXJJbmRleCIsInBhcnNlRW5kVGFnIiwic3RhcnRUYWdNYXRjaCIsInBhcnNlU3RhcnRUYWciLCJoYW5kbGVTdGFydFRhZyIsInJlc3QiLCJjaGFycyIsImVuZFRhZ0xlbmd0aCIsInN0YWNrZWRUYWciLCJyZVN0YWNrZWRUYWciLCJyZXN0JDEiLCJhbGwiLCJ1bmFyeVNsYXNoIiwidW5hcnkiLCJzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYiLCJsb3dlckNhc2VkVGFnIiwibG93ZXJDYXNlZFRhZ05hbWUiLCJvblJFIiwiZGlyUkUiLCJmb3JBbGlhc1JFIiwiZm9ySXRlcmF0b3JSRSIsInN0cmlwUGFyZW5zUkUiLCJhcmdSRSIsImJpbmRSRSIsIm1vZGlmaWVyUkUiLCJkZWNvZGVIVE1MQ2FjaGVkIiwid2FybiQyIiwidHJhbnNmb3JtcyIsInByZVRyYW5zZm9ybXMiLCJwb3N0VHJhbnNmb3JtcyIsInBsYXRmb3JtSXNQcmVUYWciLCJwbGF0Zm9ybU11c3RVc2VQcm9wIiwicGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UiLCJjcmVhdGVBU1RFbGVtZW50IiwibWFrZUF0dHJzTWFwIiwicGFyc2UiLCJwcmVzZXJ2ZVdoaXRlc3BhY2UiLCJyb290IiwiY3VycmVudFBhcmVudCIsImluUHJlIiwid2FybmVkIiwid2Fybk9uY2UiLCJjbG9zZUVsZW1lbnQiLCJlbGVtZW50IiwiY29tbWVudHMiLCJndWFyZElFU1ZHQnVnIiwiaXNGb3JiaWRkZW5UYWciLCJmb3JiaWRkZW4iLCJwcm9jZXNzUHJlIiwicHJvY2Vzc1Jhd0F0dHJzIiwicHJvY2Vzc2VkIiwicHJvY2Vzc0ZvciIsInByb2Nlc3NJZiIsInByb2Nlc3NPbmNlIiwicHJvY2Vzc0VsZW1lbnQiLCJjaGVja1Jvb3RDb25zdHJhaW50cyIsImlmIiwiZWxzZWlmIiwiZWxzZSIsImFkZElmQ29uZGl0aW9uIiwiYmxvY2siLCJwcm9jZXNzSWZDb25kaXRpb25zIiwic2xvdFNjb3BlIiwic2xvdFRhcmdldCIsImxhc3ROb2RlIiwiaXNUZXh0VGFnIiwicHJvY2Vzc0tleSIsInByb2Nlc3NSZWYiLCJwcm9jZXNzU2xvdCIsInByb2Nlc3NDb21wb25lbnQiLCJwcm9jZXNzQXR0cnMiLCJjaGVja0luRm9yIiwicGFyc2VGb3IiLCJpbk1hdGNoIiwiZm9yIiwiYWxpYXMiLCJpdGVyYXRvck1hdGNoIiwiaXRlcmF0b3IxIiwiaXRlcmF0b3IyIiwiZmluZFByZXZFbGVtZW50IiwiY29uZGl0aW9uIiwiaWZDb25kaXRpb25zIiwic2xvdE5hbWUiLCJpc1Byb3AiLCJoYXNCaW5kaW5ncyIsInBhcnNlTW9kaWZpZXJzIiwiY2FtZWwiLCJhcmdNYXRjaCIsImNoZWNrRm9yQWxpYXNNb2RlbCIsImllTlNCdWciLCJpZU5TUHJlZml4IiwiX2VsIiwicHJlVHJhbnNmb3JtTm9kZSIsImlmQ29uZGl0aW9uIiwiaWZDb25kaXRpb25FeHRyYSIsImhhc0Vsc2UiLCJlbHNlSWZDb25kaXRpb24iLCJicmFuY2gwIiwiY2xvbmVBU1RFbGVtZW50IiwiYnJhbmNoMSIsImJyYW5jaDIiLCJtb2RlbCQyIiwibW9kdWxlcyQxIiwiZGlyZWN0aXZlcyQxIiwiYmFzZU9wdGlvbnMiLCJpc1N0YXRpY0tleSIsImlzUGxhdGZvcm1SZXNlcnZlZFRhZyIsImdlblN0YXRpY0tleXNDYWNoZWQiLCJnZW5TdGF0aWNLZXlzJDEiLCJvcHRpbWl6ZSIsIm1hcmtTdGF0aWMkMSIsIm1hcmtTdGF0aWNSb290cyIsInN0YXRpYyIsImwkMSIsInN0YXRpY0luRm9yIiwic3RhdGljUm9vdCIsImlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yIiwiZm5FeHBSRSIsInNpbXBsZVBhdGhSRSIsImVzYyIsInRhYiIsInNwYWNlIiwidXAiLCJkb3duIiwia2V5TmFtZXMiLCJnZW5HdWFyZCIsIm1vZGlmaWVyQ29kZSIsInN0b3AiLCJzZWxmIiwiY3RybCIsImFsdCIsIm1ldGEiLCJnZW5IYW5kbGVycyIsImdlbkhhbmRsZXIiLCJpc01ldGhvZFBhdGgiLCJpc0Z1bmN0aW9uRXhwcmVzc2lvbiIsImdlbk1vZGlmaWVyQ29kZSIsImtleU1vZGlmaWVyIiwiZ2VuS2V5RmlsdGVyIiwiaGFuZGxlckNvZGUiLCJnZW5GaWx0ZXJDb2RlIiwia2V5VmFsIiwia2V5Q29kZSIsImtleU5hbWUiLCJ3cmFwTGlzdGVuZXJzIiwiYmluZCQxIiwid3JhcERhdGEiLCJiYXNlRGlyZWN0aXZlcyIsImNsb2FrIiwiQ29kZWdlblN0YXRlIiwiZGF0YUdlbkZucyIsIm1heWJlQ29tcG9uZW50Iiwib25jZUlkIiwiZ2VuZXJhdGUiLCJhc3QiLCJzdGF0ZSIsImdlbkVsZW1lbnQiLCJzdGF0aWNQcm9jZXNzZWQiLCJnZW5TdGF0aWMiLCJvbmNlUHJvY2Vzc2VkIiwiZ2VuT25jZSIsImZvclByb2Nlc3NlZCIsImdlbkZvciIsImlmUHJvY2Vzc2VkIiwiZ2VuSWYiLCJnZW5DaGlsZHJlbiIsImdlblNsb3QiLCJnZW5Db21wb25lbnQiLCJnZW5EYXRhJDIiLCJhbHRHZW4iLCJhbHRFbXB0eSIsImdlbklmQ29uZGl0aW9ucyIsImNvbmRpdGlvbnMiLCJnZW5UZXJuYXJ5RXhwIiwiYWx0SGVscGVyIiwiZ2VuRGlyZWN0aXZlcyIsImdlblByb3BzIiwiZ2VuU2NvcGVkU2xvdHMiLCJnZW5JbmxpbmVUZW1wbGF0ZSIsImhhc1J1bnRpbWUiLCJuZWVkUnVudGltZSIsImdlbiIsImlubGluZVJlbmRlckZucyIsImdlblNjb3BlZFNsb3QiLCJnZW5Gb3JTY29wZWRTbG90IiwiY2hlY2tTa2lwIiwiYWx0R2VuRWxlbWVudCIsImFsdEdlbk5vZGUiLCJlbCQxIiwiZ2V0Tm9ybWFsaXphdGlvblR5cGUiLCJnZW5Ob2RlIiwibmVlZHNOb3JtYWxpemF0aW9uIiwiZ2VuQ29tbWVudCIsImdlblRleHQiLCJ0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMiLCJiaW5kJCQxIiwiY29tcG9uZW50TmFtZSIsInByb2hpYml0ZWRLZXl3b3JkUkUiLCJ1bmFyeU9wZXJhdG9yc1JFIiwic3RyaXBTdHJpbmdSRSIsImRldGVjdEVycm9ycyIsImVycm9ycyIsImNoZWNrTm9kZSIsImNoZWNrRm9yIiwiY2hlY2tFdmVudCIsImNoZWNrRXhwcmVzc2lvbiIsInN0aXBwZWQiLCJrZXl3b3JkTWF0Y2giLCJjaGVja0lkZW50aWZpZXIiLCJpZGVudCIsIm1lc3NhZ2UiLCJjcmVhdGVGdW5jdGlvbiIsImNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4iLCJjb21waWxlIiwiY29tcGlsZVRvRnVuY3Rpb25zIiwid2FybiQkMSIsImNvbXBpbGVkIiwidGlwcyIsImZuR2VuRXJyb3JzIiwiY3JlYXRlQ29tcGlsZXJDcmVhdG9yIiwiYmFzZUNvbXBpbGUiLCJjcmVhdGVDb21waWxlciIsImZpbmFsT3B0aW9ucyIsImRpdiIsImdldFNob3VsZERlY29kZSIsImhyZWYiLCJpZFRvVGVtcGxhdGUiLCJtb3VudCIsImRvY3VtZW50RWxlbWVudCIsImdldE91dGVySFRNTCIsIm91dGVySFRNTCIsImNvbnRhaW5lciIsInByb2Nlc3MiLCJjYWNoZWRTZXRUaW1lb3V0IiwiY2FjaGVkQ2xlYXJUaW1lb3V0IiwiZGVmYXVsdFNldFRpbW91dCIsIkVycm9yIiwiZGVmYXVsdENsZWFyVGltZW91dCIsImNsZWFyVGltZW91dCIsInJ1blRpbWVvdXQiLCJmdW4iLCJydW5DbGVhclRpbWVvdXQiLCJtYXJrZXIiLCJkcmFpbmluZyIsImN1cnJlbnRRdWV1ZSIsInF1ZXVlSW5kZXgiLCJjbGVhblVwTmV4dFRpY2siLCJkcmFpblF1ZXVlIiwiSXRlbSIsImFycmF5IiwidGl0bGUiLCJicm93c2VyIiwiYXJndiIsInZlcnNpb25zIiwiYWRkTGlzdGVuZXIiLCJvZmYiLCJyZW1vdmVMaXN0ZW5lciIsInJlbW92ZUFsbExpc3RlbmVycyIsInByZXBlbmRMaXN0ZW5lciIsInByZXBlbmRPbmNlTGlzdGVuZXIiLCJjd2QiLCJjaGRpciIsInVtYXNrIiwibmV4dEhhbmRsZSIsInRhc2tzQnlIYW5kbGUiLCJjdXJyZW50bHlSdW5uaW5nQVRhc2siLCJkb2MiLCJyZWdpc3RlckltbWVkaWF0ZSIsInRhc2siLCJjbGVhckltbWVkaWF0ZSIsImhhbmRsZSIsInJ1bklmUHJlc2VudCIsImluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uIiwiY2FuVXNlUG9zdE1lc3NhZ2UiLCJpbXBvcnRTY3JpcHRzIiwicG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyIsIm9sZE9uTWVzc2FnZSIsImluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uIiwibWVzc2FnZVByZWZpeCIsInJhbmRvbSIsIm9uR2xvYmFsTWVzc2FnZSIsImF0dGFjaEV2ZW50IiwiaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24iLCJpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uIiwic2NyaXB0Iiwib25yZWFkeXN0YXRlY2hhbmdlIiwiaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbiIsImF0dGFjaFRvIiwiZ2V0UHJvdG90eXBlT2YiLCJUaW1lb3V0Iiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwiY2xlYXJGbiIsIl9pZCIsIl9jbGVhckZuIiwidW5yZWYiLCJlbnJvbGwiLCJtc2VjcyIsIl9pZGxlVGltZW91dElkIiwiX2lkbGVUaW1lb3V0IiwidW5lbnJvbGwiLCJfdW5yZWZBY3RpdmUiLCJvblRpbWVvdXQiLCJfb25UaW1lb3V0IiwicmVxdWlyZSIsImV2YWwiXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDN0RBOzs7OztBQUtDLFdBQVVBLE1BQVYsRUFBa0JDLE9BQWxCLEVBQTJCO0FBQzNCLGtDQUFPQyxPQUFQLE9BQW1CLFFBQW5CLElBQStCLE9BQU9DLE1BQVAsS0FBa0IsV0FBakQsR0FBK0RBLE9BQU9ELE9BQVAsR0FBaUJELFNBQWhGLEdBQ0EsUUFBNkMsb0NBQU9BLE9BQVA7QUFBQTtBQUFBO0FBQUE7QUFBQSxvR0FBN0MsR0FDQ0QsT0FBT0ksR0FBUCxHQUFhSCxTQUZkO0FBR0EsQ0FKQSxFQUlDLElBSkQsRUFJUSxZQUFZO0FBQUU7O0FBRXZCOztBQUVBLE1BQUlJLGNBQWNDLE9BQU9DLE1BQVAsQ0FBYyxFQUFkLENBQWxCOztBQUVBO0FB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dGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCIvYnVpbGQvXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL2Fzc2V0cy9qcy92dWUuanNcIik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgMmI3OTA2YWZkN2FmZWU1MzA1NTEiLCIvKiFcbiAqIFZ1ZS5qcyB2Mi41LjE2XG4gKiAoYykgMjAxNC0yMDE4IEV2YW4gWW91XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcblx0KGdsb2JhbC5WdWUgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbi8qICAqL1xuXG52YXIgZW1wdHlPYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcblxuLy8gdGhlc2UgaGVscGVycyBwcm9kdWNlcyBiZXR0ZXIgdm0gY29kZSBpbiBKUyBlbmdpbmVzIGR1ZSB0byB0aGVpclxuLy8gZXhwbGljaXRuZXNzIGFuZCBmdW5jdGlvbiBpbmxpbmluZ1xuZnVuY3Rpb24gaXNVbmRlZiAodikge1xuICByZXR1cm4gdiA9PT0gdW5kZWZpbmVkIHx8IHYgPT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNEZWYgKHYpIHtcbiAgcmV0dXJuIHYgIT09IHVuZGVmaW5lZCAmJiB2ICE9PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzVHJ1ZSAodikge1xuICByZXR1cm4gdiA9PT0gdHJ1ZVxufVxuXG5mdW5jdGlvbiBpc0ZhbHNlICh2KSB7XG4gIHJldHVybiB2ID09PSBmYWxzZVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHZhbHVlIGlzIHByaW1pdGl2ZVxuICovXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZSAodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8XG4gICAgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fFxuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcgfHxcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJ1xuICApXG59XG5cbi8qKlxuICogUXVpY2sgb2JqZWN0IGNoZWNrIC0gdGhpcyBpcyBwcmltYXJpbHkgdXNlZCB0byB0ZWxsXG4gKiBPYmplY3RzIGZyb20gcHJpbWl0aXZlIHZhbHVlcyB3aGVuIHdlIGtub3cgdGhlIHZhbHVlXG4gKiBpcyBhIEpTT04tY29tcGxpYW50IHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0J1xufVxuXG4vKipcbiAqIEdldCB0aGUgcmF3IHR5cGUgc3RyaW5nIG9mIGEgdmFsdWUgZS5nLiBbb2JqZWN0IE9iamVjdF1cbiAqL1xudmFyIF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbmZ1bmN0aW9uIHRvUmF3VHlwZSAodmFsdWUpIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSlcbn1cblxuLyoqXG4gKiBTdHJpY3Qgb2JqZWN0IHR5cGUgY2hlY2suIE9ubHkgcmV0dXJucyB0cnVlXG4gKiBmb3IgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3RzLlxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nXG59XG5cbmZ1bmN0aW9uIGlzUmVnRXhwICh2KSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2KSA9PT0gJ1tvYmplY3QgUmVnRXhwXSdcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB2YWwgaXMgYSB2YWxpZCBhcnJheSBpbmRleC5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEFycmF5SW5kZXggKHZhbCkge1xuICB2YXIgbiA9IHBhcnNlRmxvYXQoU3RyaW5nKHZhbCkpO1xuICByZXR1cm4gbiA+PSAwICYmIE1hdGguZmxvb3IobikgPT09IG4gJiYgaXNGaW5pdGUodmFsKVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSB0byBhIHN0cmluZyB0aGF0IGlzIGFjdHVhbGx5IHJlbmRlcmVkLlxuICovXG5mdW5jdGlvbiB0b1N0cmluZyAodmFsKSB7XG4gIHJldHVybiB2YWwgPT0gbnVsbFxuICAgID8gJydcbiAgICA6IHR5cGVvZiB2YWwgPT09ICdvYmplY3QnXG4gICAgICA/IEpTT04uc3RyaW5naWZ5KHZhbCwgbnVsbCwgMilcbiAgICAgIDogU3RyaW5nKHZhbClcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgaW5wdXQgdmFsdWUgdG8gYSBudW1iZXIgZm9yIHBlcnNpc3RlbmNlLlxuICogSWYgdGhlIGNvbnZlcnNpb24gZmFpbHMsIHJldHVybiBvcmlnaW5hbCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyICh2YWwpIHtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KHZhbCk7XG4gIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG5cbn1cblxuLyoqXG4gKiBNYWtlIGEgbWFwIGFuZCByZXR1cm4gYSBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYSBrZXlcbiAqIGlzIGluIHRoYXQgbWFwLlxuICovXG5mdW5jdGlvbiBtYWtlTWFwIChcbiAgc3RyLFxuICBleHBlY3RzTG93ZXJDYXNlXG4pIHtcbiAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBsaXN0ID0gc3RyLnNwbGl0KCcsJyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIG1hcFtsaXN0W2ldXSA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIGV4cGVjdHNMb3dlckNhc2VcbiAgICA/IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWwudG9Mb3dlckNhc2UoKV07IH1cbiAgICA6IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWxdOyB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB0YWcgaXMgYSBidWlsdC1pbiB0YWcuXG4gKi9cbnZhciBpc0J1aWx0SW5UYWcgPSBtYWtlTWFwKCdzbG90LGNvbXBvbmVudCcsIHRydWUpO1xuXG4vKipcbiAqIENoZWNrIGlmIGEgYXR0cmlidXRlIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlLlxuICovXG52YXIgaXNSZXNlcnZlZEF0dHJpYnV0ZSA9IG1ha2VNYXAoJ2tleSxyZWYsc2xvdCxzbG90LXNjb3BlLGlzJyk7XG5cbi8qKlxuICogUmVtb3ZlIGFuIGl0ZW0gZnJvbSBhbiBhcnJheVxuICovXG5mdW5jdGlvbiByZW1vdmUgKGFyciwgaXRlbSkge1xuICBpZiAoYXJyLmxlbmd0aCkge1xuICAgIHZhciBpbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICByZXR1cm4gYXJyLnNwbGljZShpbmRleCwgMSlcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBvYmplY3QgaGFzIHRoZSBwcm9wZXJ0eS5cbiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGhhc093biAob2JqLCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgY2FjaGVkIHZlcnNpb24gb2YgYSBwdXJlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjYWNoZWQgKGZuKSB7XG4gIHZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiAoZnVuY3Rpb24gY2FjaGVkRm4gKHN0cikge1xuICAgIHZhciBoaXQgPSBjYWNoZVtzdHJdO1xuICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKVxuICB9KVxufVxuXG4vKipcbiAqIENhbWVsaXplIGEgaHlwaGVuLWRlbGltaXRlZCBzdHJpbmcuXG4gKi9cbnZhciBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xudmFyIGNhbWVsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIGZ1bmN0aW9uIChfLCBjKSB7IHJldHVybiBjID8gYy50b1VwcGVyQ2FzZSgpIDogJyc7IH0pXG59KTtcblxuLyoqXG4gKiBDYXBpdGFsaXplIGEgc3RyaW5nLlxuICovXG52YXIgY2FwaXRhbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSlcbn0pO1xuXG4vKipcbiAqIEh5cGhlbmF0ZSBhIGNhbWVsQ2FzZSBzdHJpbmcuXG4gKi9cbnZhciBoeXBoZW5hdGVSRSA9IC9cXEIoW0EtWl0pL2c7XG52YXIgaHlwaGVuYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnLSQxJykudG9Mb3dlckNhc2UoKVxufSk7XG5cbi8qKlxuICogU2ltcGxlIGJpbmQgcG9seWZpbGwgZm9yIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBzdXBwb3J0IGl0Li4uIGUuZy5cbiAqIFBoYW50b21KUyAxLnguIFRlY2huaWNhbGx5IHdlIGRvbid0IG5lZWQgdGhpcyBhbnltb3JlIHNpbmNlIG5hdGl2ZSBiaW5kIGlzXG4gKiBub3cgbW9yZSBwZXJmb3JtYW50IGluIG1vc3QgYnJvd3NlcnMsIGJ1dCByZW1vdmluZyBpdCB3b3VsZCBiZSBicmVha2luZyBmb3JcbiAqIGNvZGUgdGhhdCB3YXMgYWJsZSB0byBydW4gaW4gUGhhbnRvbUpTIDEueCwgc28gdGhpcyBtdXN0IGJlIGtlcHQgZm9yXG4gKiBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAqL1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gcG9seWZpbGxCaW5kIChmbiwgY3R4KSB7XG4gIGZ1bmN0aW9uIGJvdW5kRm4gKGEpIHtcbiAgICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgcmV0dXJuIGxcbiAgICAgID8gbCA+IDFcbiAgICAgICAgPyBmbi5hcHBseShjdHgsIGFyZ3VtZW50cylcbiAgICAgICAgOiBmbi5jYWxsKGN0eCwgYSlcbiAgICAgIDogZm4uY2FsbChjdHgpXG4gIH1cblxuICBib3VuZEZuLl9sZW5ndGggPSBmbi5sZW5ndGg7XG4gIHJldHVybiBib3VuZEZuXG59XG5cbmZ1bmN0aW9uIG5hdGl2ZUJpbmQgKGZuLCBjdHgpIHtcbiAgcmV0dXJuIGZuLmJpbmQoY3R4KVxufVxuXG52YXIgYmluZCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kXG4gID8gbmF0aXZlQmluZFxuICA6IHBvbHlmaWxsQmluZDtcblxuLyoqXG4gKiBDb252ZXJ0IGFuIEFycmF5LWxpa2Ugb2JqZWN0IHRvIGEgcmVhbCBBcnJheS5cbiAqL1xuZnVuY3Rpb24gdG9BcnJheSAobGlzdCwgc3RhcnQpIHtcbiAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICB2YXIgaSA9IGxpc3QubGVuZ3RoIC0gc3RhcnQ7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoaSk7XG4gIHdoaWxlIChpLS0pIHtcbiAgICByZXRbaV0gPSBsaXN0W2kgKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vKipcbiAqIE1peCBwcm9wZXJ0aWVzIGludG8gdGFyZ2V0IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZXh0ZW5kICh0bywgX2Zyb20pIHtcbiAgZm9yICh2YXIga2V5IGluIF9mcm9tKSB7XG4gICAgdG9ba2V5XSA9IF9mcm9tW2tleV07XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogTWVyZ2UgYW4gQXJyYXkgb2YgT2JqZWN0cyBpbnRvIGEgc2luZ2xlIE9iamVjdC5cbiAqL1xuZnVuY3Rpb24gdG9PYmplY3QgKGFycikge1xuICB2YXIgcmVzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFycltpXSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXJyW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKipcbiAqIFBlcmZvcm0gbm8gb3BlcmF0aW9uLlxuICogU3R1YmJpbmcgYXJncyB0byBtYWtlIEZsb3cgaGFwcHkgd2l0aG91dCBsZWF2aW5nIHVzZWxlc3MgdHJhbnNwaWxlZCBjb2RlXG4gKiB3aXRoIC4uLnJlc3QgKGh0dHBzOi8vZmxvdy5vcmcvYmxvZy8yMDE3LzA1LzA3L1N0cmljdC1GdW5jdGlvbi1DYWxsLUFyaXR5LylcbiAqL1xuZnVuY3Rpb24gbm9vcCAoYSwgYiwgYykge31cblxuLyoqXG4gKiBBbHdheXMgcmV0dXJuIGZhbHNlLlxuICovXG52YXIgbm8gPSBmdW5jdGlvbiAoYSwgYiwgYykgeyByZXR1cm4gZmFsc2U7IH07XG5cbi8qKlxuICogUmV0dXJuIHNhbWUgdmFsdWVcbiAqL1xudmFyIGlkZW50aXR5ID0gZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH07XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzdGF0aWMga2V5cyBzdHJpbmcgZnJvbSBjb21waWxlciBtb2R1bGVzLlxuICovXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzIChtb2R1bGVzKSB7XG4gIHJldHVybiBtb2R1bGVzLnJlZHVjZShmdW5jdGlvbiAoa2V5cywgbSkge1xuICAgIHJldHVybiBrZXlzLmNvbmNhdChtLnN0YXRpY0tleXMgfHwgW10pXG4gIH0sIFtdKS5qb2luKCcsJylcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmFsdWVzIGFyZSBsb29zZWx5IGVxdWFsIC0gdGhhdCBpcyxcbiAqIGlmIHRoZXkgYXJlIHBsYWluIG9iamVjdHMsIGRvIHRoZXkgaGF2ZSB0aGUgc2FtZSBzaGFwZT9cbiAqL1xuZnVuY3Rpb24gbG9vc2VFcXVhbCAoYSwgYikge1xuICBpZiAoYSA9PT0gYikgeyByZXR1cm4gdHJ1ZSB9XG4gIHZhciBpc09iamVjdEEgPSBpc09iamVjdChhKTtcbiAgdmFyIGlzT2JqZWN0QiA9IGlzT2JqZWN0KGIpO1xuICBpZiAoaXNPYmplY3RBICYmIGlzT2JqZWN0Qikge1xuICAgIHRyeSB7XG4gICAgICB2YXIgaXNBcnJheUEgPSBBcnJheS5pc0FycmF5KGEpO1xuICAgICAgdmFyIGlzQXJyYXlCID0gQXJyYXkuaXNBcnJheShiKTtcbiAgICAgIGlmIChpc0FycmF5QSAmJiBpc0FycmF5Qikge1xuICAgICAgICByZXR1cm4gYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGEuZXZlcnkoZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgICByZXR1cm4gbG9vc2VFcXVhbChlLCBiW2ldKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIGlmICghaXNBcnJheUEgJiYgIWlzQXJyYXlCKSB7XG4gICAgICAgIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKGEpO1xuICAgICAgICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhiKTtcbiAgICAgICAgcmV0dXJuIGtleXNBLmxlbmd0aCA9PT0ga2V5c0IubGVuZ3RoICYmIGtleXNBLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICByZXR1cm4gbG9vc2VFcXVhbChhW2tleV0sIGJba2V5XSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWlzT2JqZWN0QSAmJiAhaXNPYmplY3RCKSB7XG4gICAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24gbG9vc2VJbmRleE9mIChhcnIsIHZhbCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChsb29zZUVxdWFsKGFycltpXSwgdmFsKSkgeyByZXR1cm4gaSB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbi8qKlxuICogRW5zdXJlIGEgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgb25jZS5cbiAqL1xuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFNTUl9BVFRSID0gJ2RhdGEtc2VydmVyLXJlbmRlcmVkJztcblxudmFyIEFTU0VUX1RZUEVTID0gW1xuICAnY29tcG9uZW50JyxcbiAgJ2RpcmVjdGl2ZScsXG4gICdmaWx0ZXInXG5dO1xuXG52YXIgTElGRUNZQ0xFX0hPT0tTID0gW1xuICAnYmVmb3JlQ3JlYXRlJyxcbiAgJ2NyZWF0ZWQnLFxuICAnYmVmb3JlTW91bnQnLFxuICAnbW91bnRlZCcsXG4gICdiZWZvcmVVcGRhdGUnLFxuICAndXBkYXRlZCcsXG4gICdiZWZvcmVEZXN0cm95JyxcbiAgJ2Rlc3Ryb3llZCcsXG4gICdhY3RpdmF0ZWQnLFxuICAnZGVhY3RpdmF0ZWQnLFxuICAnZXJyb3JDYXB0dXJlZCdcbl07XG5cbi8qICAqL1xuXG52YXIgY29uZmlnID0gKHtcbiAgLyoqXG4gICAqIE9wdGlvbiBtZXJnZSBzdHJhdGVnaWVzICh1c2VkIGluIGNvcmUvdXRpbC9vcHRpb25zKVxuICAgKi9cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIG9wdGlvbk1lcmdlU3RyYXRlZ2llczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAvKipcbiAgICogV2hldGhlciB0byBzdXBwcmVzcyB3YXJuaW5ncy5cbiAgICovXG4gIHNpbGVudDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFNob3cgcHJvZHVjdGlvbiBtb2RlIHRpcCBtZXNzYWdlIG9uIGJvb3Q/XG4gICAqL1xuICBwcm9kdWN0aW9uVGlwOiBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byBlbmFibGUgZGV2dG9vbHNcbiAgICovXG4gIGRldnRvb2xzOiBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byByZWNvcmQgcGVyZlxuICAgKi9cbiAgcGVyZm9ybWFuY2U6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBFcnJvciBoYW5kbGVyIGZvciB3YXRjaGVyIGVycm9yc1xuICAgKi9cbiAgZXJyb3JIYW5kbGVyOiBudWxsLFxuXG4gIC8qKlxuICAgKiBXYXJuIGhhbmRsZXIgZm9yIHdhdGNoZXIgd2FybnNcbiAgICovXG4gIHdhcm5IYW5kbGVyOiBudWxsLFxuXG4gIC8qKlxuICAgKiBJZ25vcmUgY2VydGFpbiBjdXN0b20gZWxlbWVudHNcbiAgICovXG4gIGlnbm9yZWRFbGVtZW50czogW10sXG5cbiAgLyoqXG4gICAqIEN1c3RvbSB1c2VyIGtleSBhbGlhc2VzIGZvciB2LW9uXG4gICAqL1xuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAga2V5Q29kZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHJlZ2lzdGVyZWQgYXMgYVxuICAgKiBjb21wb25lbnQuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBpc1Jlc2VydmVkVGFnOiBubyxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHVzZWQgYXMgYSBjb21wb25lbnRcbiAgICogcHJvcC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICovXG4gIGlzUmVzZXJ2ZWRBdHRyOiBubyxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgYW4gdW5rbm93biBlbGVtZW50LlxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBpc1Vua25vd25FbGVtZW50OiBubyxcblxuICAvKipcbiAgICogR2V0IHRoZSBuYW1lc3BhY2Ugb2YgYW4gZWxlbWVudFxuICAgKi9cbiAgZ2V0VGFnTmFtZXNwYWNlOiBub29wLFxuXG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgcmVhbCB0YWcgbmFtZSBmb3IgdGhlIHNwZWNpZmljIHBsYXRmb3JtLlxuICAgKi9cbiAgcGFyc2VQbGF0Zm9ybVRhZ05hbWU6IGlkZW50aXR5LFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgbXVzdCBiZSBib3VuZCB1c2luZyBwcm9wZXJ0eSwgZS5nLiB2YWx1ZVxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBtdXN0VXNlUHJvcDogbm8sXG5cbiAgLyoqXG4gICAqIEV4cG9zZWQgZm9yIGxlZ2FjeSByZWFzb25zXG4gICAqL1xuICBfbGlmZWN5Y2xlSG9va3M6IExJRkVDWUNMRV9IT09LU1xufSlcblxuLyogICovXG5cbi8qKlxuICogQ2hlY2sgaWYgYSBzdHJpbmcgc3RhcnRzIHdpdGggJCBvciBfXG4gKi9cbmZ1bmN0aW9uIGlzUmVzZXJ2ZWQgKHN0cikge1xuICB2YXIgYyA9IChzdHIgKyAnJykuY2hhckNvZGVBdCgwKTtcbiAgcmV0dXJuIGMgPT09IDB4MjQgfHwgYyA9PT0gMHg1RlxufVxuXG4vKipcbiAqIERlZmluZSBhIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBkZWYgKG9iaiwga2V5LCB2YWwsIGVudW1lcmFibGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgdmFsdWU6IHZhbCxcbiAgICBlbnVtZXJhYmxlOiAhIWVudW1lcmFibGUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vKipcbiAqIFBhcnNlIHNpbXBsZSBwYXRoLlxuICovXG52YXIgYmFpbFJFID0gL1teXFx3LiRdLztcbmZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xuICBpZiAoYmFpbFJFLnRlc3QocGF0aCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFvYmopIHsgcmV0dXJuIH1cbiAgICAgIG9iaiA9IG9ialtzZWdtZW50c1tpXV07XG4gICAgfVxuICAgIHJldHVybiBvYmpcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gY2FuIHdlIHVzZSBfX3Byb3RvX18/XG52YXIgaGFzUHJvdG8gPSAnX19wcm90b19fJyBpbiB7fTtcblxuLy8gQnJvd3NlciBlbnZpcm9ubWVudCBzbmlmZmluZ1xudmFyIGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xudmFyIGluV2VleCA9IHR5cGVvZiBXWEVudmlyb25tZW50ICE9PSAndW5kZWZpbmVkJyAmJiAhIVdYRW52aXJvbm1lbnQucGxhdGZvcm07XG52YXIgd2VleFBsYXRmb3JtID0gaW5XZWV4ICYmIFdYRW52aXJvbm1lbnQucGxhdGZvcm0udG9Mb3dlckNhc2UoKTtcbnZhciBVQSA9IGluQnJvd3NlciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xudmFyIGlzSUUgPSBVQSAmJiAvbXNpZXx0cmlkZW50Ly50ZXN0KFVBKTtcbnZhciBpc0lFOSA9IFVBICYmIFVBLmluZGV4T2YoJ21zaWUgOS4wJykgPiAwO1xudmFyIGlzRWRnZSA9IFVBICYmIFVBLmluZGV4T2YoJ2VkZ2UvJykgPiAwO1xudmFyIGlzQW5kcm9pZCA9IChVQSAmJiBVQS5pbmRleE9mKCdhbmRyb2lkJykgPiAwKSB8fCAod2VleFBsYXRmb3JtID09PSAnYW5kcm9pZCcpO1xudmFyIGlzSU9TID0gKFVBICYmIC9pcGhvbmV8aXBhZHxpcG9kfGlvcy8udGVzdChVQSkpIHx8ICh3ZWV4UGxhdGZvcm0gPT09ICdpb3MnKTtcbnZhciBpc0Nocm9tZSA9IFVBICYmIC9jaHJvbWVcXC9cXGQrLy50ZXN0KFVBKSAmJiAhaXNFZGdlO1xuXG4vLyBGaXJlZm94IGhhcyBhIFwid2F0Y2hcIiBmdW5jdGlvbiBvbiBPYmplY3QucHJvdG90eXBlLi4uXG52YXIgbmF0aXZlV2F0Y2ggPSAoe30pLndhdGNoO1xuXG52YXIgc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XG5pZiAoaW5Ccm93c2VyKSB7XG4gIHRyeSB7XG4gICAgdmFyIG9wdHMgPSB7fTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3B0cywgJ3Bhc3NpdmUnLCAoe1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzI4NVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0LXBhc3NpdmUnLCBudWxsLCBvcHRzKTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxuLy8gdGhpcyBuZWVkcyB0byBiZSBsYXp5LWV2YWxlZCBiZWNhdXNlIHZ1ZSBtYXkgYmUgcmVxdWlyZWQgYmVmb3JlXG4vLyB2dWUtc2VydmVyLXJlbmRlcmVyIGNhbiBzZXQgVlVFX0VOVlxudmFyIF9pc1NlcnZlcjtcbnZhciBpc1NlcnZlclJlbmRlcmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKF9pc1NlcnZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFpbkJyb3dzZXIgJiYgIWluV2VleCAmJiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gZGV0ZWN0IHByZXNlbmNlIG9mIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgYW5kIGF2b2lkXG4gICAgICAvLyBXZWJwYWNrIHNoaW1taW5nIHRoZSBwcm9jZXNzXG4gICAgICBfaXNTZXJ2ZXIgPSBnbG9iYWxbJ3Byb2Nlc3MnXS5lbnYuVlVFX0VOViA9PT0gJ3NlcnZlcic7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9pc1NlcnZlciA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gX2lzU2VydmVyXG59O1xuXG4vLyBkZXRlY3QgZGV2dG9vbHNcbnZhciBkZXZ0b29scyA9IGluQnJvd3NlciAmJiB3aW5kb3cuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGlzTmF0aXZlIChDdG9yKSB7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PT0gJ2Z1bmN0aW9uJyAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoQ3Rvci50b1N0cmluZygpKVxufVxuXG52YXIgaGFzU3ltYm9sID1cbiAgdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU3ltYm9sKSAmJlxuICB0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUmVmbGVjdC5vd25LZXlzKTtcblxudmFyIF9TZXQ7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi8gLy8gJGZsb3ctZGlzYWJsZS1saW5lXG5pZiAodHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU2V0KSkge1xuICAvLyB1c2UgbmF0aXZlIFNldCB3aGVuIGF2YWlsYWJsZS5cbiAgX1NldCA9IFNldDtcbn0gZWxzZSB7XG4gIC8vIGEgbm9uLXN0YW5kYXJkIFNldCBwb2x5ZmlsbCB0aGF0IG9ubHkgd29ya3Mgd2l0aCBwcmltaXRpdmUga2V5cy5cbiAgX1NldCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2V0ICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgU2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMgKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0W2tleV0gPT09IHRydWVcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChrZXkpIHtcbiAgICAgIHRoaXMuc2V0W2tleV0gPSB0cnVlO1xuICAgIH07XG4gICAgU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNldDtcbiAgfSgpKTtcbn1cblxuLyogICovXG5cbnZhciB3YXJuID0gbm9vcDtcbnZhciB0aXAgPSBub29wO1xudmFyIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSAobm9vcCk7IC8vIHdvcmsgYXJvdW5kIGZsb3cgY2hlY2tcbnZhciBmb3JtYXRDb21wb25lbnROYW1lID0gKG5vb3ApO1xuXG57XG4gIHZhciBoYXNDb25zb2xlID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnO1xuICB2YXIgY2xhc3NpZnlSRSA9IC8oPzpefFstX10pKFxcdykvZztcbiAgdmFyIGNsYXNzaWZ5ID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gc3RyXG4gICAgLnJlcGxhY2UoY2xhc3NpZnlSRSwgZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudG9VcHBlckNhc2UoKTsgfSlcbiAgICAucmVwbGFjZSgvWy1fXS9nLCAnJyk7IH07XG5cbiAgd2FybiA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgdmFyIHRyYWNlID0gdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnO1xuXG4gICAgaWYgKGNvbmZpZy53YXJuSGFuZGxlcikge1xuICAgICAgY29uZmlnLndhcm5IYW5kbGVyLmNhbGwobnVsbCwgbXNnLCB2bSwgdHJhY2UpO1xuICAgIH0gZWxzZSBpZiAoaGFzQ29uc29sZSAmJiAoIWNvbmZpZy5zaWxlbnQpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKChcIltWdWUgd2Fybl06IFwiICsgbXNnICsgdHJhY2UpKTtcbiAgICB9XG4gIH07XG5cbiAgdGlwID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcbiAgICBpZiAoaGFzQ29uc29sZSAmJiAoIWNvbmZpZy5zaWxlbnQpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJbVnVlIHRpcF06IFwiICsgbXNnICsgKFxuICAgICAgICB2bSA/IGdlbmVyYXRlQ29tcG9uZW50VHJhY2Uodm0pIDogJydcbiAgICAgICkpO1xuICAgIH1cbiAgfTtcblxuICBmb3JtYXRDb21wb25lbnROYW1lID0gZnVuY3Rpb24gKHZtLCBpbmNsdWRlRmlsZSkge1xuICAgIGlmICh2bS4kcm9vdCA9PT0gdm0pIHtcbiAgICAgIHJldHVybiAnPFJvb3Q+J1xuICAgIH1cbiAgICB2YXIgb3B0aW9ucyA9IHR5cGVvZiB2bSA9PT0gJ2Z1bmN0aW9uJyAmJiB2bS5jaWQgIT0gbnVsbFxuICAgICAgPyB2bS5vcHRpb25zXG4gICAgICA6IHZtLl9pc1Z1ZVxuICAgICAgICA/IHZtLiRvcHRpb25zIHx8IHZtLmNvbnN0cnVjdG9yLm9wdGlvbnNcbiAgICAgICAgOiB2bSB8fCB7fTtcbiAgICB2YXIgbmFtZSA9IG9wdGlvbnMubmFtZSB8fCBvcHRpb25zLl9jb21wb25lbnRUYWc7XG4gICAgdmFyIGZpbGUgPSBvcHRpb25zLl9fZmlsZTtcbiAgICBpZiAoIW5hbWUgJiYgZmlsZSkge1xuICAgICAgdmFyIG1hdGNoID0gZmlsZS5tYXRjaCgvKFteL1xcXFxdKylcXC52dWUkLyk7XG4gICAgICBuYW1lID0gbWF0Y2ggJiYgbWF0Y2hbMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIChuYW1lID8gKFwiPFwiICsgKGNsYXNzaWZ5KG5hbWUpKSArIFwiPlwiKSA6IFwiPEFub255bW91cz5cIikgK1xuICAgICAgKGZpbGUgJiYgaW5jbHVkZUZpbGUgIT09IGZhbHNlID8gKFwiIGF0IFwiICsgZmlsZSkgOiAnJylcbiAgICApXG4gIH07XG5cbiAgdmFyIHJlcGVhdCA9IGZ1bmN0aW9uIChzdHIsIG4pIHtcbiAgICB2YXIgcmVzID0gJyc7XG4gICAgd2hpbGUgKG4pIHtcbiAgICAgIGlmIChuICUgMiA9PT0gMSkgeyByZXMgKz0gc3RyOyB9XG4gICAgICBpZiAobiA+IDEpIHsgc3RyICs9IHN0cjsgfVxuICAgICAgbiA+Pj0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9O1xuXG4gIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSBmdW5jdGlvbiAodm0pIHtcbiAgICBpZiAodm0uX2lzVnVlICYmIHZtLiRwYXJlbnQpIHtcbiAgICAgIHZhciB0cmVlID0gW107XG4gICAgICB2YXIgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcbiAgICAgIHdoaWxlICh2bSkge1xuICAgICAgICBpZiAodHJlZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIGxhc3QgPSB0cmVlW3RyZWUubGVuZ3RoIC0gMV07XG4gICAgICAgICAgaWYgKGxhc3QuY29uc3RydWN0b3IgPT09IHZtLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UrKztcbiAgICAgICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPiAwKSB7XG4gICAgICAgICAgICB0cmVlW3RyZWUubGVuZ3RoIC0gMV0gPSBbbGFzdCwgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlXTtcbiAgICAgICAgICAgIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRyZWUucHVzaCh2bSk7XG4gICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnXFxuXFxuZm91bmQgaW5cXG5cXG4nICsgdHJlZVxuICAgICAgICAubWFwKGZ1bmN0aW9uICh2bSwgaSkgeyByZXR1cm4gKFwiXCIgKyAoaSA9PT0gMCA/ICctLS0+ICcgOiByZXBlYXQoJyAnLCA1ICsgaSAqIDIpKSArIChBcnJheS5pc0FycmF5KHZtKVxuICAgICAgICAgICAgPyAoKGZvcm1hdENvbXBvbmVudE5hbWUodm1bMF0pKSArIFwiLi4uIChcIiArICh2bVsxXSkgKyBcIiByZWN1cnNpdmUgY2FsbHMpXCIpXG4gICAgICAgICAgICA6IGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSk7IH0pXG4gICAgICAgIC5qb2luKCdcXG4nKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKFwiXFxuXFxuKGZvdW5kIGluIFwiICsgKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSArIFwiKVwiKVxuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cblxudmFyIHVpZCA9IDA7XG5cbi8qKlxuICogQSBkZXAgaXMgYW4gb2JzZXJ2YWJsZSB0aGF0IGNhbiBoYXZlIG11bHRpcGxlXG4gKiBkaXJlY3RpdmVzIHN1YnNjcmliaW5nIHRvIGl0LlxuICovXG52YXIgRGVwID0gZnVuY3Rpb24gRGVwICgpIHtcbiAgdGhpcy5pZCA9IHVpZCsrO1xuICB0aGlzLnN1YnMgPSBbXTtcbn07XG5cbkRlcC5wcm90b3R5cGUuYWRkU3ViID0gZnVuY3Rpb24gYWRkU3ViIChzdWIpIHtcbiAgdGhpcy5zdWJzLnB1c2goc3ViKTtcbn07XG5cbkRlcC5wcm90b3R5cGUucmVtb3ZlU3ViID0gZnVuY3Rpb24gcmVtb3ZlU3ViIChzdWIpIHtcbiAgcmVtb3ZlKHRoaXMuc3Vicywgc3ViKTtcbn07XG5cbkRlcC5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcbiAgaWYgKERlcC50YXJnZXQpIHtcbiAgICBEZXAudGFyZ2V0LmFkZERlcCh0aGlzKTtcbiAgfVxufTtcblxuRGVwLnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbiBub3RpZnkgKCkge1xuICAvLyBzdGFiaWxpemUgdGhlIHN1YnNjcmliZXIgbGlzdCBmaXJzdFxuICB2YXIgc3VicyA9IHRoaXMuc3Vicy5zbGljZSgpO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHN1YnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgc3Vic1tpXS51cGRhdGUoKTtcbiAgfVxufTtcblxuLy8gdGhlIGN1cnJlbnQgdGFyZ2V0IHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkLlxuLy8gdGhpcyBpcyBnbG9iYWxseSB1bmlxdWUgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvbmx5IG9uZVxuLy8gd2F0Y2hlciBiZWluZyBldmFsdWF0ZWQgYXQgYW55IHRpbWUuXG5EZXAudGFyZ2V0ID0gbnVsbDtcbnZhciB0YXJnZXRTdGFjayA9IFtdO1xuXG5mdW5jdGlvbiBwdXNoVGFyZ2V0IChfdGFyZ2V0KSB7XG4gIGlmIChEZXAudGFyZ2V0KSB7IHRhcmdldFN0YWNrLnB1c2goRGVwLnRhcmdldCk7IH1cbiAgRGVwLnRhcmdldCA9IF90YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIHBvcFRhcmdldCAoKSB7XG4gIERlcC50YXJnZXQgPSB0YXJnZXRTdGFjay5wb3AoKTtcbn1cblxuLyogICovXG5cbnZhciBWTm9kZSA9IGZ1bmN0aW9uIFZOb2RlIChcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgdGV4dCxcbiAgZWxtLFxuICBjb250ZXh0LFxuICBjb21wb25lbnRPcHRpb25zLFxuICBhc3luY0ZhY3Rvcnlcbikge1xuICB0aGlzLnRhZyA9IHRhZztcbiAgdGhpcy5kYXRhID0gZGF0YTtcbiAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB0aGlzLnRleHQgPSB0ZXh0O1xuICB0aGlzLmVsbSA9IGVsbTtcbiAgdGhpcy5ucyA9IHVuZGVmaW5lZDtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5mbkNvbnRleHQgPSB1bmRlZmluZWQ7XG4gIHRoaXMuZm5PcHRpb25zID0gdW5kZWZpbmVkO1xuICB0aGlzLmZuU2NvcGVJZCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5rZXkgPSBkYXRhICYmIGRhdGEua2V5O1xuICB0aGlzLmNvbXBvbmVudE9wdGlvbnMgPSBjb21wb25lbnRPcHRpb25zO1xuICB0aGlzLmNvbXBvbmVudEluc3RhbmNlID0gdW5kZWZpbmVkO1xuICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5yYXcgPSBmYWxzZTtcbiAgdGhpcy5pc1N0YXRpYyA9IGZhbHNlO1xuICB0aGlzLmlzUm9vdEluc2VydCA9IHRydWU7XG4gIHRoaXMuaXNDb21tZW50ID0gZmFsc2U7XG4gIHRoaXMuaXNDbG9uZWQgPSBmYWxzZTtcbiAgdGhpcy5pc09uY2UgPSBmYWxzZTtcbiAgdGhpcy5hc3luY0ZhY3RvcnkgPSBhc3luY0ZhY3Rvcnk7XG4gIHRoaXMuYXN5bmNNZXRhID0gdW5kZWZpbmVkO1xuICB0aGlzLmlzQXN5bmNQbGFjZWhvbGRlciA9IGZhbHNlO1xufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgY2hpbGQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuLy8gREVQUkVDQVRFRDogYWxpYXMgZm9yIGNvbXBvbmVudEluc3RhbmNlIGZvciBiYWNrd2FyZHMgY29tcGF0LlxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnByb3RvdHlwZUFjY2Vzc29ycy5jaGlsZC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNvbXBvbmVudEluc3RhbmNlXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVk5vZGUucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxudmFyIGNyZWF0ZUVtcHR5Vk5vZGUgPSBmdW5jdGlvbiAodGV4dCkge1xuICBpZiAoIHRleHQgPT09IHZvaWQgMCApIHRleHQgPSAnJztcblxuICB2YXIgbm9kZSA9IG5ldyBWTm9kZSgpO1xuICBub2RlLnRleHQgPSB0ZXh0O1xuICBub2RlLmlzQ29tbWVudCA9IHRydWU7XG4gIHJldHVybiBub2RlXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Vk5vZGUgKHZhbCkge1xuICByZXR1cm4gbmV3IFZOb2RlKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFN0cmluZyh2YWwpKVxufVxuXG4vLyBvcHRpbWl6ZWQgc2hhbGxvdyBjbG9uZVxuLy8gdXNlZCBmb3Igc3RhdGljIG5vZGVzIGFuZCBzbG90IG5vZGVzIGJlY2F1c2UgdGhleSBtYXkgYmUgcmV1c2VkIGFjcm9zc1xuLy8gbXVsdGlwbGUgcmVuZGVycywgY2xvbmluZyB0aGVtIGF2b2lkcyBlcnJvcnMgd2hlbiBET00gbWFuaXB1bGF0aW9ucyByZWx5XG4vLyBvbiB0aGVpciBlbG0gcmVmZXJlbmNlLlxuZnVuY3Rpb24gY2xvbmVWTm9kZSAodm5vZGUpIHtcbiAgdmFyIGNsb25lZCA9IG5ldyBWTm9kZShcbiAgICB2bm9kZS50YWcsXG4gICAgdm5vZGUuZGF0YSxcbiAgICB2bm9kZS5jaGlsZHJlbixcbiAgICB2bm9kZS50ZXh0LFxuICAgIHZub2RlLmVsbSxcbiAgICB2bm9kZS5jb250ZXh0LFxuICAgIHZub2RlLmNvbXBvbmVudE9wdGlvbnMsXG4gICAgdm5vZGUuYXN5bmNGYWN0b3J5XG4gICk7XG4gIGNsb25lZC5ucyA9IHZub2RlLm5zO1xuICBjbG9uZWQuaXNTdGF0aWMgPSB2bm9kZS5pc1N0YXRpYztcbiAgY2xvbmVkLmtleSA9IHZub2RlLmtleTtcbiAgY2xvbmVkLmlzQ29tbWVudCA9IHZub2RlLmlzQ29tbWVudDtcbiAgY2xvbmVkLmZuQ29udGV4dCA9IHZub2RlLmZuQ29udGV4dDtcbiAgY2xvbmVkLmZuT3B0aW9ucyA9IHZub2RlLmZuT3B0aW9ucztcbiAgY2xvbmVkLmZuU2NvcGVJZCA9IHZub2RlLmZuU2NvcGVJZDtcbiAgY2xvbmVkLmlzQ2xvbmVkID0gdHJ1ZTtcbiAgcmV0dXJuIGNsb25lZFxufVxuXG4vKlxuICogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoXG4gKiBkeW5hbWljYWxseSBhY2Nlc3NpbmcgbWV0aG9kcyBvbiBBcnJheSBwcm90b3R5cGVcbiAqL1xuXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbnZhciBhcnJheU1ldGhvZHMgPSBPYmplY3QuY3JlYXRlKGFycmF5UHJvdG8pO1xuXG52YXIgbWV0aG9kc1RvUGF0Y2ggPSBbXG4gICdwdXNoJyxcbiAgJ3BvcCcsXG4gICdzaGlmdCcsXG4gICd1bnNoaWZ0JyxcbiAgJ3NwbGljZScsXG4gICdzb3J0JyxcbiAgJ3JldmVyc2UnXG5dO1xuXG4vKipcbiAqIEludGVyY2VwdCBtdXRhdGluZyBtZXRob2RzIGFuZCBlbWl0IGV2ZW50c1xuICovXG5tZXRob2RzVG9QYXRjaC5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgLy8gY2FjaGUgb3JpZ2luYWwgbWV0aG9kXG4gIHZhciBvcmlnaW5hbCA9IGFycmF5UHJvdG9bbWV0aG9kXTtcbiAgZGVmKGFycmF5TWV0aG9kcywgbWV0aG9kLCBmdW5jdGlvbiBtdXRhdG9yICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICB2YXIgcmVzdWx0ID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgdmFyIG9iID0gdGhpcy5fX29iX187XG4gICAgdmFyIGluc2VydGVkO1xuICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICBjYXNlICdwdXNoJzpcbiAgICAgIGNhc2UgJ3Vuc2hpZnQnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3M7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdzcGxpY2UnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3Muc2xpY2UoMik7XG4gICAgICAgIGJyZWFrXG4gICAgfVxuICAgIGlmIChpbnNlcnRlZCkgeyBvYi5vYnNlcnZlQXJyYXkoaW5zZXJ0ZWQpOyB9XG4gICAgLy8gbm90aWZ5IGNoYW5nZVxuICAgIG9iLmRlcC5ub3RpZnkoKTtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH0pO1xufSk7XG5cbi8qICAqL1xuXG52YXIgYXJyYXlLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJyYXlNZXRob2RzKTtcblxuLyoqXG4gKiBJbiBzb21lIGNhc2VzIHdlIG1heSB3YW50IHRvIGRpc2FibGUgb2JzZXJ2YXRpb24gaW5zaWRlIGEgY29tcG9uZW50J3NcbiAqIHVwZGF0ZSBjb21wdXRhdGlvbi5cbiAqL1xudmFyIHNob3VsZE9ic2VydmUgPSB0cnVlO1xuXG5mdW5jdGlvbiB0b2dnbGVPYnNlcnZpbmcgKHZhbHVlKSB7XG4gIHNob3VsZE9ic2VydmUgPSB2YWx1ZTtcbn1cblxuLyoqXG4gKiBPYnNlcnZlciBjbGFzcyB0aGF0IGlzIGF0dGFjaGVkIHRvIGVhY2ggb2JzZXJ2ZWRcbiAqIG9iamVjdC4gT25jZSBhdHRhY2hlZCwgdGhlIG9ic2VydmVyIGNvbnZlcnRzIHRoZSB0YXJnZXRcbiAqIG9iamVjdCdzIHByb3BlcnR5IGtleXMgaW50byBnZXR0ZXIvc2V0dGVycyB0aGF0XG4gKiBjb2xsZWN0IGRlcGVuZGVuY2llcyBhbmQgZGlzcGF0Y2ggdXBkYXRlcy5cbiAqL1xudmFyIE9ic2VydmVyID0gZnVuY3Rpb24gT2JzZXJ2ZXIgKHZhbHVlKSB7XG4gIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgdGhpcy5kZXAgPSBuZXcgRGVwKCk7XG4gIHRoaXMudm1Db3VudCA9IDA7XG4gIGRlZih2YWx1ZSwgJ19fb2JfXycsIHRoaXMpO1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICB2YXIgYXVnbWVudCA9IGhhc1Byb3RvXG4gICAgICA/IHByb3RvQXVnbWVudFxuICAgICAgOiBjb3B5QXVnbWVudDtcbiAgICBhdWdtZW50KHZhbHVlLCBhcnJheU1ldGhvZHMsIGFycmF5S2V5cyk7XG4gICAgdGhpcy5vYnNlcnZlQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMud2Fsayh2YWx1ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogV2FsayB0aHJvdWdoIGVhY2ggcHJvcGVydHkgYW5kIGNvbnZlcnQgdGhlbSBpbnRvXG4gKiBnZXR0ZXIvc2V0dGVycy4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW5cbiAqIHZhbHVlIHR5cGUgaXMgT2JqZWN0LlxuICovXG5PYnNlcnZlci5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIHdhbGsgKG9iaikge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGRlZmluZVJlYWN0aXZlKG9iaiwga2V5c1tpXSk7XG4gIH1cbn07XG5cbi8qKlxuICogT2JzZXJ2ZSBhIGxpc3Qgb2YgQXJyYXkgaXRlbXMuXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS5vYnNlcnZlQXJyYXkgPSBmdW5jdGlvbiBvYnNlcnZlQXJyYXkgKGl0ZW1zKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb2JzZXJ2ZShpdGVtc1tpXSk7XG4gIH1cbn07XG5cbi8vIGhlbHBlcnNcblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgaW50ZXJjZXB0aW5nXG4gKiB0aGUgcHJvdG90eXBlIGNoYWluIHVzaW5nIF9fcHJvdG9fX1xuICovXG5mdW5jdGlvbiBwcm90b0F1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG4gIHRhcmdldC5fX3Byb3RvX18gPSBzcmM7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tcHJvdG8gKi9cbn1cblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgZGVmaW5pbmdcbiAqIGhpZGRlbiBwcm9wZXJ0aWVzLlxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gY29weUF1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBkZWYodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHQgdG8gY3JlYXRlIGFuIG9ic2VydmVyIGluc3RhbmNlIGZvciBhIHZhbHVlLFxuICogcmV0dXJucyB0aGUgbmV3IG9ic2VydmVyIGlmIHN1Y2Nlc3NmdWxseSBvYnNlcnZlZCxcbiAqIG9yIHRoZSBleGlzdGluZyBvYnNlcnZlciBpZiB0aGUgdmFsdWUgYWxyZWFkeSBoYXMgb25lLlxuICovXG5mdW5jdGlvbiBvYnNlcnZlICh2YWx1ZSwgYXNSb290RGF0YSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCB2YWx1ZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9iO1xuICBpZiAoaGFzT3duKHZhbHVlLCAnX19vYl9fJykgJiYgdmFsdWUuX19vYl9fIGluc3RhbmNlb2YgT2JzZXJ2ZXIpIHtcbiAgICBvYiA9IHZhbHVlLl9fb2JfXztcbiAgfSBlbHNlIGlmIChcbiAgICBzaG91bGRPYnNlcnZlICYmXG4gICAgIWlzU2VydmVyUmVuZGVyaW5nKCkgJiZcbiAgICAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSkpICYmXG4gICAgT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkgJiZcbiAgICAhdmFsdWUuX2lzVnVlXG4gICkge1xuICAgIG9iID0gbmV3IE9ic2VydmVyKHZhbHVlKTtcbiAgfVxuICBpZiAoYXNSb290RGF0YSAmJiBvYikge1xuICAgIG9iLnZtQ291bnQrKztcbiAgfVxuICByZXR1cm4gb2Jcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiBhbiBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGRlZmluZVJlYWN0aXZlIChcbiAgb2JqLFxuICBrZXksXG4gIHZhbCxcbiAgY3VzdG9tU2V0dGVyLFxuICBzaGFsbG93XG4pIHtcbiAgdmFyIGRlcCA9IG5ldyBEZXAoKTtcblxuICB2YXIgcHJvcGVydHkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgaWYgKHByb3BlcnR5ICYmIHByb3BlcnR5LmNvbmZpZ3VyYWJsZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGNhdGVyIGZvciBwcmUtZGVmaW5lZCBnZXR0ZXIvc2V0dGVyc1xuICB2YXIgZ2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuZ2V0O1xuICBpZiAoIWdldHRlciAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFsID0gb2JqW2tleV07XG4gIH1cbiAgdmFyIHNldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LnNldDtcblxuICB2YXIgY2hpbGRPYiA9ICFzaGFsbG93ICYmIG9ic2VydmUodmFsKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiByZWFjdGl2ZUdldHRlciAoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgZGVwLmRlcGVuZCgpO1xuICAgICAgICBpZiAoY2hpbGRPYikge1xuICAgICAgICAgIGNoaWxkT2IuZGVwLmRlcGVuZCgpO1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgZGVwZW5kQXJyYXkodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlU2V0dGVyIChuZXdWYWwpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChuZXdWYWwgPT09IHZhbHVlIHx8IChuZXdWYWwgIT09IG5ld1ZhbCAmJiB2YWx1ZSAhPT0gdmFsdWUpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBjdXN0b21TZXR0ZXIpIHtcbiAgICAgICAgY3VzdG9tU2V0dGVyKCk7XG4gICAgICB9XG4gICAgICBpZiAoc2V0dGVyKSB7XG4gICAgICAgIHNldHRlci5jYWxsKG9iaiwgbmV3VmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IG5ld1ZhbDtcbiAgICAgIH1cbiAgICAgIGNoaWxkT2IgPSAhc2hhbGxvdyAmJiBvYnNlcnZlKG5ld1ZhbCk7XG4gICAgICBkZXAubm90aWZ5KCk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBTZXQgYSBwcm9wZXJ0eSBvbiBhbiBvYmplY3QuIEFkZHMgdGhlIG5ldyBwcm9wZXJ0eSBhbmRcbiAqIHRyaWdnZXJzIGNoYW5nZSBub3RpZmljYXRpb24gaWYgdGhlIHByb3BlcnR5IGRvZXNuJ3RcbiAqIGFscmVhZHkgZXhpc3QuXG4gKi9cbmZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbCkge1xuICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAoaXNVbmRlZih0YXJnZXQpIHx8IGlzUHJpbWl0aXZlKHRhcmdldCkpXG4gICkge1xuICAgIHdhcm4oKFwiQ2Fubm90IHNldCByZWFjdGl2ZSBwcm9wZXJ0eSBvbiB1bmRlZmluZWQsIG51bGwsIG9yIHByaW1pdGl2ZSB2YWx1ZTogXCIgKyAoKHRhcmdldCkpKSk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiBpc1ZhbGlkQXJyYXlJbmRleChrZXkpKSB7XG4gICAgdGFyZ2V0Lmxlbmd0aCA9IE1hdGgubWF4KHRhcmdldC5sZW5ndGgsIGtleSk7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEsIHZhbCk7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGlmIChrZXkgaW4gdGFyZ2V0ICYmICEoa2V5IGluIE9iamVjdC5wcm90b3R5cGUpKSB7XG4gICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIHZhciBvYiA9ICh0YXJnZXQpLl9fb2JfXztcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdBdm9pZCBhZGRpbmcgcmVhY3RpdmUgcHJvcGVydGllcyB0byBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICdhdCBydW50aW1lIC0gZGVjbGFyZSBpdCB1cGZyb250IGluIHRoZSBkYXRhIG9wdGlvbi4nXG4gICAgKTtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgaWYgKCFvYikge1xuICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBkZWZpbmVSZWFjdGl2ZShvYi52YWx1ZSwga2V5LCB2YWwpO1xuICBvYi5kZXAubm90aWZ5KCk7XG4gIHJldHVybiB2YWxcbn1cblxuLyoqXG4gKiBEZWxldGUgYSBwcm9wZXJ0eSBhbmQgdHJpZ2dlciBjaGFuZ2UgaWYgbmVjZXNzYXJ5LlxuICovXG5mdW5jdGlvbiBkZWwgKHRhcmdldCwga2V5KSB7XG4gIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIChpc1VuZGVmKHRhcmdldCkgfHwgaXNQcmltaXRpdmUodGFyZ2V0KSlcbiAgKSB7XG4gICAgd2FybigoXCJDYW5ub3QgZGVsZXRlIHJlYWN0aXZlIHByb3BlcnR5IG9uIHVuZGVmaW5lZCwgbnVsbCwgb3IgcHJpbWl0aXZlIHZhbHVlOiBcIiArICgodGFyZ2V0KSkpKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIGlzVmFsaWRBcnJheUluZGV4KGtleSkpIHtcbiAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9iID0gKHRhcmdldCkuX19vYl9fO1xuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ0F2b2lkIGRlbGV0aW5nIHByb3BlcnRpZXMgb24gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAnLSBqdXN0IHNldCBpdCB0byBudWxsLidcbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICghaGFzT3duKHRhcmdldCwga2V5KSkge1xuICAgIHJldHVyblxuICB9XG4gIGRlbGV0ZSB0YXJnZXRba2V5XTtcbiAgaWYgKCFvYikge1xuICAgIHJldHVyblxuICB9XG4gIG9iLmRlcC5ub3RpZnkoKTtcbn1cblxuLyoqXG4gKiBDb2xsZWN0IGRlcGVuZGVuY2llcyBvbiBhcnJheSBlbGVtZW50cyB3aGVuIHRoZSBhcnJheSBpcyB0b3VjaGVkLCBzaW5jZVxuICogd2UgY2Fubm90IGludGVyY2VwdCBhcnJheSBlbGVtZW50IGFjY2VzcyBsaWtlIHByb3BlcnR5IGdldHRlcnMuXG4gKi9cbmZ1bmN0aW9uIGRlcGVuZEFycmF5ICh2YWx1ZSkge1xuICBmb3IgKHZhciBlID0gKHZvaWQgMCksIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZSA9IHZhbHVlW2ldO1xuICAgIGUgJiYgZS5fX29iX18gJiYgZS5fX29iX18uZGVwLmRlcGVuZCgpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGUpKSB7XG4gICAgICBkZXBlbmRBcnJheShlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogT3B0aW9uIG92ZXJ3cml0aW5nIHN0cmF0ZWdpZXMgYXJlIGZ1bmN0aW9ucyB0aGF0IGhhbmRsZVxuICogaG93IHRvIG1lcmdlIGEgcGFyZW50IG9wdGlvbiB2YWx1ZSBhbmQgYSBjaGlsZCBvcHRpb25cbiAqIHZhbHVlIGludG8gdGhlIGZpbmFsIHZhbHVlLlxuICovXG52YXIgc3RyYXRzID0gY29uZmlnLm9wdGlvbk1lcmdlU3RyYXRlZ2llcztcblxuLyoqXG4gKiBPcHRpb25zIHdpdGggcmVzdHJpY3Rpb25zXG4gKi9cbntcbiAgc3RyYXRzLmVsID0gc3RyYXRzLnByb3BzRGF0YSA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkLCB2bSwga2V5KSB7XG4gICAgaWYgKCF2bSkge1xuICAgICAgd2FybihcbiAgICAgICAgXCJvcHRpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIGNhbiBvbmx5IGJlIHVzZWQgZHVyaW5nIGluc3RhbmNlIFwiICtcbiAgICAgICAgJ2NyZWF0aW9uIHdpdGggdGhlIGBuZXdgIGtleXdvcmQuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRTdHJhdChwYXJlbnQsIGNoaWxkKVxuICB9O1xufVxuXG4vKipcbiAqIEhlbHBlciB0aGF0IHJlY3Vyc2l2ZWx5IG1lcmdlcyB0d28gZGF0YSBvYmplY3RzIHRvZ2V0aGVyLlxuICovXG5mdW5jdGlvbiBtZXJnZURhdGEgKHRvLCBmcm9tKSB7XG4gIGlmICghZnJvbSkgeyByZXR1cm4gdG8gfVxuICB2YXIga2V5LCB0b1ZhbCwgZnJvbVZhbDtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcm9tKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICB0b1ZhbCA9IHRvW2tleV07XG4gICAgZnJvbVZhbCA9IGZyb21ba2V5XTtcbiAgICBpZiAoIWhhc093bih0bywga2V5KSkge1xuICAgICAgc2V0KHRvLCBrZXksIGZyb21WYWwpO1xuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh0b1ZhbCkgJiYgaXNQbGFpbk9iamVjdChmcm9tVmFsKSkge1xuICAgICAgbWVyZ2VEYXRhKHRvVmFsLCBmcm9tVmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogRGF0YVxuICovXG5mdW5jdGlvbiBtZXJnZURhdGFPckZuIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm1cbikge1xuICBpZiAoIXZtKSB7XG4gICAgLy8gaW4gYSBWdWUuZXh0ZW5kIG1lcmdlLCBib3RoIHNob3VsZCBiZSBmdW5jdGlvbnNcbiAgICBpZiAoIWNoaWxkVmFsKSB7XG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIGlmICghcGFyZW50VmFsKSB7XG4gICAgICByZXR1cm4gY2hpbGRWYWxcbiAgICB9XG4gICAgLy8gd2hlbiBwYXJlbnRWYWwgJiBjaGlsZFZhbCBhcmUgYm90aCBwcmVzZW50LFxuICAgIC8vIHdlIG5lZWQgdG8gcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAgIC8vIG1lcmdlZCByZXN1bHQgb2YgYm90aCBmdW5jdGlvbnMuLi4gbm8gbmVlZCB0b1xuICAgIC8vIGNoZWNrIGlmIHBhcmVudFZhbCBpcyBhIGZ1bmN0aW9uIGhlcmUgYmVjYXVzZVxuICAgIC8vIGl0IGhhcyB0byBiZSBhIGZ1bmN0aW9uIHRvIHBhc3MgcHJldmlvdXMgbWVyZ2VzLlxuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWREYXRhRm4gKCkge1xuICAgICAgcmV0dXJuIG1lcmdlRGF0YShcbiAgICAgICAgdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nID8gY2hpbGRWYWwuY2FsbCh0aGlzLCB0aGlzKSA6IGNoaWxkVmFsLFxuICAgICAgICB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nID8gcGFyZW50VmFsLmNhbGwodGhpcywgdGhpcykgOiBwYXJlbnRWYWxcbiAgICAgIClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZEluc3RhbmNlRGF0YUZuICgpIHtcbiAgICAgIC8vIGluc3RhbmNlIG1lcmdlXG4gICAgICB2YXIgaW5zdGFuY2VEYXRhID0gdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gY2hpbGRWYWwuY2FsbCh2bSwgdm0pXG4gICAgICAgIDogY2hpbGRWYWw7XG4gICAgICB2YXIgZGVmYXVsdERhdGEgPSB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gcGFyZW50VmFsLmNhbGwodm0sIHZtKVxuICAgICAgICA6IHBhcmVudFZhbDtcbiAgICAgIGlmIChpbnN0YW5jZURhdGEpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlRGF0YShpbnN0YW5jZURhdGEsIGRlZmF1bHREYXRhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHREYXRhXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnN0cmF0cy5kYXRhID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bVxuKSB7XG4gIGlmICghdm0pIHtcbiAgICBpZiAoY2hpbGRWYWwgJiYgdHlwZW9mIGNoaWxkVmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAnVGhlIFwiZGF0YVwiIG9wdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbiAnICtcbiAgICAgICAgJ3RoYXQgcmV0dXJucyBhIHBlci1pbnN0YW5jZSB2YWx1ZSBpbiBjb21wb25lbnQgJyArXG4gICAgICAgICdkZWZpbml0aW9ucy4nLFxuICAgICAgICB2bVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHBhcmVudFZhbFxuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VEYXRhT3JGbihwYXJlbnRWYWwsIGNoaWxkVmFsKVxuICB9XG5cbiAgcmV0dXJuIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pXG59O1xuXG4vKipcbiAqIEhvb2tzIGFuZCBwcm9wcyBhcmUgbWVyZ2VkIGFzIGFycmF5cy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VIb29rIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbFxuKSB7XG4gIHJldHVybiBjaGlsZFZhbFxuICAgID8gcGFyZW50VmFsXG4gICAgICA/IHBhcmVudFZhbC5jb25jYXQoY2hpbGRWYWwpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRWYWwpXG4gICAgICAgID8gY2hpbGRWYWxcbiAgICAgICAgOiBbY2hpbGRWYWxdXG4gICAgOiBwYXJlbnRWYWxcbn1cblxuTElGRUNZQ0xFX0hPT0tTLmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHtcbiAgc3RyYXRzW2hvb2tdID0gbWVyZ2VIb29rO1xufSk7XG5cbi8qKlxuICogQXNzZXRzXG4gKlxuICogV2hlbiBhIHZtIGlzIHByZXNlbnQgKGluc3RhbmNlIGNyZWF0aW9uKSwgd2UgbmVlZCB0byBkb1xuICogYSB0aHJlZS13YXkgbWVyZ2UgYmV0d2VlbiBjb25zdHJ1Y3RvciBvcHRpb25zLCBpbnN0YW5jZVxuICogb3B0aW9ucyBhbmQgcGFyZW50IG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlQXNzZXRzIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm0sXG4gIGtleVxuKSB7XG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKTtcbiAgaWYgKGNoaWxkVmFsKSB7XG4gICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gICAgcmV0dXJuIGV4dGVuZChyZXMsIGNoaWxkVmFsKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiByZXNcbiAgfVxufVxuXG5BU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gIHN0cmF0c1t0eXBlICsgJ3MnXSA9IG1lcmdlQXNzZXRzO1xufSk7XG5cbi8qKlxuICogV2F0Y2hlcnMuXG4gKlxuICogV2F0Y2hlcnMgaGFzaGVzIHNob3VsZCBub3Qgb3ZlcndyaXRlIG9uZVxuICogYW5vdGhlciwgc28gd2UgbWVyZ2UgdGhlbSBhcyBhcnJheXMuXG4gKi9cbnN0cmF0cy53YXRjaCA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm0sXG4gIGtleVxuKSB7XG4gIC8vIHdvcmsgYXJvdW5kIEZpcmVmb3gncyBPYmplY3QucHJvdG90eXBlLndhdGNoLi4uXG4gIGlmIChwYXJlbnRWYWwgPT09IG5hdGl2ZVdhdGNoKSB7IHBhcmVudFZhbCA9IHVuZGVmaW5lZDsgfVxuICBpZiAoY2hpbGRWYWwgPT09IG5hdGl2ZVdhdGNoKSB7IGNoaWxkVmFsID0gdW5kZWZpbmVkOyB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNoaWxkVmFsKSB7IHJldHVybiBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKSB9XG4gIHtcbiAgICBhc3NlcnRPYmplY3RUeXBlKGtleSwgY2hpbGRWYWwsIHZtKTtcbiAgfVxuICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxuICB2YXIgcmV0ID0ge307XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGZvciAodmFyIGtleSQxIGluIGNoaWxkVmFsKSB7XG4gICAgdmFyIHBhcmVudCA9IHJldFtrZXkkMV07XG4gICAgdmFyIGNoaWxkID0gY2hpbGRWYWxba2V5JDFdO1xuICAgIGlmIChwYXJlbnQgJiYgIUFycmF5LmlzQXJyYXkocGFyZW50KSkge1xuICAgICAgcGFyZW50ID0gW3BhcmVudF07XG4gICAgfVxuICAgIHJldFtrZXkkMV0gPSBwYXJlbnRcbiAgICAgID8gcGFyZW50LmNvbmNhdChjaGlsZClcbiAgICAgIDogQXJyYXkuaXNBcnJheShjaGlsZCkgPyBjaGlsZCA6IFtjaGlsZF07XG4gIH1cbiAgcmV0dXJuIHJldFxufTtcblxuLyoqXG4gKiBPdGhlciBvYmplY3QgaGFzaGVzLlxuICovXG5zdHJhdHMucHJvcHMgPVxuc3RyYXRzLm1ldGhvZHMgPVxuc3RyYXRzLmluamVjdCA9XG5zdHJhdHMuY29tcHV0ZWQgPSBmdW5jdGlvbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtLFxuICBrZXlcbikge1xuICBpZiAoY2hpbGRWYWwgJiYgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnRPYmplY3RUeXBlKGtleSwgY2hpbGRWYWwsIHZtKTtcbiAgfVxuICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxuICB2YXIgcmV0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgaWYgKGNoaWxkVmFsKSB7IGV4dGVuZChyZXQsIGNoaWxkVmFsKTsgfVxuICByZXR1cm4gcmV0XG59O1xuc3RyYXRzLnByb3ZpZGUgPSBtZXJnZURhdGFPckZuO1xuXG4vKipcbiAqIERlZmF1bHQgc3RyYXRlZ3kuXG4gKi9cbnZhciBkZWZhdWx0U3RyYXQgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICByZXR1cm4gY2hpbGRWYWwgPT09IHVuZGVmaW5lZFxuICAgID8gcGFyZW50VmFsXG4gICAgOiBjaGlsZFZhbFxufTtcblxuLyoqXG4gKiBWYWxpZGF0ZSBjb21wb25lbnQgbmFtZXNcbiAqL1xuZnVuY3Rpb24gY2hlY2tDb21wb25lbnRzIChvcHRpb25zKSB7XG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLmNvbXBvbmVudHMpIHtcbiAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUoa2V5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNvbXBvbmVudE5hbWUgKG5hbWUpIHtcbiAgaWYgKCEvXlthLXpBLVpdW1xcdy1dKiQvLnRlc3QobmFtZSkpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ludmFsaWQgY29tcG9uZW50IG5hbWU6IFwiJyArIG5hbWUgKyAnXCIuIENvbXBvbmVudCBuYW1lcyAnICtcbiAgICAgICdjYW4gb25seSBjb250YWluIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzIGFuZCB0aGUgaHlwaGVuLCAnICtcbiAgICAgICdhbmQgbXVzdCBzdGFydCB3aXRoIGEgbGV0dGVyLidcbiAgICApO1xuICB9XG4gIGlmIChpc0J1aWx0SW5UYWcobmFtZSkgfHwgY29uZmlnLmlzUmVzZXJ2ZWRUYWcobmFtZSkpIHtcbiAgICB3YXJuKFxuICAgICAgJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgJyArXG4gICAgICAnaWQ6ICcgKyBuYW1lXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIEVuc3VyZSBhbGwgcHJvcHMgb3B0aW9uIHN5bnRheCBhcmUgbm9ybWFsaXplZCBpbnRvIHRoZVxuICogT2JqZWN0LWJhc2VkIGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplUHJvcHMgKG9wdGlvbnMsIHZtKSB7XG4gIHZhciBwcm9wcyA9IG9wdGlvbnMucHJvcHM7XG4gIGlmICghcHJvcHMpIHsgcmV0dXJuIH1cbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgaSwgdmFsLCBuYW1lO1xuICBpZiAoQXJyYXkuaXNBcnJheShwcm9wcykpIHtcbiAgICBpID0gcHJvcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhbCA9IHByb3BzW2ldO1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG5hbWUgPSBjYW1lbGl6ZSh2YWwpO1xuICAgICAgICByZXNbbmFtZV0gPSB7IHR5cGU6IG51bGwgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oJ3Byb3BzIG11c3QgYmUgc3RyaW5ncyB3aGVuIHVzaW5nIGFycmF5IHN5bnRheC4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChwcm9wcykpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIHZhbCA9IHByb3BzW2tleV07XG4gICAgICBuYW1lID0gY2FtZWxpemUoa2V5KTtcbiAgICAgIHJlc1tuYW1lXSA9IGlzUGxhaW5PYmplY3QodmFsKVxuICAgICAgICA/IHZhbFxuICAgICAgICA6IHsgdHlwZTogdmFsIH07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHdhcm4oXG4gICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwicHJvcHNcXFwiOiBleHBlY3RlZCBhbiBBcnJheSBvciBhbiBPYmplY3QsIFwiICtcbiAgICAgIFwiYnV0IGdvdCBcIiArICh0b1Jhd1R5cGUocHJvcHMpKSArIFwiLlwiLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIG9wdGlvbnMucHJvcHMgPSByZXM7XG59XG5cbi8qKlxuICogTm9ybWFsaXplIGFsbCBpbmplY3Rpb25zIGludG8gT2JqZWN0LWJhc2VkIGZvcm1hdFxuICovXG5mdW5jdGlvbiBub3JtYWxpemVJbmplY3QgKG9wdGlvbnMsIHZtKSB7XG4gIHZhciBpbmplY3QgPSBvcHRpb25zLmluamVjdDtcbiAgaWYgKCFpbmplY3QpIHsgcmV0dXJuIH1cbiAgdmFyIG5vcm1hbGl6ZWQgPSBvcHRpb25zLmluamVjdCA9IHt9O1xuICBpZiAoQXJyYXkuaXNBcnJheShpbmplY3QpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmplY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vcm1hbGl6ZWRbaW5qZWN0W2ldXSA9IHsgZnJvbTogaW5qZWN0W2ldIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QoaW5qZWN0KSkge1xuICAgIGZvciAodmFyIGtleSBpbiBpbmplY3QpIHtcbiAgICAgIHZhciB2YWwgPSBpbmplY3Rba2V5XTtcbiAgICAgIG5vcm1hbGl6ZWRba2V5XSA9IGlzUGxhaW5PYmplY3QodmFsKVxuICAgICAgICA/IGV4dGVuZCh7IGZyb206IGtleSB9LCB2YWwpXG4gICAgICAgIDogeyBmcm9tOiB2YWwgfTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd2FybihcbiAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJpbmplY3RcXFwiOiBleHBlY3RlZCBhbiBBcnJheSBvciBhbiBPYmplY3QsIFwiICtcbiAgICAgIFwiYnV0IGdvdCBcIiArICh0b1Jhd1R5cGUoaW5qZWN0KSkgKyBcIi5cIixcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSByYXcgZnVuY3Rpb24gZGlyZWN0aXZlcyBpbnRvIG9iamVjdCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMgKG9wdGlvbnMpIHtcbiAgdmFyIGRpcnMgPSBvcHRpb25zLmRpcmVjdGl2ZXM7XG4gIGlmIChkaXJzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGRpcnMpIHtcbiAgICAgIHZhciBkZWYgPSBkaXJzW2tleV07XG4gICAgICBpZiAodHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBkaXJzW2tleV0gPSB7IGJpbmQ6IGRlZiwgdXBkYXRlOiBkZWYgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0T2JqZWN0VHlwZSAobmFtZSwgdmFsdWUsIHZtKSB7XG4gIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICB3YXJuKFxuICAgICAgXCJJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXFxcIlwiICsgbmFtZSArIFwiXFxcIjogZXhwZWN0ZWQgYW4gT2JqZWN0LCBcIiArXG4gICAgICBcImJ1dCBnb3QgXCIgKyAodG9SYXdUeXBlKHZhbHVlKSkgKyBcIi5cIixcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIE1lcmdlIHR3byBvcHRpb24gb2JqZWN0cyBpbnRvIGEgbmV3IG9uZS5cbiAqIENvcmUgdXRpbGl0eSB1c2VkIGluIGJvdGggaW5zdGFudGlhdGlvbiBhbmQgaW5oZXJpdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyAoXG4gIHBhcmVudCxcbiAgY2hpbGQsXG4gIHZtXG4pIHtcbiAge1xuICAgIGNoZWNrQ29tcG9uZW50cyhjaGlsZCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGNoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2hpbGQgPSBjaGlsZC5vcHRpb25zO1xuICB9XG5cbiAgbm9ybWFsaXplUHJvcHMoY2hpbGQsIHZtKTtcbiAgbm9ybWFsaXplSW5qZWN0KGNoaWxkLCB2bSk7XG4gIG5vcm1hbGl6ZURpcmVjdGl2ZXMoY2hpbGQpO1xuICB2YXIgZXh0ZW5kc0Zyb20gPSBjaGlsZC5leHRlbmRzO1xuICBpZiAoZXh0ZW5kc0Zyb20pIHtcbiAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBleHRlbmRzRnJvbSwgdm0pO1xuICB9XG4gIGlmIChjaGlsZC5taXhpbnMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkLm1peGlucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLm1peGluc1tpXSwgdm0pO1xuICAgIH1cbiAgfVxuICB2YXIgb3B0aW9ucyA9IHt9O1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBwYXJlbnQpIHtcbiAgICBtZXJnZUZpZWxkKGtleSk7XG4gIH1cbiAgZm9yIChrZXkgaW4gY2hpbGQpIHtcbiAgICBpZiAoIWhhc093bihwYXJlbnQsIGtleSkpIHtcbiAgICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbWVyZ2VGaWVsZCAoa2V5KSB7XG4gICAgdmFyIHN0cmF0ID0gc3RyYXRzW2tleV0gfHwgZGVmYXVsdFN0cmF0O1xuICAgIG9wdGlvbnNba2V5XSA9IHN0cmF0KHBhcmVudFtrZXldLCBjaGlsZFtrZXldLCB2bSwga2V5KTtcbiAgfVxuICByZXR1cm4gb3B0aW9uc1xufVxuXG4vKipcbiAqIFJlc29sdmUgYW4gYXNzZXQuXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYmVjYXVzZSBjaGlsZCBpbnN0YW5jZXMgbmVlZCBhY2Nlc3NcbiAqIHRvIGFzc2V0cyBkZWZpbmVkIGluIGl0cyBhbmNlc3RvciBjaGFpbi5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUFzc2V0IChcbiAgb3B0aW9ucyxcbiAgdHlwZSxcbiAgaWQsXG4gIHdhcm5NaXNzaW5nXG4pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGFzc2V0cyA9IG9wdGlvbnNbdHlwZV07XG4gIC8vIGNoZWNrIGxvY2FsIHJlZ2lzdHJhdGlvbiB2YXJpYXRpb25zIGZpcnN0XG4gIGlmIChoYXNPd24oYXNzZXRzLCBpZCkpIHsgcmV0dXJuIGFzc2V0c1tpZF0gfVxuICB2YXIgY2FtZWxpemVkSWQgPSBjYW1lbGl6ZShpZCk7XG4gIGlmIChoYXNPd24oYXNzZXRzLCBjYW1lbGl6ZWRJZCkpIHsgcmV0dXJuIGFzc2V0c1tjYW1lbGl6ZWRJZF0gfVxuICB2YXIgUGFzY2FsQ2FzZUlkID0gY2FwaXRhbGl6ZShjYW1lbGl6ZWRJZCk7XG4gIGlmIChoYXNPd24oYXNzZXRzLCBQYXNjYWxDYXNlSWQpKSB7IHJldHVybiBhc3NldHNbUGFzY2FsQ2FzZUlkXSB9XG4gIC8vIGZhbGxiYWNrIHRvIHByb3RvdHlwZSBjaGFpblxuICB2YXIgcmVzID0gYXNzZXRzW2lkXSB8fCBhc3NldHNbY2FtZWxpemVkSWRdIHx8IGFzc2V0c1tQYXNjYWxDYXNlSWRdO1xuICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybk1pc3NpbmcgJiYgIXJlcykge1xuICAgIHdhcm4oXG4gICAgICAnRmFpbGVkIHRvIHJlc29sdmUgJyArIHR5cGUuc2xpY2UoMCwgLTEpICsgJzogJyArIGlkLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wIChcbiAga2V5LFxuICBwcm9wT3B0aW9ucyxcbiAgcHJvcHNEYXRhLFxuICB2bVxuKSB7XG4gIHZhciBwcm9wID0gcHJvcE9wdGlvbnNba2V5XTtcbiAgdmFyIGFic2VudCA9ICFoYXNPd24ocHJvcHNEYXRhLCBrZXkpO1xuICB2YXIgdmFsdWUgPSBwcm9wc0RhdGFba2V5XTtcbiAgLy8gYm9vbGVhbiBjYXN0aW5nXG4gIHZhciBib29sZWFuSW5kZXggPSBnZXRUeXBlSW5kZXgoQm9vbGVhbiwgcHJvcC50eXBlKTtcbiAgaWYgKGJvb2xlYW5JbmRleCA+IC0xKSB7XG4gICAgaWYgKGFic2VudCAmJiAhaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09IGh5cGhlbmF0ZShrZXkpKSB7XG4gICAgICAvLyBvbmx5IGNhc3QgZW1wdHkgc3RyaW5nIC8gc2FtZSBuYW1lIHRvIGJvb2xlYW4gaWZcbiAgICAgIC8vIGJvb2xlYW4gaGFzIGhpZ2hlciBwcmlvcml0eVxuICAgICAgdmFyIHN0cmluZ0luZGV4ID0gZ2V0VHlwZUluZGV4KFN0cmluZywgcHJvcC50eXBlKTtcbiAgICAgIGlmIChzdHJpbmdJbmRleCA8IDAgfHwgYm9vbGVhbkluZGV4IDwgc3RyaW5nSW5kZXgpIHtcbiAgICAgICAgdmFsdWUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBjaGVjayBkZWZhdWx0IHZhbHVlXG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsdWUgPSBnZXRQcm9wRGVmYXVsdFZhbHVlKHZtLCBwcm9wLCBrZXkpO1xuICAgIC8vIHNpbmNlIHRoZSBkZWZhdWx0IHZhbHVlIGlzIGEgZnJlc2ggY29weSxcbiAgICAvLyBtYWtlIHN1cmUgdG8gb2JzZXJ2ZSBpdC5cbiAgICB2YXIgcHJldlNob3VsZE9ic2VydmUgPSBzaG91bGRPYnNlcnZlO1xuICAgIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbiAgICBvYnNlcnZlKHZhbHVlKTtcbiAgICB0b2dnbGVPYnNlcnZpbmcocHJldlNob3VsZE9ic2VydmUpO1xuICB9XG4gIHtcbiAgICBhc3NlcnRQcm9wKHByb3AsIGtleSwgdmFsdWUsIHZtLCBhYnNlbnQpO1xuICB9XG4gIHJldHVybiB2YWx1ZVxufVxuXG4vKipcbiAqIEdldCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBhIHByb3AuXG4gKi9cbmZ1bmN0aW9uIGdldFByb3BEZWZhdWx0VmFsdWUgKHZtLCBwcm9wLCBrZXkpIHtcbiAgLy8gbm8gZGVmYXVsdCwgcmV0dXJuIHVuZGVmaW5lZFxuICBpZiAoIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG4gIHZhciBkZWYgPSBwcm9wLmRlZmF1bHQ7XG4gIC8vIHdhcm4gYWdhaW5zdCBub24tZmFjdG9yeSBkZWZhdWx0cyBmb3IgT2JqZWN0ICYgQXJyYXlcbiAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzT2JqZWN0KGRlZikpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ludmFsaWQgZGVmYXVsdCB2YWx1ZSBmb3IgcHJvcCBcIicgKyBrZXkgKyAnXCI6ICcgK1xuICAgICAgJ1Byb3BzIHdpdGggdHlwZSBPYmplY3QvQXJyYXkgbXVzdCB1c2UgYSBmYWN0b3J5IGZ1bmN0aW9uICcgK1xuICAgICAgJ3RvIHJldHVybiB0aGUgZGVmYXVsdCB2YWx1ZS4nLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIC8vIHRoZSByYXcgcHJvcCB2YWx1ZSB3YXMgYWxzbyB1bmRlZmluZWQgZnJvbSBwcmV2aW91cyByZW5kZXIsXG4gIC8vIHJldHVybiBwcmV2aW91cyBkZWZhdWx0IHZhbHVlIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHdhdGNoZXIgdHJpZ2dlclxuICBpZiAodm0gJiYgdm0uJG9wdGlvbnMucHJvcHNEYXRhICYmXG4gICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhW2tleV0gPT09IHVuZGVmaW5lZCAmJlxuICAgIHZtLl9wcm9wc1trZXldICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgcmV0dXJuIHZtLl9wcm9wc1trZXldXG4gIH1cbiAgLy8gY2FsbCBmYWN0b3J5IGZ1bmN0aW9uIGZvciBub24tRnVuY3Rpb24gdHlwZXNcbiAgLy8gYSB2YWx1ZSBpcyBGdW5jdGlvbiBpZiBpdHMgcHJvdG90eXBlIGlzIGZ1bmN0aW9uIGV2ZW4gYWNyb3NzIGRpZmZlcmVudCBleGVjdXRpb24gY29udGV4dFxuICByZXR1cm4gdHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBnZXRUeXBlKHByb3AudHlwZSkgIT09ICdGdW5jdGlvbidcbiAgICA/IGRlZi5jYWxsKHZtKVxuICAgIDogZGVmXG59XG5cbi8qKlxuICogQXNzZXJ0IHdoZXRoZXIgYSBwcm9wIGlzIHZhbGlkLlxuICovXG5mdW5jdGlvbiBhc3NlcnRQcm9wIChcbiAgcHJvcCxcbiAgbmFtZSxcbiAgdmFsdWUsXG4gIHZtLFxuICBhYnNlbnRcbikge1xuICBpZiAocHJvcC5yZXF1aXJlZCAmJiBhYnNlbnQpIHtcbiAgICB3YXJuKFxuICAgICAgJ01pc3NpbmcgcmVxdWlyZWQgcHJvcDogXCInICsgbmFtZSArICdcIicsXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgJiYgIXByb3AucmVxdWlyZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdHlwZSA9IHByb3AudHlwZTtcbiAgdmFyIHZhbGlkID0gIXR5cGUgfHwgdHlwZSA9PT0gdHJ1ZTtcbiAgdmFyIGV4cGVjdGVkVHlwZXMgPSBbXTtcbiAgaWYgKHR5cGUpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIHR5cGUgPSBbdHlwZV07XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZS5sZW5ndGggJiYgIXZhbGlkOyBpKyspIHtcbiAgICAgIHZhciBhc3NlcnRlZFR5cGUgPSBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlW2ldKTtcbiAgICAgIGV4cGVjdGVkVHlwZXMucHVzaChhc3NlcnRlZFR5cGUuZXhwZWN0ZWRUeXBlIHx8ICcnKTtcbiAgICAgIHZhbGlkID0gYXNzZXJ0ZWRUeXBlLnZhbGlkO1xuICAgIH1cbiAgfVxuICBpZiAoIXZhbGlkKSB7XG4gICAgd2FybihcbiAgICAgIFwiSW52YWxpZCBwcm9wOiB0eXBlIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcXFwiXCIgKyBuYW1lICsgXCJcXFwiLlwiICtcbiAgICAgIFwiIEV4cGVjdGVkIFwiICsgKGV4cGVjdGVkVHlwZXMubWFwKGNhcGl0YWxpemUpLmpvaW4oJywgJykpICtcbiAgICAgIFwiLCBnb3QgXCIgKyAodG9SYXdUeXBlKHZhbHVlKSkgKyBcIi5cIixcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdmFsaWRhdG9yID0gcHJvcC52YWxpZGF0b3I7XG4gIGlmICh2YWxpZGF0b3IpIHtcbiAgICBpZiAoIXZhbGlkYXRvcih2YWx1ZSkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdJbnZhbGlkIHByb3A6IGN1c3RvbSB2YWxpZGF0b3IgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbnZhciBzaW1wbGVDaGVja1JFID0gL14oU3RyaW5nfE51bWJlcnxCb29sZWFufEZ1bmN0aW9ufFN5bWJvbCkkLztcblxuZnVuY3Rpb24gYXNzZXJ0VHlwZSAodmFsdWUsIHR5cGUpIHtcbiAgdmFyIHZhbGlkO1xuICB2YXIgZXhwZWN0ZWRUeXBlID0gZ2V0VHlwZSh0eXBlKTtcbiAgaWYgKHNpbXBsZUNoZWNrUkUudGVzdChleHBlY3RlZFR5cGUpKSB7XG4gICAgdmFyIHQgPSB0eXBlb2YgdmFsdWU7XG4gICAgdmFsaWQgPSB0ID09PSBleHBlY3RlZFR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAvLyBmb3IgcHJpbWl0aXZlIHdyYXBwZXIgb2JqZWN0c1xuICAgIGlmICghdmFsaWQgJiYgdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdPYmplY3QnKSB7XG4gICAgdmFsaWQgPSBpc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdBcnJheScpIHtcbiAgICB2YWxpZCA9IEFycmF5LmlzQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICB9XG4gIHJldHVybiB7XG4gICAgdmFsaWQ6IHZhbGlkLFxuICAgIGV4cGVjdGVkVHlwZTogZXhwZWN0ZWRUeXBlXG4gIH1cbn1cblxuLyoqXG4gKiBVc2UgZnVuY3Rpb24gc3RyaW5nIG5hbWUgdG8gY2hlY2sgYnVpbHQtaW4gdHlwZXMsXG4gKiBiZWNhdXNlIGEgc2ltcGxlIGVxdWFsaXR5IGNoZWNrIHdpbGwgZmFpbCB3aGVuIHJ1bm5pbmdcbiAqIGFjcm9zcyBkaWZmZXJlbnQgdm1zIC8gaWZyYW1lcy5cbiAqL1xuZnVuY3Rpb24gZ2V0VHlwZSAoZm4pIHtcbiAgdmFyIG1hdGNoID0gZm4gJiYgZm4udG9TdHJpbmcoKS5tYXRjaCgvXlxccypmdW5jdGlvbiAoXFx3KykvKTtcbiAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiAnJ1xufVxuXG5mdW5jdGlvbiBpc1NhbWVUeXBlIChhLCBiKSB7XG4gIHJldHVybiBnZXRUeXBlKGEpID09PSBnZXRUeXBlKGIpXG59XG5cbmZ1bmN0aW9uIGdldFR5cGVJbmRleCAodHlwZSwgZXhwZWN0ZWRUeXBlcykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWRUeXBlcykpIHtcbiAgICByZXR1cm4gaXNTYW1lVHlwZShleHBlY3RlZFR5cGVzLCB0eXBlKSA/IDAgOiAtMVxuICB9XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBleHBlY3RlZFR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGlzU2FtZVR5cGUoZXhwZWN0ZWRUeXBlc1tpXSwgdHlwZSkpIHtcbiAgICAgIHJldHVybiBpXG4gICAgfVxuICB9XG4gIHJldHVybiAtMVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaGFuZGxlRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgaWYgKHZtKSB7XG4gICAgdmFyIGN1ciA9IHZtO1xuICAgIHdoaWxlICgoY3VyID0gY3VyLiRwYXJlbnQpKSB7XG4gICAgICB2YXIgaG9va3MgPSBjdXIuJG9wdGlvbnMuZXJyb3JDYXB0dXJlZDtcbiAgICAgIGlmIChob29rcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBjYXB0dXJlID0gaG9va3NbaV0uY2FsbChjdXIsIGVyciwgdm0sIGluZm8pID09PSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChjYXB0dXJlKSB7IHJldHVybiB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZ2xvYmFsSGFuZGxlRXJyb3IoZSwgY3VyLCAnZXJyb3JDYXB0dXJlZCBob29rJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdsb2JhbEhhbmRsZUVycm9yKGVyciwgdm0sIGluZm8pO1xufVxuXG5mdW5jdGlvbiBnbG9iYWxIYW5kbGVFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICBpZiAoY29uZmlnLmVycm9ySGFuZGxlcikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY29uZmlnLmVycm9ySGFuZGxlci5jYWxsKG51bGwsIGVyciwgdm0sIGluZm8pXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nRXJyb3IoZSwgbnVsbCwgJ2NvbmZpZy5lcnJvckhhbmRsZXInKTtcbiAgICB9XG4gIH1cbiAgbG9nRXJyb3IoZXJyLCB2bSwgaW5mbyk7XG59XG5cbmZ1bmN0aW9uIGxvZ0Vycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIHtcbiAgICB3YXJuKChcIkVycm9yIGluIFwiICsgaW5mbyArIFwiOiBcXFwiXCIgKyAoZXJyLnRvU3RyaW5nKCkpICsgXCJcXFwiXCIpLCB2bSk7XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKChpbkJyb3dzZXIgfHwgaW5XZWV4KSAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zb2xlLmVycm9yKGVycik7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLyogICovXG4vKiBnbG9iYWxzIE1lc3NhZ2VDaGFubmVsICovXG5cbnZhciBjYWxsYmFja3MgPSBbXTtcbnZhciBwZW5kaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGZsdXNoQ2FsbGJhY2tzICgpIHtcbiAgcGVuZGluZyA9IGZhbHNlO1xuICB2YXIgY29waWVzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICBjYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3BpZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb3BpZXNbaV0oKTtcbiAgfVxufVxuXG4vLyBIZXJlIHdlIGhhdmUgYXN5bmMgZGVmZXJyaW5nIHdyYXBwZXJzIHVzaW5nIGJvdGggbWljcm90YXNrcyBhbmQgKG1hY3JvKSB0YXNrcy5cbi8vIEluIDwgMi40IHdlIHVzZWQgbWljcm90YXNrcyBldmVyeXdoZXJlLCBidXQgdGhlcmUgYXJlIHNvbWUgc2NlbmFyaW9zIHdoZXJlXG4vLyBtaWNyb3Rhc2tzIGhhdmUgdG9vIGhpZ2ggYSBwcmlvcml0eSBhbmQgZmlyZSBpbiBiZXR3ZWVuIHN1cHBvc2VkbHlcbi8vIHNlcXVlbnRpYWwgZXZlbnRzIChlLmcuICM0NTIxLCAjNjY5MCkgb3IgZXZlbiBiZXR3ZWVuIGJ1YmJsaW5nIG9mIHRoZSBzYW1lXG4vLyBldmVudCAoIzY1NjYpLiBIb3dldmVyLCB1c2luZyAobWFjcm8pIHRhc2tzIGV2ZXJ5d2hlcmUgYWxzbyBoYXMgc3VidGxlIHByb2JsZW1zXG4vLyB3aGVuIHN0YXRlIGlzIGNoYW5nZWQgcmlnaHQgYmVmb3JlIHJlcGFpbnQgKGUuZy4gIzY4MTMsIG91dC1pbiB0cmFuc2l0aW9ucykuXG4vLyBIZXJlIHdlIHVzZSBtaWNyb3Rhc2sgYnkgZGVmYXVsdCwgYnV0IGV4cG9zZSBhIHdheSB0byBmb3JjZSAobWFjcm8pIHRhc2sgd2hlblxuLy8gbmVlZGVkIChlLmcuIGluIGV2ZW50IGhhbmRsZXJzIGF0dGFjaGVkIGJ5IHYtb24pLlxudmFyIG1pY3JvVGltZXJGdW5jO1xudmFyIG1hY3JvVGltZXJGdW5jO1xudmFyIHVzZU1hY3JvVGFzayA9IGZhbHNlO1xuXG4vLyBEZXRlcm1pbmUgKG1hY3JvKSB0YXNrIGRlZmVyIGltcGxlbWVudGF0aW9uLlxuLy8gVGVjaG5pY2FsbHkgc2V0SW1tZWRpYXRlIHNob3VsZCBiZSB0aGUgaWRlYWwgY2hvaWNlLCBidXQgaXQncyBvbmx5IGF2YWlsYWJsZVxuLy8gaW4gSUUuIFRoZSBvbmx5IHBvbHlmaWxsIHRoYXQgY29uc2lzdGVudGx5IHF1ZXVlcyB0aGUgY2FsbGJhY2sgYWZ0ZXIgYWxsIERPTVxuLy8gZXZlbnRzIHRyaWdnZXJlZCBpbiB0aGUgc2FtZSBsb29wIGlzIGJ5IHVzaW5nIE1lc3NhZ2VDaGFubmVsLlxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAodHlwZW9mIHNldEltbWVkaWF0ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoc2V0SW1tZWRpYXRlKSkge1xuICBtYWNyb1RpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZXRJbW1lZGlhdGUoZmx1c2hDYWxsYmFja3MpO1xuICB9O1xufSBlbHNlIGlmICh0eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09ICd1bmRlZmluZWQnICYmIChcbiAgaXNOYXRpdmUoTWVzc2FnZUNoYW5uZWwpIHx8XG4gIC8vIFBoYW50b21KU1xuICBNZXNzYWdlQ2hhbm5lbC50b1N0cmluZygpID09PSAnW29iamVjdCBNZXNzYWdlQ2hhbm5lbENvbnN0cnVjdG9yXSdcbikpIHtcbiAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgdmFyIHBvcnQgPSBjaGFubmVsLnBvcnQyO1xuICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZsdXNoQ2FsbGJhY2tzO1xuICBtYWNyb1RpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBwb3J0LnBvc3RNZXNzYWdlKDEpO1xuICB9O1xufSBlbHNlIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgbWFjcm9UaW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2V0VGltZW91dChmbHVzaENhbGxiYWNrcywgMCk7XG4gIH07XG59XG5cbi8vIERldGVybWluZSBtaWNyb3Rhc2sgZGVmZXIgaW1wbGVtZW50YXRpb24uXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCwgJGZsb3ctZGlzYWJsZS1saW5lICovXG5pZiAodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb21pc2UpKSB7XG4gIHZhciBwID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIG1pY3JvVGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgIHAudGhlbihmbHVzaENhbGxiYWNrcyk7XG4gICAgLy8gaW4gcHJvYmxlbWF0aWMgVUlXZWJWaWV3cywgUHJvbWlzZS50aGVuIGRvZXNuJ3QgY29tcGxldGVseSBicmVhaywgYnV0XG4gICAgLy8gaXQgY2FuIGdldCBzdHVjayBpbiBhIHdlaXJkIHN0YXRlIHdoZXJlIGNhbGxiYWNrcyBhcmUgcHVzaGVkIGludG8gdGhlXG4gICAgLy8gbWljcm90YXNrIHF1ZXVlIGJ1dCB0aGUgcXVldWUgaXNuJ3QgYmVpbmcgZmx1c2hlZCwgdW50aWwgdGhlIGJyb3dzZXJcbiAgICAvLyBuZWVkcyB0byBkbyBzb21lIG90aGVyIHdvcmssIGUuZy4gaGFuZGxlIGEgdGltZXIuIFRoZXJlZm9yZSB3ZSBjYW5cbiAgICAvLyBcImZvcmNlXCIgdGhlIG1pY3JvdGFzayBxdWV1ZSB0byBiZSBmbHVzaGVkIGJ5IGFkZGluZyBhbiBlbXB0eSB0aW1lci5cbiAgICBpZiAoaXNJT1MpIHsgc2V0VGltZW91dChub29wKTsgfVxuICB9O1xufSBlbHNlIHtcbiAgLy8gZmFsbGJhY2sgdG8gbWFjcm9cbiAgbWljcm9UaW1lckZ1bmMgPSBtYWNyb1RpbWVyRnVuYztcbn1cblxuLyoqXG4gKiBXcmFwIGEgZnVuY3Rpb24gc28gdGhhdCBpZiBhbnkgY29kZSBpbnNpZGUgdHJpZ2dlcnMgc3RhdGUgY2hhbmdlLFxuICogdGhlIGNoYW5nZXMgYXJlIHF1ZXVlZCB1c2luZyBhIChtYWNybykgdGFzayBpbnN0ZWFkIG9mIGEgbWljcm90YXNrLlxuICovXG5mdW5jdGlvbiB3aXRoTWFjcm9UYXNrIChmbikge1xuICByZXR1cm4gZm4uX3dpdGhUYXNrIHx8IChmbi5fd2l0aFRhc2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgdXNlTWFjcm9UYXNrID0gdHJ1ZTtcbiAgICB2YXIgcmVzID0gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB1c2VNYWNyb1Rhc2sgPSBmYWxzZTtcbiAgICByZXR1cm4gcmVzXG4gIH0pXG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrIChjYiwgY3R4KSB7XG4gIHZhciBfcmVzb2x2ZTtcbiAgY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2IuY2FsbChjdHgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCBjdHgsICduZXh0VGljaycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoX3Jlc29sdmUpIHtcbiAgICAgIF9yZXNvbHZlKGN0eCk7XG4gICAgfVxuICB9KTtcbiAgaWYgKCFwZW5kaW5nKSB7XG4gICAgcGVuZGluZyA9IHRydWU7XG4gICAgaWYgKHVzZU1hY3JvVGFzaykge1xuICAgICAgbWFjcm9UaW1lckZ1bmMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWljcm9UaW1lckZ1bmMoKTtcbiAgICB9XG4gIH1cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIGlmICghY2IgJiYgdHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgfSlcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIG1hcms7XG52YXIgbWVhc3VyZTtcblxue1xuICB2YXIgcGVyZiA9IGluQnJvd3NlciAmJiB3aW5kb3cucGVyZm9ybWFuY2U7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoXG4gICAgcGVyZiAmJlxuICAgIHBlcmYubWFyayAmJlxuICAgIHBlcmYubWVhc3VyZSAmJlxuICAgIHBlcmYuY2xlYXJNYXJrcyAmJlxuICAgIHBlcmYuY2xlYXJNZWFzdXJlc1xuICApIHtcbiAgICBtYXJrID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gcGVyZi5tYXJrKHRhZyk7IH07XG4gICAgbWVhc3VyZSA9IGZ1bmN0aW9uIChuYW1lLCBzdGFydFRhZywgZW5kVGFnKSB7XG4gICAgICBwZXJmLm1lYXN1cmUobmFtZSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWFya3Moc3RhcnRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKGVuZFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWVhc3VyZXMobmFtZSk7XG4gICAgfTtcbiAgfVxufVxuXG4vKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGggUHJveHkgKi9cblxudmFyIGluaXRQcm94eTtcblxue1xuICB2YXIgYWxsb3dlZEdsb2JhbHMgPSBtYWtlTWFwKFxuICAgICdJbmZpbml0eSx1bmRlZmluZWQsTmFOLGlzRmluaXRlLGlzTmFOLCcgK1xuICAgICdwYXJzZUZsb2F0LHBhcnNlSW50LGRlY29kZVVSSSxkZWNvZGVVUklDb21wb25lbnQsZW5jb2RlVVJJLGVuY29kZVVSSUNvbXBvbmVudCwnICtcbiAgICAnTWF0aCxOdW1iZXIsRGF0ZSxBcnJheSxPYmplY3QsQm9vbGVhbixTdHJpbmcsUmVnRXhwLE1hcCxTZXQsSlNPTixJbnRsLCcgK1xuICAgICdyZXF1aXJlJyAvLyBmb3IgV2VicGFjay9Ccm93c2VyaWZ5XG4gICk7XG5cbiAgdmFyIHdhcm5Ob25QcmVzZW50ID0gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG4gICAgd2FybihcbiAgICAgIFwiUHJvcGVydHkgb3IgbWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBub3QgZGVmaW5lZCBvbiB0aGUgaW5zdGFuY2UgYnV0IFwiICtcbiAgICAgICdyZWZlcmVuY2VkIGR1cmluZyByZW5kZXIuIE1ha2Ugc3VyZSB0aGF0IHRoaXMgcHJvcGVydHkgaXMgcmVhY3RpdmUsICcgK1xuICAgICAgJ2VpdGhlciBpbiB0aGUgZGF0YSBvcHRpb24sIG9yIGZvciBjbGFzcy1iYXNlZCBjb21wb25lbnRzLCBieSAnICtcbiAgICAgICdpbml0aWFsaXppbmcgdGhlIHByb3BlcnR5LiAnICtcbiAgICAgICdTZWU6IGh0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL3JlYWN0aXZpdHkuaHRtbCNEZWNsYXJpbmctUmVhY3RpdmUtUHJvcGVydGllcy4nLFxuICAgICAgdGFyZ2V0XG4gICAgKTtcbiAgfTtcblxuICB2YXIgaGFzUHJveHkgPVxuICAgIHR5cGVvZiBQcm94eSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUHJveHkpO1xuXG4gIGlmIChoYXNQcm94eSkge1xuICAgIHZhciBpc0J1aWx0SW5Nb2RpZmllciA9IG1ha2VNYXAoJ3N0b3AscHJldmVudCxzZWxmLGN0cmwsc2hpZnQsYWx0LG1ldGEsZXhhY3QnKTtcbiAgICBjb25maWcua2V5Q29kZXMgPSBuZXcgUHJveHkoY29uZmlnLmtleUNvZGVzLCB7XG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0J1aWx0SW5Nb2RpZmllcihrZXkpKSB7XG4gICAgICAgICAgd2FybigoXCJBdm9pZCBvdmVyd3JpdGluZyBidWlsdC1pbiBtb2RpZmllciBpbiBjb25maWcua2V5Q29kZXM6IC5cIiArIGtleSkpO1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdmFyIGhhc0hhbmRsZXIgPSB7XG4gICAgaGFzOiBmdW5jdGlvbiBoYXMgKHRhcmdldCwga2V5KSB7XG4gICAgICB2YXIgaGFzID0ga2V5IGluIHRhcmdldDtcbiAgICAgIHZhciBpc0FsbG93ZWQgPSBhbGxvd2VkR2xvYmFscyhrZXkpIHx8IGtleS5jaGFyQXQoMCkgPT09ICdfJztcbiAgICAgIGlmICghaGFzICYmICFpc0FsbG93ZWQpIHtcbiAgICAgICAgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhcyB8fCAhaXNBbGxvd2VkXG4gICAgfVxuICB9O1xuXG4gIHZhciBnZXRIYW5kbGVyID0ge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0ICh0YXJnZXQsIGtleSkge1xuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmICEoa2V5IGluIHRhcmdldCkpIHtcbiAgICAgICAgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldFtrZXldXG4gICAgfVxuICB9O1xuXG4gIGluaXRQcm94eSA9IGZ1bmN0aW9uIGluaXRQcm94eSAodm0pIHtcbiAgICBpZiAoaGFzUHJveHkpIHtcbiAgICAgIC8vIGRldGVybWluZSB3aGljaCBwcm94eSBoYW5kbGVyIHRvIHVzZVxuICAgICAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcbiAgICAgIHZhciBoYW5kbGVycyA9IG9wdGlvbnMucmVuZGVyICYmIG9wdGlvbnMucmVuZGVyLl93aXRoU3RyaXBwZWRcbiAgICAgICAgPyBnZXRIYW5kbGVyXG4gICAgICAgIDogaGFzSGFuZGxlcjtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IG5ldyBQcm94eSh2bSwgaGFuZGxlcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgc2Vlbk9iamVjdHMgPSBuZXcgX1NldCgpO1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIGFuIG9iamVjdCB0byBldm9rZSBhbGwgY29udmVydGVkXG4gKiBnZXR0ZXJzLCBzbyB0aGF0IGV2ZXJ5IG5lc3RlZCBwcm9wZXJ0eSBpbnNpZGUgdGhlIG9iamVjdFxuICogaXMgY29sbGVjdGVkIGFzIGEgXCJkZWVwXCIgZGVwZW5kZW5jeS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2UgKHZhbCkge1xuICBfdHJhdmVyc2UodmFsLCBzZWVuT2JqZWN0cyk7XG4gIHNlZW5PYmplY3RzLmNsZWFyKCk7XG59XG5cbmZ1bmN0aW9uIF90cmF2ZXJzZSAodmFsLCBzZWVuKSB7XG4gIHZhciBpLCBrZXlzO1xuICB2YXIgaXNBID0gQXJyYXkuaXNBcnJheSh2YWwpO1xuICBpZiAoKCFpc0EgJiYgIWlzT2JqZWN0KHZhbCkpIHx8IE9iamVjdC5pc0Zyb3plbih2YWwpIHx8IHZhbCBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZhbC5fX29iX18pIHtcbiAgICB2YXIgZGVwSWQgPSB2YWwuX19vYl9fLmRlcC5pZDtcbiAgICBpZiAoc2Vlbi5oYXMoZGVwSWQpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgc2Vlbi5hZGQoZGVwSWQpO1xuICB9XG4gIGlmIChpc0EpIHtcbiAgICBpID0gdmFsLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxbaV0sIHNlZW4pOyB9XG4gIH0gZWxzZSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgaSA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHsgX3RyYXZlcnNlKHZhbFtrZXlzW2ldXSwgc2Vlbik7IH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIG5vcm1hbGl6ZUV2ZW50ID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciBwYXNzaXZlID0gbmFtZS5jaGFyQXQoMCkgPT09ICcmJztcbiAgbmFtZSA9IHBhc3NpdmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgdmFyIG9uY2UkJDEgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJ34nOyAvLyBQcmVmaXhlZCBsYXN0LCBjaGVja2VkIGZpcnN0XG4gIG5hbWUgPSBvbmNlJCQxID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHZhciBjYXB0dXJlID0gbmFtZS5jaGFyQXQoMCkgPT09ICchJztcbiAgbmFtZSA9IGNhcHR1cmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIG9uY2U6IG9uY2UkJDEsXG4gICAgY2FwdHVyZTogY2FwdHVyZSxcbiAgICBwYXNzaXZlOiBwYXNzaXZlXG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBjcmVhdGVGbkludm9rZXIgKGZucykge1xuICBmdW5jdGlvbiBpbnZva2VyICgpIHtcbiAgICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XG5cbiAgICB2YXIgZm5zID0gaW52b2tlci5mbnM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZm5zKSkge1xuICAgICAgdmFyIGNsb25lZCA9IGZucy5zbGljZSgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbG9uZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2xvbmVkW2ldLmFwcGx5KG51bGwsIGFyZ3VtZW50cyQxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmV0dXJuIGhhbmRsZXIgcmV0dXJuIHZhbHVlIGZvciBzaW5nbGUgaGFuZGxlcnNcbiAgICAgIHJldHVybiBmbnMuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICAgIH1cbiAgfVxuICBpbnZva2VyLmZucyA9IGZucztcbiAgcmV0dXJuIGludm9rZXJcbn1cblxuZnVuY3Rpb24gdXBkYXRlTGlzdGVuZXJzIChcbiAgb24sXG4gIG9sZE9uLFxuICBhZGQsXG4gIHJlbW92ZSQkMSxcbiAgdm1cbikge1xuICB2YXIgbmFtZSwgZGVmLCBjdXIsIG9sZCwgZXZlbnQ7XG4gIGZvciAobmFtZSBpbiBvbikge1xuICAgIGRlZiA9IGN1ciA9IG9uW25hbWVdO1xuICAgIG9sZCA9IG9sZE9uW25hbWVdO1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzVW5kZWYoY3VyKSkge1xuICAgICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJJbnZhbGlkIGhhbmRsZXIgZm9yIGV2ZW50IFxcXCJcIiArIChldmVudC5uYW1lKSArIFwiXFxcIjogZ290IFwiICsgU3RyaW5nKGN1ciksXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGQpKSB7XG4gICAgICBpZiAoaXNVbmRlZihjdXIuZm5zKSkge1xuICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZUZuSW52b2tlcihjdXIpO1xuICAgICAgfVxuICAgICAgYWRkKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQub25jZSwgZXZlbnQuY2FwdHVyZSwgZXZlbnQucGFzc2l2ZSwgZXZlbnQucGFyYW1zKTtcbiAgICB9IGVsc2UgaWYgKGN1ciAhPT0gb2xkKSB7XG4gICAgICBvbGQuZm5zID0gY3VyO1xuICAgICAgb25bbmFtZV0gPSBvbGQ7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBvbGRPbikge1xuICAgIGlmIChpc1VuZGVmKG9uW25hbWVdKSkge1xuICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICAgIHJlbW92ZSQkMShldmVudC5uYW1lLCBvbGRPbltuYW1lXSwgZXZlbnQuY2FwdHVyZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBtZXJnZVZOb2RlSG9vayAoZGVmLCBob29rS2V5LCBob29rKSB7XG4gIGlmIChkZWYgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIGRlZiA9IGRlZi5kYXRhLmhvb2sgfHwgKGRlZi5kYXRhLmhvb2sgPSB7fSk7XG4gIH1cbiAgdmFyIGludm9rZXI7XG4gIHZhciBvbGRIb29rID0gZGVmW2hvb2tLZXldO1xuXG4gIGZ1bmN0aW9uIHdyYXBwZWRIb29rICgpIHtcbiAgICBob29rLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgLy8gaW1wb3J0YW50OiByZW1vdmUgbWVyZ2VkIGhvb2sgdG8gZW5zdXJlIGl0J3MgY2FsbGVkIG9ubHkgb25jZVxuICAgIC8vIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrXG4gICAgcmVtb3ZlKGludm9rZXIuZm5zLCB3cmFwcGVkSG9vayk7XG4gIH1cblxuICBpZiAoaXNVbmRlZihvbGRIb29rKSkge1xuICAgIC8vIG5vIGV4aXN0aW5nIGhvb2tcbiAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFt3cmFwcGVkSG9va10pO1xuICB9IGVsc2Uge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc0RlZihvbGRIb29rLmZucykgJiYgaXNUcnVlKG9sZEhvb2subWVyZ2VkKSkge1xuICAgICAgLy8gYWxyZWFkeSBhIG1lcmdlZCBpbnZva2VyXG4gICAgICBpbnZva2VyID0gb2xkSG9vaztcbiAgICAgIGludm9rZXIuZm5zLnB1c2god3JhcHBlZEhvb2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGlzdGluZyBwbGFpbiBob29rXG4gICAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFtvbGRIb29rLCB3cmFwcGVkSG9va10pO1xuICAgIH1cbiAgfVxuXG4gIGludm9rZXIubWVyZ2VkID0gdHJ1ZTtcbiAgZGVmW2hvb2tLZXldID0gaW52b2tlcjtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEgKFxuICBkYXRhLFxuICBDdG9yLFxuICB0YWdcbikge1xuICAvLyB3ZSBhcmUgb25seSBleHRyYWN0aW5nIHJhdyB2YWx1ZXMgaGVyZS5cbiAgLy8gdmFsaWRhdGlvbiBhbmQgZGVmYXVsdCB2YWx1ZXMgYXJlIGhhbmRsZWQgaW4gdGhlIGNoaWxkXG4gIC8vIGNvbXBvbmVudCBpdHNlbGYuXG4gIHZhciBwcm9wT3B0aW9ucyA9IEN0b3Iub3B0aW9ucy5wcm9wcztcbiAgaWYgKGlzVW5kZWYocHJvcE9wdGlvbnMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgYXR0cnMgPSBkYXRhLmF0dHJzO1xuICB2YXIgcHJvcHMgPSBkYXRhLnByb3BzO1xuICBpZiAoaXNEZWYoYXR0cnMpIHx8IGlzRGVmKHByb3BzKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgdmFyIGFsdEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAge1xuICAgICAgICB2YXIga2V5SW5Mb3dlckNhc2UgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGtleSAhPT0ga2V5SW5Mb3dlckNhc2UgJiZcbiAgICAgICAgICBhdHRycyAmJiBoYXNPd24oYXR0cnMsIGtleUluTG93ZXJDYXNlKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aXAoXG4gICAgICAgICAgICBcIlByb3AgXFxcIlwiICsga2V5SW5Mb3dlckNhc2UgKyBcIlxcXCIgaXMgcGFzc2VkIHRvIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh0YWcgfHwgQ3RvcikpICsgXCIsIGJ1dCB0aGUgZGVjbGFyZWQgcHJvcCBuYW1lIGlzXCIgK1xuICAgICAgICAgICAgXCIgXFxcIlwiICsga2V5ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIGNhbWVsQ2FzZWQgXCIgK1xuICAgICAgICAgICAgXCJwcm9wcyBuZWVkIHRvIHVzZSB0aGVpciBrZWJhYi1jYXNlIGVxdWl2YWxlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIFwiICtcbiAgICAgICAgICAgIFwidGVtcGxhdGVzLiBZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcXFwiXCIgKyBhbHRLZXkgKyBcIlxcXCIgaW5zdGVhZCBvZiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjaGVja1Byb3AocmVzLCBwcm9wcywga2V5LCBhbHRLZXksIHRydWUpIHx8XG4gICAgICBjaGVja1Byb3AocmVzLCBhdHRycywga2V5LCBhbHRLZXksIGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBjaGVja1Byb3AgKFxuICByZXMsXG4gIGhhc2gsXG4gIGtleSxcbiAgYWx0S2V5LFxuICBwcmVzZXJ2ZVxuKSB7XG4gIGlmIChpc0RlZihoYXNoKSkge1xuICAgIGlmIChoYXNPd24oaGFzaCwga2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2tleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoaGFzT3duKGhhc2gsIGFsdEtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFthbHRLZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFthbHRLZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG4vLyBUaGUgdGVtcGxhdGUgY29tcGlsZXIgYXR0ZW1wdHMgdG8gbWluaW1pemUgdGhlIG5lZWQgZm9yIG5vcm1hbGl6YXRpb24gYnlcbi8vIHN0YXRpY2FsbHkgYW5hbHl6aW5nIHRoZSB0ZW1wbGF0ZSBhdCBjb21waWxlIHRpbWUuXG4vL1xuLy8gRm9yIHBsYWluIEhUTUwgbWFya3VwLCBub3JtYWxpemF0aW9uIGNhbiBiZSBjb21wbGV0ZWx5IHNraXBwZWQgYmVjYXVzZSB0aGVcbi8vIGdlbmVyYXRlZCByZW5kZXIgZnVuY3Rpb24gaXMgZ3VhcmFudGVlZCB0byByZXR1cm4gQXJyYXk8Vk5vZGU+LiBUaGVyZSBhcmVcbi8vIHR3byBjYXNlcyB3aGVyZSBleHRyYSBub3JtYWxpemF0aW9uIGlzIG5lZWRlZDpcblxuLy8gMS4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29tcG9uZW50cyAtIGJlY2F1c2UgYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxuLy8gbWF5IHJldHVybiBhbiBBcnJheSBpbnN0ZWFkIG9mIGEgc2luZ2xlIHJvb3QuIEluIHRoaXMgY2FzZSwganVzdCBhIHNpbXBsZVxuLy8gbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQgLSBpZiBhbnkgY2hpbGQgaXMgYW4gQXJyYXksIHdlIGZsYXR0ZW4gdGhlIHdob2xlXG4vLyB0aGluZyB3aXRoIEFycmF5LnByb3RvdHlwZS5jb25jYXQuIEl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgb25seSAxLWxldmVsIGRlZXBcbi8vIGJlY2F1c2UgZnVuY3Rpb25hbCBjb21wb25lbnRzIGFscmVhZHkgbm9ybWFsaXplIHRoZWlyIG93biBjaGlsZHJlbi5cbmZ1bmN0aW9uIHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW5baV0pKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgY2hpbGRyZW4pXG4gICAgfVxuICB9XG4gIHJldHVybiBjaGlsZHJlblxufVxuXG4vLyAyLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb25zdHJ1Y3RzIHRoYXQgYWx3YXlzIGdlbmVyYXRlZCBuZXN0ZWQgQXJyYXlzLFxuLy8gZS5nLiA8dGVtcGxhdGU+LCA8c2xvdD4sIHYtZm9yLCBvciB3aGVuIHRoZSBjaGlsZHJlbiBpcyBwcm92aWRlZCBieSB1c2VyXG4vLyB3aXRoIGhhbmQtd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zIC8gSlNYLiBJbiBzdWNoIGNhc2VzIGEgZnVsbCBub3JtYWxpemF0aW9uXG4vLyBpcyBuZWVkZWQgdG8gY2F0ZXIgdG8gYWxsIHBvc3NpYmxlIHR5cGVzIG9mIGNoaWxkcmVuIHZhbHVlcy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICByZXR1cm4gaXNQcmltaXRpdmUoY2hpbGRyZW4pXG4gICAgPyBbY3JlYXRlVGV4dFZOb2RlKGNoaWxkcmVuKV1cbiAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pXG4gICAgICA/IG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oY2hpbGRyZW4pXG4gICAgICA6IHVuZGVmaW5lZFxufVxuXG5mdW5jdGlvbiBpc1RleHROb2RlIChub2RlKSB7XG4gIHJldHVybiBpc0RlZihub2RlKSAmJiBpc0RlZihub2RlLnRleHQpICYmIGlzRmFsc2Uobm9kZS5pc0NvbW1lbnQpXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4gKGNoaWxkcmVuLCBuZXN0ZWRJbmRleCkge1xuICB2YXIgcmVzID0gW107XG4gIHZhciBpLCBjLCBsYXN0SW5kZXgsIGxhc3Q7XG4gIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGMgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoaXNVbmRlZihjKSB8fCB0eXBlb2YgYyA9PT0gJ2Jvb2xlYW4nKSB7IGNvbnRpbnVlIH1cbiAgICBsYXN0SW5kZXggPSByZXMubGVuZ3RoIC0gMTtcbiAgICBsYXN0ID0gcmVzW2xhc3RJbmRleF07XG4gICAgLy8gIG5lc3RlZFxuICAgIGlmIChBcnJheS5pc0FycmF5KGMpKSB7XG4gICAgICBpZiAoYy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGMgPSBub3JtYWxpemVBcnJheUNoaWxkcmVuKGMsICgobmVzdGVkSW5kZXggfHwgJycpICsgXCJfXCIgKyBpKSk7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgaWYgKGlzVGV4dE5vZGUoY1swXSkgJiYgaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIChjWzBdKS50ZXh0KTtcbiAgICAgICAgICBjLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2guYXBwbHkocmVzLCBjKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKGMpKSB7XG4gICAgICBpZiAoaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIC8vIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciBTU1IgaHlkcmF0aW9uIGJlY2F1c2UgdGV4dCBub2RlcyBhcmVcbiAgICAgICAgLy8gZXNzZW50aWFsbHkgbWVyZ2VkIHdoZW4gcmVuZGVyZWQgdG8gSFRNTCBzdHJpbmdzXG4gICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMpO1xuICAgICAgfSBlbHNlIGlmIChjICE9PSAnJykge1xuICAgICAgICAvLyBjb252ZXJ0IHByaW1pdGl2ZSB0byB2bm9kZVxuICAgICAgICByZXMucHVzaChjcmVhdGVUZXh0Vk5vZGUoYykpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNUZXh0Tm9kZShjKSAmJiBpc1RleHROb2RlKGxhc3QpKSB7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYy50ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlZmF1bHQga2V5IGZvciBuZXN0ZWQgYXJyYXkgY2hpbGRyZW4gKGxpa2VseSBnZW5lcmF0ZWQgYnkgdi1mb3IpXG4gICAgICAgIGlmIChpc1RydWUoY2hpbGRyZW4uX2lzVkxpc3QpICYmXG4gICAgICAgICAgaXNEZWYoYy50YWcpICYmXG4gICAgICAgICAgaXNVbmRlZihjLmtleSkgJiZcbiAgICAgICAgICBpc0RlZihuZXN0ZWRJbmRleCkpIHtcbiAgICAgICAgICBjLmtleSA9IFwiX192bGlzdFwiICsgbmVzdGVkSW5kZXggKyBcIl9cIiArIGkgKyBcIl9fXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2goYyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVuc3VyZUN0b3IgKGNvbXAsIGJhc2UpIHtcbiAgaWYgKFxuICAgIGNvbXAuX19lc01vZHVsZSB8fFxuICAgIChoYXNTeW1ib2wgJiYgY29tcFtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnTW9kdWxlJylcbiAgKSB7XG4gICAgY29tcCA9IGNvbXAuZGVmYXVsdDtcbiAgfVxuICByZXR1cm4gaXNPYmplY3QoY29tcClcbiAgICA/IGJhc2UuZXh0ZW5kKGNvbXApXG4gICAgOiBjb21wXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIgKFxuICBmYWN0b3J5LFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlbixcbiAgdGFnXG4pIHtcbiAgdmFyIG5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gIG5vZGUuYXN5bmNGYWN0b3J5ID0gZmFjdG9yeTtcbiAgbm9kZS5hc3luY01ldGEgPSB7IGRhdGE6IGRhdGEsIGNvbnRleHQ6IGNvbnRleHQsIGNoaWxkcmVuOiBjaGlsZHJlbiwgdGFnOiB0YWcgfTtcbiAgcmV0dXJuIG5vZGVcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUFzeW5jQ29tcG9uZW50IChcbiAgZmFjdG9yeSxcbiAgYmFzZUN0b3IsXG4gIGNvbnRleHRcbikge1xuICBpZiAoaXNUcnVlKGZhY3RvcnkuZXJyb3IpICYmIGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuICAgIHJldHVybiBmYWN0b3J5LmVycm9yQ29tcFxuICB9XG5cbiAgaWYgKGlzRGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkucmVzb2x2ZWRcbiAgfVxuXG4gIGlmIChpc1RydWUoZmFjdG9yeS5sb2FkaW5nKSAmJiBpc0RlZihmYWN0b3J5LmxvYWRpbmdDb21wKSkge1xuICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmdDb21wXG4gIH1cblxuICBpZiAoaXNEZWYoZmFjdG9yeS5jb250ZXh0cykpIHtcbiAgICAvLyBhbHJlYWR5IHBlbmRpbmdcbiAgICBmYWN0b3J5LmNvbnRleHRzLnB1c2goY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvbnRleHRzID0gZmFjdG9yeS5jb250ZXh0cyA9IFtjb250ZXh0XTtcbiAgICB2YXIgc3luYyA9IHRydWU7XG5cbiAgICB2YXIgZm9yY2VSZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNvbnRleHRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjb250ZXh0c1tpXS4kZm9yY2VVcGRhdGUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHJlc29sdmUgPSBvbmNlKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIC8vIGNhY2hlIHJlc29sdmVkXG4gICAgICBmYWN0b3J5LnJlc29sdmVkID0gZW5zdXJlQ3RvcihyZXMsIGJhc2VDdG9yKTtcbiAgICAgIC8vIGludm9rZSBjYWxsYmFja3Mgb25seSBpZiB0aGlzIGlzIG5vdCBhIHN5bmNocm9ub3VzIHJlc29sdmVcbiAgICAgIC8vIChhc3luYyByZXNvbHZlcyBhcmUgc2hpbW1lZCBhcyBzeW5jaHJvbm91cyBkdXJpbmcgU1NSKVxuICAgICAgaWYgKCFzeW5jKSB7XG4gICAgICAgIGZvcmNlUmVuZGVyKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgcmVqZWN0ID0gb25jZShmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkZhaWxlZCB0byByZXNvbHZlIGFzeW5jIGNvbXBvbmVudDogXCIgKyAoU3RyaW5nKGZhY3RvcnkpKSArXG4gICAgICAgIChyZWFzb24gPyAoXCJcXG5SZWFzb246IFwiICsgcmVhc29uKSA6ICcnKVxuICAgICAgKTtcbiAgICAgIGlmIChpc0RlZihmYWN0b3J5LmVycm9yQ29tcCkpIHtcbiAgICAgICAgZmFjdG9yeS5lcnJvciA9IHRydWU7XG4gICAgICAgIGZvcmNlUmVuZGVyKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgcmVzID0gZmFjdG9yeShyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgaWYgKGlzT2JqZWN0KHJlcykpIHtcbiAgICAgIGlmICh0eXBlb2YgcmVzLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gKCkgPT4gUHJvbWlzZVxuICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICAgIHJlcy50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYocmVzLmNvbXBvbmVudCkgJiYgdHlwZW9mIHJlcy5jb21wb25lbnQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXMuY29tcG9uZW50LnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcblxuICAgICAgICBpZiAoaXNEZWYocmVzLmVycm9yKSkge1xuICAgICAgICAgIGZhY3RvcnkuZXJyb3JDb21wID0gZW5zdXJlQ3RvcihyZXMuZXJyb3IsIGJhc2VDdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihyZXMubG9hZGluZykpIHtcbiAgICAgICAgICBmYWN0b3J5LmxvYWRpbmdDb21wID0gZW5zdXJlQ3RvcihyZXMubG9hZGluZywgYmFzZUN0b3IpO1xuICAgICAgICAgIGlmIChyZXMuZGVsYXkgPT09IDApIHtcbiAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSAmJiBpc1VuZGVmKGZhY3RvcnkuZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3JjZVJlbmRlcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCByZXMuZGVsYXkgfHwgMjAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWYocmVzLnRpbWVvdXQpKSB7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgICAgXCJ0aW1lb3V0IChcIiArIChyZXMudGltZW91dCkgKyBcIm1zKVwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgcmVzLnRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3luYyA9IGZhbHNlO1xuICAgIC8vIHJldHVybiBpbiBjYXNlIHJlc29sdmVkIHN5bmNocm9ub3VzbHlcbiAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nXG4gICAgICA/IGZhY3RvcnkubG9hZGluZ0NvbXBcbiAgICAgIDogZmFjdG9yeS5yZXNvbHZlZFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpc0FzeW5jUGxhY2Vob2xkZXIgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuaXNDb21tZW50ICYmIG5vZGUuYXN5bmNGYWN0b3J5XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZXRGaXJzdENvbXBvbmVudENoaWxkIChjaGlsZHJlbikge1xuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IGNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGlzRGVmKGMpICYmIChpc0RlZihjLmNvbXBvbmVudE9wdGlvbnMpIHx8IGlzQXN5bmNQbGFjZWhvbGRlcihjKSkpIHtcbiAgICAgICAgcmV0dXJuIGNcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0RXZlbnRzICh2bSkge1xuICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdm0uX2hhc0hvb2tFdmVudCA9IGZhbHNlO1xuICAvLyBpbml0IHBhcmVudCBhdHRhY2hlZCBldmVudHNcbiAgdmFyIGxpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIGlmIChsaXN0ZW5lcnMpIHtcbiAgICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycyk7XG4gIH1cbn1cblxudmFyIHRhcmdldDtcblxuZnVuY3Rpb24gYWRkIChldmVudCwgZm4sIG9uY2UpIHtcbiAgaWYgKG9uY2UpIHtcbiAgICB0YXJnZXQuJG9uY2UoZXZlbnQsIGZuKTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQuJG9uKGV2ZW50LCBmbik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlJDEgKGV2ZW50LCBmbikge1xuICB0YXJnZXQuJG9mZihldmVudCwgZm4pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnMgKFxuICB2bSxcbiAgbGlzdGVuZXJzLFxuICBvbGRMaXN0ZW5lcnNcbikge1xuICB0YXJnZXQgPSB2bTtcbiAgdXBkYXRlTGlzdGVuZXJzKGxpc3RlbmVycywgb2xkTGlzdGVuZXJzIHx8IHt9LCBhZGQsIHJlbW92ZSQxLCB2bSk7XG4gIHRhcmdldCA9IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZXZlbnRzTWl4aW4gKFZ1ZSkge1xuICB2YXIgaG9va1JFID0gL15ob29rOi87XG4gIFZ1ZS5wcm90b3R5cGUuJG9uID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMkMS4kb24oZXZlbnRbaV0sIGZuKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgKHZtLl9ldmVudHNbZXZlbnRdIHx8ICh2bS5fZXZlbnRzW2V2ZW50XSA9IFtdKSkucHVzaChmbik7XG4gICAgICAvLyBvcHRpbWl6ZSBob29rOmV2ZW50IGNvc3QgYnkgdXNpbmcgYSBib29sZWFuIGZsYWcgbWFya2VkIGF0IHJlZ2lzdHJhdGlvblxuICAgICAgLy8gaW5zdGVhZCBvZiBhIGhhc2ggbG9va3VwXG4gICAgICBpZiAoaG9va1JFLnRlc3QoZXZlbnQpKSB7XG4gICAgICAgIHZtLl9oYXNIb29rRXZlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgZnVuY3Rpb24gb24gKCkge1xuICAgICAgdm0uJG9mZihldmVudCwgb24pO1xuICAgICAgZm4uYXBwbHkodm0sIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIG9uLmZuID0gZm47XG4gICAgdm0uJG9uKGV2ZW50LCBvbik7XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kb2ZmID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHZtID0gdGhpcztcbiAgICAvLyBhbGxcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIGFycmF5IG9mIGV2ZW50c1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcyQxLiRvZmYoZXZlbnRbaV0sIGZuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBldmVudFxuICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoIWNicykge1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIGlmICghZm4pIHtcbiAgICAgIHZtLl9ldmVudHNbZXZlbnRdID0gbnVsbDtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICBpZiAoZm4pIHtcbiAgICAgIC8vIHNwZWNpZmljIGhhbmRsZXJcbiAgICAgIHZhciBjYjtcbiAgICAgIHZhciBpJDEgPSBjYnMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGkkMS0tKSB7XG4gICAgICAgIGNiID0gY2JzW2kkMV07XG4gICAgICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICAgICAgY2JzLnNwbGljZShpJDEsIDEpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAge1xuICAgICAgdmFyIGxvd2VyQ2FzZUV2ZW50ID0gZXZlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChsb3dlckNhc2VFdmVudCAhPT0gZXZlbnQgJiYgdm0uX2V2ZW50c1tsb3dlckNhc2VFdmVudF0pIHtcbiAgICAgICAgdGlwKFxuICAgICAgICAgIFwiRXZlbnQgXFxcIlwiICsgbG93ZXJDYXNlRXZlbnQgKyBcIlxcXCIgaXMgZW1pdHRlZCBpbiBjb21wb25lbnQgXCIgK1xuICAgICAgICAgIChmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgKyBcIiBidXQgdGhlIGhhbmRsZXIgaXMgcmVnaXN0ZXJlZCBmb3IgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuIFwiICtcbiAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIHlvdSBjYW5ub3QgdXNlIFwiICtcbiAgICAgICAgICBcInYtb24gdG8gbGlzdGVuIHRvIGNhbWVsQ2FzZSBldmVudHMgd2hlbiB1c2luZyBpbi1ET00gdGVtcGxhdGVzLiBcIiArXG4gICAgICAgICAgXCJZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcXFwiXCIgKyAoaHlwaGVuYXRlKGV2ZW50KSkgKyBcIlxcXCIgaW5zdGVhZCBvZiBcXFwiXCIgKyBldmVudCArIFwiXFxcIi5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG4gICAgaWYgKGNicykge1xuICAgICAgY2JzID0gY2JzLmxlbmd0aCA+IDEgPyB0b0FycmF5KGNicykgOiBjYnM7XG4gICAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNic1tpXS5hcHBseSh2bSwgYXJncyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKFwiZXZlbnQgaGFuZGxlciBmb3IgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCJcIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xufVxuXG4vKiAgKi9cblxuXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyByYXcgY2hpbGRyZW4gVk5vZGVzIGludG8gYSBzbG90IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVNsb3RzIChcbiAgY2hpbGRyZW4sXG4gIGNvbnRleHRcbikge1xuICB2YXIgc2xvdHMgPSB7fTtcbiAgaWYgKCFjaGlsZHJlbikge1xuICAgIHJldHVybiBzbG90c1xuICB9XG4gIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgdmFyIGRhdGEgPSBjaGlsZC5kYXRhO1xuICAgIC8vIHJlbW92ZSBzbG90IGF0dHJpYnV0ZSBpZiB0aGUgbm9kZSBpcyByZXNvbHZlZCBhcyBhIFZ1ZSBzbG90IG5vZGVcbiAgICBpZiAoZGF0YSAmJiBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMuc2xvdCkge1xuICAgICAgZGVsZXRlIGRhdGEuYXR0cnMuc2xvdDtcbiAgICB9XG4gICAgLy8gbmFtZWQgc2xvdHMgc2hvdWxkIG9ubHkgYmUgcmVzcGVjdGVkIGlmIHRoZSB2bm9kZSB3YXMgcmVuZGVyZWQgaW4gdGhlXG4gICAgLy8gc2FtZSBjb250ZXh0LlxuICAgIGlmICgoY2hpbGQuY29udGV4dCA9PT0gY29udGV4dCB8fCBjaGlsZC5mbkNvbnRleHQgPT09IGNvbnRleHQpICYmXG4gICAgICBkYXRhICYmIGRhdGEuc2xvdCAhPSBudWxsXG4gICAgKSB7XG4gICAgICB2YXIgbmFtZSA9IGRhdGEuc2xvdDtcbiAgICAgIHZhciBzbG90ID0gKHNsb3RzW25hbWVdIHx8IChzbG90c1tuYW1lXSA9IFtdKSk7XG4gICAgICBpZiAoY2hpbGQudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgIHNsb3QucHVzaC5hcHBseShzbG90LCBjaGlsZC5jaGlsZHJlbiB8fCBbXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbG90LnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAoc2xvdHMuZGVmYXVsdCB8fCAoc2xvdHMuZGVmYXVsdCA9IFtdKSkucHVzaChjaGlsZCk7XG4gICAgfVxuICB9XG4gIC8vIGlnbm9yZSBzbG90cyB0aGF0IGNvbnRhaW5zIG9ubHkgd2hpdGVzcGFjZVxuICBmb3IgKHZhciBuYW1lJDEgaW4gc2xvdHMpIHtcbiAgICBpZiAoc2xvdHNbbmFtZSQxXS5ldmVyeShpc1doaXRlc3BhY2UpKSB7XG4gICAgICBkZWxldGUgc2xvdHNbbmFtZSQxXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNsb3RzXG59XG5cbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZSAobm9kZSkge1xuICByZXR1cm4gKG5vZGUuaXNDb21tZW50ICYmICFub2RlLmFzeW5jRmFjdG9yeSkgfHwgbm9kZS50ZXh0ID09PSAnICdcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVNjb3BlZFNsb3RzIChcbiAgZm5zLCAvLyBzZWUgZmxvdy92bm9kZVxuICByZXNcbikge1xuICByZXMgPSByZXMgfHwge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZm5zW2ldKSkge1xuICAgICAgcmVzb2x2ZVNjb3BlZFNsb3RzKGZuc1tpXSwgcmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzW2Zuc1tpXS5rZXldID0gZm5zW2ldLmZuO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgYWN0aXZlSW5zdGFuY2UgPSBudWxsO1xudmFyIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBpbml0TGlmZWN5Y2xlICh2bSkge1xuICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuXG4gIC8vIGxvY2F0ZSBmaXJzdCBub24tYWJzdHJhY3QgcGFyZW50XG4gIHZhciBwYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgaWYgKHBhcmVudCAmJiAhb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHdoaWxlIChwYXJlbnQuJG9wdGlvbnMuYWJzdHJhY3QgJiYgcGFyZW50LiRwYXJlbnQpIHtcbiAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xuICAgIH1cbiAgICBwYXJlbnQuJGNoaWxkcmVuLnB1c2godm0pO1xuICB9XG5cbiAgdm0uJHBhcmVudCA9IHBhcmVudDtcbiAgdm0uJHJvb3QgPSBwYXJlbnQgPyBwYXJlbnQuJHJvb3QgOiB2bTtcblxuICB2bS4kY2hpbGRyZW4gPSBbXTtcbiAgdm0uJHJlZnMgPSB7fTtcblxuICB2bS5fd2F0Y2hlciA9IG51bGw7XG4gIHZtLl9pbmFjdGl2ZSA9IG51bGw7XG4gIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICB2bS5faXNNb3VudGVkID0gZmFsc2U7XG4gIHZtLl9pc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBsaWZlY3ljbGVNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX2lzTW91bnRlZCkge1xuICAgICAgY2FsbEhvb2sodm0sICdiZWZvcmVVcGRhdGUnKTtcbiAgICB9XG4gICAgdmFyIHByZXZFbCA9IHZtLiRlbDtcbiAgICB2YXIgcHJldlZub2RlID0gdm0uX3Zub2RlO1xuICAgIHZhciBwcmV2QWN0aXZlSW5zdGFuY2UgPSBhY3RpdmVJbnN0YW5jZTtcbiAgICBhY3RpdmVJbnN0YW5jZSA9IHZtO1xuICAgIHZtLl92bm9kZSA9IHZub2RlO1xuICAgIC8vIFZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fIGlzIGluamVjdGVkIGluIGVudHJ5IHBvaW50c1xuICAgIC8vIGJhc2VkIG9uIHRoZSByZW5kZXJpbmcgYmFja2VuZCB1c2VkLlxuICAgIGlmICghcHJldlZub2RlKSB7XG4gICAgICAvLyBpbml0aWFsIHJlbmRlclxuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKFxuICAgICAgICB2bS4kZWwsIHZub2RlLCBoeWRyYXRpbmcsIGZhbHNlIC8qIHJlbW92ZU9ubHkgKi8sXG4gICAgICAgIHZtLiRvcHRpb25zLl9wYXJlbnRFbG0sXG4gICAgICAgIHZtLiRvcHRpb25zLl9yZWZFbG1cbiAgICAgICk7XG4gICAgICAvLyBubyBuZWVkIGZvciB0aGUgcmVmIG5vZGVzIGFmdGVyIGluaXRpYWwgcGF0Y2hcbiAgICAgIC8vIHRoaXMgcHJldmVudHMga2VlcGluZyBhIGRldGFjaGVkIERPTSB0cmVlIGluIG1lbW9yeSAoIzU4NTEpXG4gICAgICB2bS4kb3B0aW9ucy5fcGFyZW50RWxtID0gdm0uJG9wdGlvbnMuX3JlZkVsbSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVwZGF0ZXNcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhwcmV2Vm5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgYWN0aXZlSW5zdGFuY2UgPSBwcmV2QWN0aXZlSW5zdGFuY2U7XG4gICAgLy8gdXBkYXRlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHByZXZFbCkge1xuICAgICAgcHJldkVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IHZtO1xuICAgIH1cbiAgICAvLyBpZiBwYXJlbnQgaXMgYW4gSE9DLCB1cGRhdGUgaXRzICRlbCBhcyB3ZWxsXG4gICAgaWYgKHZtLiR2bm9kZSAmJiB2bS4kcGFyZW50ICYmIHZtLiR2bm9kZSA9PT0gdm0uJHBhcmVudC5fdm5vZGUpIHtcbiAgICAgIHZtLiRwYXJlbnQuJGVsID0gdm0uJGVsO1xuICAgIH1cbiAgICAvLyB1cGRhdGVkIGhvb2sgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgdG8gZW5zdXJlIHRoYXQgY2hpbGRyZW4gYXJlXG4gICAgLy8gdXBkYXRlZCBpbiBhIHBhcmVudCdzIHVwZGF0ZWQgaG9vay5cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRmb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudXBkYXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZURlc3Ryb3knKTtcbiAgICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSBwYXJlbnRcbiAgICB2YXIgcGFyZW50ID0gdm0uJHBhcmVudDtcbiAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuX2lzQmVpbmdEZXN0cm95ZWQgJiYgIXZtLiRvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgICByZW1vdmUocGFyZW50LiRjaGlsZHJlbiwgdm0pO1xuICAgIH1cbiAgICAvLyB0ZWFyZG93biB3YXRjaGVyc1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gICAgdmFyIGkgPSB2bS5fd2F0Y2hlcnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZtLl93YXRjaGVyc1tpXS50ZWFyZG93bigpO1xuICAgIH1cbiAgICAvLyByZW1vdmUgcmVmZXJlbmNlIGZyb20gZGF0YSBvYlxuICAgIC8vIGZyb3plbiBvYmplY3QgbWF5IG5vdCBoYXZlIG9ic2VydmVyLlxuICAgIGlmICh2bS5fZGF0YS5fX29iX18pIHtcbiAgICAgIHZtLl9kYXRhLl9fb2JfXy52bUNvdW50LS07XG4gICAgfVxuICAgIC8vIGNhbGwgdGhlIGxhc3QgaG9vay4uLlxuICAgIHZtLl9pc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gaW52b2tlIGRlc3Ryb3kgaG9va3Mgb24gY3VycmVudCByZW5kZXJlZCB0cmVlXG4gICAgdm0uX19wYXRjaF9fKHZtLl92bm9kZSwgbnVsbCk7XG4gICAgLy8gZmlyZSBkZXN0cm95ZWQgaG9va1xuICAgIGNhbGxIb29rKHZtLCAnZGVzdHJveWVkJyk7XG4gICAgLy8gdHVybiBvZmYgYWxsIGluc3RhbmNlIGxpc3RlbmVycy5cbiAgICB2bS4kb2ZmKCk7XG4gICAgLy8gcmVtb3ZlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICAvLyByZWxlYXNlIGNpcmN1bGFyIHJlZmVyZW5jZSAoIzY3NTkpXG4gICAgaWYgKHZtLiR2bm9kZSkge1xuICAgICAgdm0uJHZub2RlLnBhcmVudCA9IG51bGw7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBtb3VudENvbXBvbmVudCAoXG4gIHZtLFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgdm0uJGVsID0gZWw7XG4gIGlmICghdm0uJG9wdGlvbnMucmVuZGVyKSB7XG4gICAgdm0uJG9wdGlvbnMucmVuZGVyID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgICB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICgodm0uJG9wdGlvbnMudGVtcGxhdGUgJiYgdm0uJG9wdGlvbnMudGVtcGxhdGUuY2hhckF0KDApICE9PSAnIycpIHx8XG4gICAgICAgIHZtLiRvcHRpb25zLmVsIHx8IGVsKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBhcmUgdXNpbmcgdGhlIHJ1bnRpbWUtb25seSBidWlsZCBvZiBWdWUgd2hlcmUgdGhlIHRlbXBsYXRlICcgK1xuICAgICAgICAgICdjb21waWxlciBpcyBub3QgYXZhaWxhYmxlLiBFaXRoZXIgcHJlLWNvbXBpbGUgdGhlIHRlbXBsYXRlcyBpbnRvICcgK1xuICAgICAgICAgICdyZW5kZXIgZnVuY3Rpb25zLCBvciB1c2UgdGhlIGNvbXBpbGVyLWluY2x1ZGVkIGJ1aWxkLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ0ZhaWxlZCB0byBtb3VudCBjb21wb25lbnQ6IHRlbXBsYXRlIG9yIHJlbmRlciBmdW5jdGlvbiBub3QgZGVmaW5lZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNhbGxIb29rKHZtLCAnYmVmb3JlTW91bnQnKTtcblxuICB2YXIgdXBkYXRlQ29tcG9uZW50O1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG5hbWUgPSB2bS5fbmFtZTtcbiAgICAgIHZhciBpZCA9IHZtLl91aWQ7XG4gICAgICB2YXIgc3RhcnRUYWcgPSBcInZ1ZS1wZXJmLXN0YXJ0OlwiICsgaWQ7XG4gICAgICB2YXIgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyBpZDtcblxuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICB2YXIgdm5vZGUgPSB2bS5fcmVuZGVyKCk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChcInZ1ZSBcIiArIG5hbWUgKyBcIiByZW5kZXJcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgIHZtLl91cGRhdGUodm5vZGUsIGh5ZHJhdGluZyk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChcInZ1ZSBcIiArIG5hbWUgKyBcIiBwYXRjaFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2bS5fdXBkYXRlKHZtLl9yZW5kZXIoKSwgaHlkcmF0aW5nKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gd2Ugc2V0IHRoaXMgdG8gdm0uX3dhdGNoZXIgaW5zaWRlIHRoZSB3YXRjaGVyJ3MgY29uc3RydWN0b3JcbiAgLy8gc2luY2UgdGhlIHdhdGNoZXIncyBpbml0aWFsIHBhdGNoIG1heSBjYWxsICRmb3JjZVVwZGF0ZSAoZS5nLiBpbnNpZGUgY2hpbGRcbiAgLy8gY29tcG9uZW50J3MgbW91bnRlZCBob29rKSwgd2hpY2ggcmVsaWVzIG9uIHZtLl93YXRjaGVyIGJlaW5nIGFscmVhZHkgZGVmaW5lZFxuICBuZXcgV2F0Y2hlcih2bSwgdXBkYXRlQ29tcG9uZW50LCBub29wLCBudWxsLCB0cnVlIC8qIGlzUmVuZGVyV2F0Y2hlciAqLyk7XG4gIGh5ZHJhdGluZyA9IGZhbHNlO1xuXG4gIC8vIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UsIGNhbGwgbW91bnRlZCBvbiBzZWxmXG4gIC8vIG1vdW50ZWQgaXMgY2FsbGVkIGZvciByZW5kZXItY3JlYXRlZCBjaGlsZCBjb21wb25lbnRzIGluIGl0cyBpbnNlcnRlZCBob29rXG4gIGlmICh2bS4kdm5vZGUgPT0gbnVsbCkge1xuICAgIHZtLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgIGNhbGxIb29rKHZtLCAnbW91bnRlZCcpO1xuICB9XG4gIHJldHVybiB2bVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDaGlsZENvbXBvbmVudCAoXG4gIHZtLFxuICBwcm9wc0RhdGEsXG4gIGxpc3RlbmVycyxcbiAgcGFyZW50Vm5vZGUsXG4gIHJlbmRlckNoaWxkcmVuXG4pIHtcbiAge1xuICAgIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IHRydWU7XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgd2hldGhlciBjb21wb25lbnQgaGFzIHNsb3QgY2hpbGRyZW5cbiAgLy8gd2UgbmVlZCB0byBkbyB0aGlzIGJlZm9yZSBvdmVyd3JpdGluZyAkb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW5cbiAgdmFyIGhhc0NoaWxkcmVuID0gISEoXG4gICAgcmVuZGVyQ2hpbGRyZW4gfHwgICAgICAgICAgICAgICAvLyBoYXMgbmV3IHN0YXRpYyBzbG90c1xuICAgIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiB8fCAgLy8gaGFzIG9sZCBzdGF0aWMgc2xvdHNcbiAgICBwYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzIHx8IC8vIGhhcyBuZXcgc2NvcGVkIHNsb3RzXG4gICAgdm0uJHNjb3BlZFNsb3RzICE9PSBlbXB0eU9iamVjdCAvLyBoYXMgb2xkIHNjb3BlZCBzbG90c1xuICApO1xuXG4gIHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZSA9IHBhcmVudFZub2RlO1xuICB2bS4kdm5vZGUgPSBwYXJlbnRWbm9kZTsgLy8gdXBkYXRlIHZtJ3MgcGxhY2Vob2xkZXIgbm9kZSB3aXRob3V0IHJlLXJlbmRlclxuXG4gIGlmICh2bS5fdm5vZGUpIHsgLy8gdXBkYXRlIGNoaWxkIHRyZWUncyBwYXJlbnRcbiAgICB2bS5fdm5vZGUucGFyZW50ID0gcGFyZW50Vm5vZGU7XG4gIH1cbiAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuID0gcmVuZGVyQ2hpbGRyZW47XG5cbiAgLy8gdXBkYXRlICRhdHRycyBhbmQgJGxpc3RlbmVycyBoYXNoXG4gIC8vIHRoZXNlIGFyZSBhbHNvIHJlYWN0aXZlIHNvIHRoZXkgbWF5IHRyaWdnZXIgY2hpbGQgdXBkYXRlIGlmIHRoZSBjaGlsZFxuICAvLyB1c2VkIHRoZW0gZHVyaW5nIHJlbmRlclxuICB2bS4kYXR0cnMgPSBwYXJlbnRWbm9kZS5kYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0O1xuICB2bS4kbGlzdGVuZXJzID0gbGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0O1xuXG4gIC8vIHVwZGF0ZSBwcm9wc1xuICBpZiAocHJvcHNEYXRhICYmIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKGZhbHNlKTtcbiAgICB2YXIgcHJvcHMgPSB2bS5fcHJvcHM7XG4gICAgdmFyIHByb3BLZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzIHx8IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wS2V5c1tpXTtcbiAgICAgIHZhciBwcm9wT3B0aW9ucyA9IHZtLiRvcHRpb25zLnByb3BzOyAvLyB3dGYgZmxvdz9cbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgfVxuICAgIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbiAgICAvLyBrZWVwIGEgY29weSBvZiByYXcgcHJvcHNEYXRhXG4gICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhID0gcHJvcHNEYXRhO1xuICB9XG5cbiAgLy8gdXBkYXRlIGxpc3RlbmVyc1xuICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3Q7XG4gIHZhciBvbGRMaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycywgb2xkTGlzdGVuZXJzKTtcblxuICAvLyByZXNvbHZlIHNsb3RzICsgZm9yY2UgdXBkYXRlIGlmIGhhcyBjaGlsZHJlblxuICBpZiAoaGFzQ2hpbGRyZW4pIHtcbiAgICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMocmVuZGVyQ2hpbGRyZW4sIHBhcmVudFZub2RlLmNvbnRleHQpO1xuICAgIHZtLiRmb3JjZVVwZGF0ZSgpO1xuICB9XG5cbiAge1xuICAgIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzSW5JbmFjdGl2ZVRyZWUgKHZtKSB7XG4gIHdoaWxlICh2bSAmJiAodm0gPSB2bS4kcGFyZW50KSkge1xuICAgIGlmICh2bS5faW5hY3RpdmUpIHsgcmV0dXJuIHRydWUgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfSBlbHNlIGlmICh2bS5fZGlyZWN0SW5hY3RpdmUpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodm0uX2luYWN0aXZlIHx8IHZtLl9pbmFjdGl2ZSA9PT0gbnVsbCkge1xuICAgIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnYWN0aXZhdGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSB0cnVlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG4gIGlmICghdm0uX2luYWN0aXZlKSB7XG4gICAgdm0uX2luYWN0aXZlID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnZGVhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayAodm0sIGhvb2spIHtcbiAgLy8gIzc1NzMgZGlzYWJsZSBkZXAgY29sbGVjdGlvbiB3aGVuIGludm9raW5nIGxpZmVjeWNsZSBob29rc1xuICBwdXNoVGFyZ2V0KCk7XG4gIHZhciBoYW5kbGVycyA9IHZtLiRvcHRpb25zW2hvb2tdO1xuICBpZiAoaGFuZGxlcnMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaGFuZGxlcnNbaV0uY2FsbCh2bSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCAoaG9vayArIFwiIGhvb2tcIikpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAodm0uX2hhc0hvb2tFdmVudCkge1xuICAgIHZtLiRlbWl0KCdob29rOicgKyBob29rKTtcbiAgfVxuICBwb3BUYXJnZXQoKTtcbn1cblxuLyogICovXG5cblxudmFyIE1BWF9VUERBVEVfQ09VTlQgPSAxMDA7XG5cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGFjdGl2YXRlZENoaWxkcmVuID0gW107XG52YXIgaGFzID0ge307XG52YXIgY2lyY3VsYXIgPSB7fTtcbnZhciB3YWl0aW5nID0gZmFsc2U7XG52YXIgZmx1c2hpbmcgPSBmYWxzZTtcbnZhciBpbmRleCA9IDA7XG5cbi8qKlxuICogUmVzZXQgdGhlIHNjaGVkdWxlcidzIHN0YXRlLlxuICovXG5mdW5jdGlvbiByZXNldFNjaGVkdWxlclN0YXRlICgpIHtcbiAgaW5kZXggPSBxdWV1ZS5sZW5ndGggPSBhY3RpdmF0ZWRDaGlsZHJlbi5sZW5ndGggPSAwO1xuICBoYXMgPSB7fTtcbiAge1xuICAgIGNpcmN1bGFyID0ge307XG4gIH1cbiAgd2FpdGluZyA9IGZsdXNoaW5nID0gZmFsc2U7XG59XG5cbi8qKlxuICogRmx1c2ggYm90aCBxdWV1ZXMgYW5kIHJ1biB0aGUgd2F0Y2hlcnMuXG4gKi9cbmZ1bmN0aW9uIGZsdXNoU2NoZWR1bGVyUXVldWUgKCkge1xuICBmbHVzaGluZyA9IHRydWU7XG4gIHZhciB3YXRjaGVyLCBpZDtcblxuICAvLyBTb3J0IHF1ZXVlIGJlZm9yZSBmbHVzaC5cbiAgLy8gVGhpcyBlbnN1cmVzIHRoYXQ6XG4gIC8vIDEuIENvbXBvbmVudHMgYXJlIHVwZGF0ZWQgZnJvbSBwYXJlbnQgdG8gY2hpbGQuIChiZWNhdXNlIHBhcmVudCBpcyBhbHdheXNcbiAgLy8gICAgY3JlYXRlZCBiZWZvcmUgdGhlIGNoaWxkKVxuICAvLyAyLiBBIGNvbXBvbmVudCdzIHVzZXIgd2F0Y2hlcnMgYXJlIHJ1biBiZWZvcmUgaXRzIHJlbmRlciB3YXRjaGVyIChiZWNhdXNlXG4gIC8vICAgIHVzZXIgd2F0Y2hlcnMgYXJlIGNyZWF0ZWQgYmVmb3JlIHRoZSByZW5kZXIgd2F0Y2hlcilcbiAgLy8gMy4gSWYgYSBjb21wb25lbnQgaXMgZGVzdHJveWVkIGR1cmluZyBhIHBhcmVudCBjb21wb25lbnQncyB3YXRjaGVyIHJ1bixcbiAgLy8gICAgaXRzIHdhdGNoZXJzIGNhbiBiZSBza2lwcGVkLlxuICBxdWV1ZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmlkIC0gYi5pZDsgfSk7XG5cbiAgLy8gZG8gbm90IGNhY2hlIGxlbmd0aCBiZWNhdXNlIG1vcmUgd2F0Y2hlcnMgbWlnaHQgYmUgcHVzaGVkXG4gIC8vIGFzIHdlIHJ1biBleGlzdGluZyB3YXRjaGVyc1xuICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBxdWV1ZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICB3YXRjaGVyID0gcXVldWVbaW5kZXhdO1xuICAgIGlkID0gd2F0Y2hlci5pZDtcbiAgICBoYXNbaWRdID0gbnVsbDtcbiAgICB3YXRjaGVyLnJ1bigpO1xuICAgIC8vIGluIGRldiBidWlsZCwgY2hlY2sgYW5kIHN0b3AgY2lyY3VsYXIgdXBkYXRlcy5cbiAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgaGFzW2lkXSAhPSBudWxsKSB7XG4gICAgICBjaXJjdWxhcltpZF0gPSAoY2lyY3VsYXJbaWRdIHx8IDApICsgMTtcbiAgICAgIGlmIChjaXJjdWxhcltpZF0gPiBNQVhfVVBEQVRFX0NPVU5UKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBtYXkgaGF2ZSBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcCAnICsgKFxuICAgICAgICAgICAgd2F0Y2hlci51c2VyXG4gICAgICAgICAgICAgID8gKFwiaW4gd2F0Y2hlciB3aXRoIGV4cHJlc3Npb24gXFxcIlwiICsgKHdhdGNoZXIuZXhwcmVzc2lvbikgKyBcIlxcXCJcIilcbiAgICAgICAgICAgICAgOiBcImluIGEgY29tcG9uZW50IHJlbmRlciBmdW5jdGlvbi5cIlxuICAgICAgICAgICksXG4gICAgICAgICAgd2F0Y2hlci52bVxuICAgICAgICApO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGtlZXAgY29waWVzIG9mIHBvc3QgcXVldWVzIGJlZm9yZSByZXNldHRpbmcgc3RhdGVcbiAgdmFyIGFjdGl2YXRlZFF1ZXVlID0gYWN0aXZhdGVkQ2hpbGRyZW4uc2xpY2UoKTtcbiAgdmFyIHVwZGF0ZWRRdWV1ZSA9IHF1ZXVlLnNsaWNlKCk7XG5cbiAgcmVzZXRTY2hlZHVsZXJTdGF0ZSgpO1xuXG4gIC8vIGNhbGwgY29tcG9uZW50IHVwZGF0ZWQgYW5kIGFjdGl2YXRlZCBob29rc1xuICBjYWxsQWN0aXZhdGVkSG9va3MoYWN0aXZhdGVkUXVldWUpO1xuICBjYWxsVXBkYXRlZEhvb2tzKHVwZGF0ZWRRdWV1ZSk7XG5cbiAgLy8gZGV2dG9vbCBob29rXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZGV2dG9vbHMgJiYgY29uZmlnLmRldnRvb2xzKSB7XG4gICAgZGV2dG9vbHMuZW1pdCgnZmx1c2gnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsVXBkYXRlZEhvb2tzIChxdWV1ZSkge1xuICB2YXIgaSA9IHF1ZXVlLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciB3YXRjaGVyID0gcXVldWVbaV07XG4gICAgdmFyIHZtID0gd2F0Y2hlci52bTtcbiAgICBpZiAodm0uX3dhdGNoZXIgPT09IHdhdGNoZXIgJiYgdm0uX2lzTW91bnRlZCkge1xuICAgICAgY2FsbEhvb2sodm0sICd1cGRhdGVkJyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUXVldWUgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCB0aGF0IHdhcyBhY3RpdmF0ZWQgZHVyaW5nIHBhdGNoLlxuICogVGhlIHF1ZXVlIHdpbGwgYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSBlbnRpcmUgdHJlZSBoYXMgYmVlbiBwYXRjaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudCAodm0pIHtcbiAgLy8gc2V0dGluZyBfaW5hY3RpdmUgdG8gZmFsc2UgaGVyZSBzbyB0aGF0IGEgcmVuZGVyIGZ1bmN0aW9uIGNhblxuICAvLyByZWx5IG9uIGNoZWNraW5nIHdoZXRoZXIgaXQncyBpbiBhbiBpbmFjdGl2ZSB0cmVlIChlLmcuIHJvdXRlci12aWV3KVxuICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgYWN0aXZhdGVkQ2hpbGRyZW4ucHVzaCh2bSk7XG59XG5cbmZ1bmN0aW9uIGNhbGxBY3RpdmF0ZWRIb29rcyAocXVldWUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIHF1ZXVlW2ldLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChxdWV1ZVtpXSwgdHJ1ZSAvKiB0cnVlICovKTtcbiAgfVxufVxuXG4vKipcbiAqIFB1c2ggYSB3YXRjaGVyIGludG8gdGhlIHdhdGNoZXIgcXVldWUuXG4gKiBKb2JzIHdpdGggZHVwbGljYXRlIElEcyB3aWxsIGJlIHNraXBwZWQgdW5sZXNzIGl0J3NcbiAqIHB1c2hlZCB3aGVuIHRoZSBxdWV1ZSBpcyBiZWluZyBmbHVzaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZVdhdGNoZXIgKHdhdGNoZXIpIHtcbiAgdmFyIGlkID0gd2F0Y2hlci5pZDtcbiAgaWYgKGhhc1tpZF0gPT0gbnVsbCkge1xuICAgIGhhc1tpZF0gPSB0cnVlO1xuICAgIGlmICghZmx1c2hpbmcpIHtcbiAgICAgIHF1ZXVlLnB1c2god2F0Y2hlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIGFscmVhZHkgZmx1c2hpbmcsIHNwbGljZSB0aGUgd2F0Y2hlciBiYXNlZCBvbiBpdHMgaWRcbiAgICAgIC8vIGlmIGFscmVhZHkgcGFzdCBpdHMgaWQsIGl0IHdpbGwgYmUgcnVuIG5leHQgaW1tZWRpYXRlbHkuXG4gICAgICB2YXIgaSA9IHF1ZXVlLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAoaSA+IGluZGV4ICYmIHF1ZXVlW2ldLmlkID4gd2F0Y2hlci5pZCkge1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgICBxdWV1ZS5zcGxpY2UoaSArIDEsIDAsIHdhdGNoZXIpO1xuICAgIH1cbiAgICAvLyBxdWV1ZSB0aGUgZmx1c2hcbiAgICBpZiAoIXdhaXRpbmcpIHtcbiAgICAgIHdhaXRpbmcgPSB0cnVlO1xuICAgICAgbmV4dFRpY2soZmx1c2hTY2hlZHVsZXJRdWV1ZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgdWlkJDEgPSAwO1xuXG4vKipcbiAqIEEgd2F0Y2hlciBwYXJzZXMgYW4gZXhwcmVzc2lvbiwgY29sbGVjdHMgZGVwZW5kZW5jaWVzLFxuICogYW5kIGZpcmVzIGNhbGxiYWNrIHdoZW4gdGhlIGV4cHJlc3Npb24gdmFsdWUgY2hhbmdlcy5cbiAqIFRoaXMgaXMgdXNlZCBmb3IgYm90aCB0aGUgJHdhdGNoKCkgYXBpIGFuZCBkaXJlY3RpdmVzLlxuICovXG52YXIgV2F0Y2hlciA9IGZ1bmN0aW9uIFdhdGNoZXIgKFxuICB2bSxcbiAgZXhwT3JGbixcbiAgY2IsXG4gIG9wdGlvbnMsXG4gIGlzUmVuZGVyV2F0Y2hlclxuKSB7XG4gIHRoaXMudm0gPSB2bTtcbiAgaWYgKGlzUmVuZGVyV2F0Y2hlcikge1xuICAgIHZtLl93YXRjaGVyID0gdGhpcztcbiAgfVxuICB2bS5fd2F0Y2hlcnMucHVzaCh0aGlzKTtcbiAgLy8gb3B0aW9uc1xuICBpZiAob3B0aW9ucykge1xuICAgIHRoaXMuZGVlcCA9ICEhb3B0aW9ucy5kZWVwO1xuICAgIHRoaXMudXNlciA9ICEhb3B0aW9ucy51c2VyO1xuICAgIHRoaXMubGF6eSA9ICEhb3B0aW9ucy5sYXp5O1xuICAgIHRoaXMuc3luYyA9ICEhb3B0aW9ucy5zeW5jO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZGVlcCA9IHRoaXMudXNlciA9IHRoaXMubGF6eSA9IHRoaXMuc3luYyA9IGZhbHNlO1xuICB9XG4gIHRoaXMuY2IgPSBjYjtcbiAgdGhpcy5pZCA9ICsrdWlkJDE7IC8vIHVpZCBmb3IgYmF0Y2hpbmdcbiAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICB0aGlzLmRpcnR5ID0gdGhpcy5sYXp5OyAvLyBmb3IgbGF6eSB3YXRjaGVyc1xuICB0aGlzLmRlcHMgPSBbXTtcbiAgdGhpcy5uZXdEZXBzID0gW107XG4gIHRoaXMuZGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgdGhpcy5uZXdEZXBJZHMgPSBuZXcgX1NldCgpO1xuICB0aGlzLmV4cHJlc3Npb24gPSBleHBPckZuLnRvU3RyaW5nKCk7XG4gIC8vIHBhcnNlIGV4cHJlc3Npb24gZm9yIGdldHRlclxuICBpZiAodHlwZW9mIGV4cE9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLmdldHRlciA9IGV4cE9yRm47XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBwYXJzZVBhdGgoZXhwT3JGbik7XG4gICAgaWYgKCF0aGlzLmdldHRlcikge1xuICAgICAgdGhpcy5nZXR0ZXIgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiRmFpbGVkIHdhdGNoaW5nIHBhdGg6IFxcXCJcIiArIGV4cE9yRm4gKyBcIlxcXCIgXCIgK1xuICAgICAgICAnV2F0Y2hlciBvbmx5IGFjY2VwdHMgc2ltcGxlIGRvdC1kZWxpbWl0ZWQgcGF0aHMuICcgK1xuICAgICAgICAnRm9yIGZ1bGwgY29udHJvbCwgdXNlIGEgZnVuY3Rpb24gaW5zdGVhZC4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgdGhpcy52YWx1ZSA9IHRoaXMubGF6eVxuICAgID8gdW5kZWZpbmVkXG4gICAgOiB0aGlzLmdldCgpO1xufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgZ2V0dGVyLCBhbmQgcmUtY29sbGVjdCBkZXBlbmRlbmNpZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoKSB7XG4gIHB1c2hUYXJnZXQodGhpcyk7XG4gIHZhciB2YWx1ZTtcbiAgdmFyIHZtID0gdGhpcy52bTtcbiAgdHJ5IHtcbiAgICB2YWx1ZSA9IHRoaXMuZ2V0dGVyLmNhbGwodm0sIHZtKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0aGlzLnVzZXIpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCAoXCJnZXR0ZXIgZm9yIHdhdGNoZXIgXFxcIlwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlXG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIC8vIFwidG91Y2hcIiBldmVyeSBwcm9wZXJ0eSBzbyB0aGV5IGFyZSBhbGwgdHJhY2tlZCBhc1xuICAgIC8vIGRlcGVuZGVuY2llcyBmb3IgZGVlcCB3YXRjaGluZ1xuICAgIGlmICh0aGlzLmRlZXApIHtcbiAgICAgIHRyYXZlcnNlKHZhbHVlKTtcbiAgICB9XG4gICAgcG9wVGFyZ2V0KCk7XG4gICAgdGhpcy5jbGVhbnVwRGVwcygpO1xuICB9XG4gIHJldHVybiB2YWx1ZVxufTtcblxuLyoqXG4gKiBBZGQgYSBkZXBlbmRlbmN5IHRvIHRoaXMgZGlyZWN0aXZlLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5hZGREZXAgPSBmdW5jdGlvbiBhZGREZXAgKGRlcCkge1xuICB2YXIgaWQgPSBkZXAuaWQ7XG4gIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGlkKSkge1xuICAgIHRoaXMubmV3RGVwSWRzLmFkZChpZCk7XG4gICAgdGhpcy5uZXdEZXBzLnB1c2goZGVwKTtcbiAgICBpZiAoIXRoaXMuZGVwSWRzLmhhcyhpZCkpIHtcbiAgICAgIGRlcC5hZGRTdWIodGhpcyk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENsZWFuIHVwIGZvciBkZXBlbmRlbmN5IGNvbGxlY3Rpb24uXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmNsZWFudXBEZXBzID0gZnVuY3Rpb24gY2xlYW51cERlcHMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciBkZXAgPSB0aGlzJDEuZGVwc1tpXTtcbiAgICBpZiAoIXRoaXMkMS5uZXdEZXBJZHMuaGFzKGRlcC5pZCkpIHtcbiAgICAgIGRlcC5yZW1vdmVTdWIodGhpcyQxKTtcbiAgICB9XG4gIH1cbiAgdmFyIHRtcCA9IHRoaXMuZGVwSWRzO1xuICB0aGlzLmRlcElkcyA9IHRoaXMubmV3RGVwSWRzO1xuICB0aGlzLm5ld0RlcElkcyA9IHRtcDtcbiAgdGhpcy5uZXdEZXBJZHMuY2xlYXIoKTtcbiAgdG1wID0gdGhpcy5kZXBzO1xuICB0aGlzLmRlcHMgPSB0aGlzLm5ld0RlcHM7XG4gIHRoaXMubmV3RGVwcyA9IHRtcDtcbiAgdGhpcy5uZXdEZXBzLmxlbmd0aCA9IDA7XG59O1xuXG4vKipcbiAqIFN1YnNjcmliZXIgaW50ZXJmYWNlLlxuICogV2lsbCBiZSBjYWxsZWQgd2hlbiBhIGRlcGVuZGVuY3kgY2hhbmdlcy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlICgpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHRoaXMubGF6eSkge1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICB9IGVsc2UgaWYgKHRoaXMuc3luYykge1xuICAgIHRoaXMucnVuKCk7XG4gIH0gZWxzZSB7XG4gICAgcXVldWVXYXRjaGVyKHRoaXMpO1xuICB9XG59O1xuXG4vKipcbiAqIFNjaGVkdWxlciBqb2IgaW50ZXJmYWNlLlxuICogV2lsbCBiZSBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlci5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gcnVuICgpIHtcbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5nZXQoKTtcbiAgICBpZiAoXG4gICAgICB2YWx1ZSAhPT0gdGhpcy52YWx1ZSB8fFxuICAgICAgLy8gRGVlcCB3YXRjaGVycyBhbmQgd2F0Y2hlcnMgb24gT2JqZWN0L0FycmF5cyBzaG91bGQgZmlyZSBldmVuXG4gICAgICAvLyB3aGVuIHRoZSB2YWx1ZSBpcyB0aGUgc2FtZSwgYmVjYXVzZSB0aGUgdmFsdWUgbWF5XG4gICAgICAvLyBoYXZlIG11dGF0ZWQuXG4gICAgICBpc09iamVjdCh2YWx1ZSkgfHxcbiAgICAgIHRoaXMuZGVlcFxuICAgICkge1xuICAgICAgLy8gc2V0IG5ldyB2YWx1ZVxuICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIGlmICh0aGlzLnVzZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHRoaXMudm0sIChcImNhbGxiYWNrIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSB2YWx1ZSBvZiB0aGUgd2F0Y2hlci5cbiAqIFRoaXMgb25seSBnZXRzIGNhbGxlZCBmb3IgbGF6eSB3YXRjaGVycy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZSAoKSB7XG4gIHRoaXMudmFsdWUgPSB0aGlzLmdldCgpO1xuICB0aGlzLmRpcnR5ID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIERlcGVuZCBvbiBhbGwgZGVwcyBjb2xsZWN0ZWQgYnkgdGhpcyB3YXRjaGVyLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHRoaXMkMS5kZXBzW2ldLmRlcGVuZCgpO1xuICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSBzZWxmIGZyb20gYWxsIGRlcGVuZGVuY2llcycgc3Vic2NyaWJlciBsaXN0LlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS50ZWFyZG93biA9IGZ1bmN0aW9uIHRlYXJkb3duICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHZtJ3Mgd2F0Y2hlciBsaXN0XG4gICAgLy8gdGhpcyBpcyBhIHNvbWV3aGF0IGV4cGVuc2l2ZSBvcGVyYXRpb24gc28gd2Ugc2tpcCBpdFxuICAgIC8vIGlmIHRoZSB2bSBpcyBiZWluZyBkZXN0cm95ZWQuXG4gICAgaWYgKCF0aGlzLnZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICByZW1vdmUodGhpcy52bS5fd2F0Y2hlcnMsIHRoaXMpO1xuICAgIH1cbiAgICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdGhpcyQxLmRlcHNbaV0ucmVtb3ZlU3ViKHRoaXMkMSk7XG4gICAgfVxuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gIH1cbn07XG5cbi8qICAqL1xuXG52YXIgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uID0ge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogbm9vcCxcbiAgc2V0OiBub29wXG59O1xuXG5mdW5jdGlvbiBwcm94eSAodGFyZ2V0LCBzb3VyY2VLZXksIGtleSkge1xuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gZnVuY3Rpb24gcHJveHlHZXR0ZXIgKCkge1xuICAgIHJldHVybiB0aGlzW3NvdXJjZUtleV1ba2V5XVxuICB9O1xuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gcHJveHlTZXR0ZXIgKHZhbCkge1xuICAgIHRoaXNbc291cmNlS2V5XVtrZXldID0gdmFsO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGluaXRTdGF0ZSAodm0pIHtcbiAgdm0uX3dhdGNoZXJzID0gW107XG4gIHZhciBvcHRzID0gdm0uJG9wdGlvbnM7XG4gIGlmIChvcHRzLnByb3BzKSB7IGluaXRQcm9wcyh2bSwgb3B0cy5wcm9wcyk7IH1cbiAgaWYgKG9wdHMubWV0aG9kcykgeyBpbml0TWV0aG9kcyh2bSwgb3B0cy5tZXRob2RzKTsgfVxuICBpZiAob3B0cy5kYXRhKSB7XG4gICAgaW5pdERhdGEodm0pO1xuICB9IGVsc2Uge1xuICAgIG9ic2VydmUodm0uX2RhdGEgPSB7fSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbiAgfVxuICBpZiAob3B0cy5jb21wdXRlZCkgeyBpbml0Q29tcHV0ZWQodm0sIG9wdHMuY29tcHV0ZWQpOyB9XG4gIGlmIChvcHRzLndhdGNoICYmIG9wdHMud2F0Y2ggIT09IG5hdGl2ZVdhdGNoKSB7XG4gICAgaW5pdFdhdGNoKHZtLCBvcHRzLndhdGNoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0UHJvcHMgKHZtLCBwcm9wc09wdGlvbnMpIHtcbiAgdmFyIHByb3BzRGF0YSA9IHZtLiRvcHRpb25zLnByb3BzRGF0YSB8fCB7fTtcbiAgdmFyIHByb3BzID0gdm0uX3Byb3BzID0ge307XG4gIC8vIGNhY2hlIHByb3Aga2V5cyBzbyB0aGF0IGZ1dHVyZSBwcm9wcyB1cGRhdGVzIGNhbiBpdGVyYXRlIHVzaW5nIEFycmF5XG4gIC8vIGluc3RlYWQgb2YgZHluYW1pYyBvYmplY3Qga2V5IGVudW1lcmF0aW9uLlxuICB2YXIga2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyA9IFtdO1xuICB2YXIgaXNSb290ID0gIXZtLiRwYXJlbnQ7XG4gIC8vIHJvb3QgaW5zdGFuY2UgcHJvcHMgc2hvdWxkIGJlIGNvbnZlcnRlZFxuICBpZiAoIWlzUm9vdCkge1xuICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XG4gIH1cbiAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB2YXIgdmFsdWUgPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wc09wdGlvbnMsIHByb3BzRGF0YSwgdm0pO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAge1xuICAgICAgdmFyIGh5cGhlbmF0ZWRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgIGlmIChpc1Jlc2VydmVkQXR0cmlidXRlKGh5cGhlbmF0ZWRLZXkpIHx8XG4gICAgICAgICAgY29uZmlnLmlzUmVzZXJ2ZWRBdHRyKGh5cGhlbmF0ZWRLZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiXFxcIlwiICsgaHlwaGVuYXRlZEtleSArIFwiXFxcIiBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZSBhbmQgY2Fubm90IGJlIHVzZWQgYXMgY29tcG9uZW50IHByb3AuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBkZWZpbmVSZWFjdGl2ZShwcm9wcywga2V5LCB2YWx1ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodm0uJHBhcmVudCAmJiAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50KSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIFwiQXZvaWQgbXV0YXRpbmcgYSBwcm9wIGRpcmVjdGx5IHNpbmNlIHRoZSB2YWx1ZSB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHBhcmVudCBjb21wb25lbnQgcmUtcmVuZGVycy4gXCIgK1xuICAgICAgICAgICAgXCJJbnN0ZWFkLCB1c2UgYSBkYXRhIG9yIGNvbXB1dGVkIHByb3BlcnR5IGJhc2VkIG9uIHRoZSBwcm9wJ3MgXCIgK1xuICAgICAgICAgICAgXCJ2YWx1ZS4gUHJvcCBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIHN0YXRpYyBwcm9wcyBhcmUgYWxyZWFkeSBwcm94aWVkIG9uIHRoZSBjb21wb25lbnQncyBwcm90b3R5cGVcbiAgICAvLyBkdXJpbmcgVnVlLmV4dGVuZCgpLiBXZSBvbmx5IG5lZWQgdG8gcHJveHkgcHJvcHMgZGVmaW5lZCBhdFxuICAgIC8vIGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICBwcm94eSh2bSwgXCJfcHJvcHNcIiwga2V5KTtcbiAgICB9XG4gIH07XG5cbiAgZm9yICh2YXIga2V5IGluIHByb3BzT3B0aW9ucykgbG9vcCgga2V5ICk7XG4gIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbn1cblxuZnVuY3Rpb24gaW5pdERhdGEgKHZtKSB7XG4gIHZhciBkYXRhID0gdm0uJG9wdGlvbnMuZGF0YTtcbiAgZGF0YSA9IHZtLl9kYXRhID0gdHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbidcbiAgICA/IGdldERhdGEoZGF0YSwgdm0pXG4gICAgOiBkYXRhIHx8IHt9O1xuICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICBkYXRhID0ge307XG4gICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdkYXRhIGZ1bmN0aW9ucyBzaG91bGQgcmV0dXJuIGFuIG9iamVjdDpcXG4nICtcbiAgICAgICdodHRwczovL3Z1ZWpzLm9yZy92Mi9ndWlkZS9jb21wb25lbnRzLmh0bWwjZGF0YS1NdXN0LUJlLWEtRnVuY3Rpb24nLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIC8vIHByb3h5IGRhdGEgb24gaW5zdGFuY2VcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgdmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XG4gIHZhciBtZXRob2RzID0gdm0uJG9wdGlvbnMubWV0aG9kcztcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIHtcbiAgICAgIGlmIChtZXRob2RzICYmIGhhc093bihtZXRob2RzLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBkYXRhIHByb3BlcnR5LlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIlRoZSBkYXRhIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlY2xhcmVkIGFzIGEgcHJvcC4gXCIgK1xuICAgICAgICBcIlVzZSBwcm9wIGRlZmF1bHQgdmFsdWUgaW5zdGVhZC5cIixcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICghaXNSZXNlcnZlZChrZXkpKSB7XG4gICAgICBwcm94eSh2bSwgXCJfZGF0YVwiLCBrZXkpO1xuICAgIH1cbiAgfVxuICAvLyBvYnNlcnZlIGRhdGFcbiAgb2JzZXJ2ZShkYXRhLCB0cnVlIC8qIGFzUm9vdERhdGEgKi8pO1xufVxuXG5mdW5jdGlvbiBnZXREYXRhIChkYXRhLCB2bSkge1xuICAvLyAjNzU3MyBkaXNhYmxlIGRlcCBjb2xsZWN0aW9uIHdoZW4gaW52b2tpbmcgZGF0YSBnZXR0ZXJzXG4gIHB1c2hUYXJnZXQoKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGF0YS5jYWxsKHZtLCB2bSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcImRhdGEoKVwiKTtcbiAgICByZXR1cm4ge31cbiAgfSBmaW5hbGx5IHtcbiAgICBwb3BUYXJnZXQoKTtcbiAgfVxufVxuXG52YXIgY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyA9IHsgbGF6eTogdHJ1ZSB9O1xuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQgKHZtLCBjb21wdXRlZCkge1xuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgdmFyIHdhdGNoZXJzID0gdm0uX2NvbXB1dGVkV2F0Y2hlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAvLyBjb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSBqdXN0IGdldHRlcnMgZHVyaW5nIFNTUlxuICB2YXIgaXNTU1IgPSBpc1NlcnZlclJlbmRlcmluZygpO1xuXG4gIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgIHZhciB1c2VyRGVmID0gY29tcHV0ZWRba2V5XTtcbiAgICB2YXIgZ2V0dGVyID0gdHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicgPyB1c2VyRGVmIDogdXNlckRlZi5nZXQ7XG4gICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGdldHRlciA9PSBudWxsKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAoXCJHZXR0ZXIgaXMgbWlzc2luZyBmb3IgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFpc1NTUikge1xuICAgICAgLy8gY3JlYXRlIGludGVybmFsIHdhdGNoZXIgZm9yIHRoZSBjb21wdXRlZCBwcm9wZXJ0eS5cbiAgICAgIHdhdGNoZXJzW2tleV0gPSBuZXcgV2F0Y2hlcihcbiAgICAgICAgdm0sXG4gICAgICAgIGdldHRlciB8fCBub29wLFxuICAgICAgICBub29wLFxuICAgICAgICBjb21wdXRlZFdhdGNoZXJPcHRpb25zXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIGNvbXBvbmVudC1kZWZpbmVkIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGFscmVhZHkgZGVmaW5lZCBvbiB0aGVcbiAgICAvLyBjb21wb25lbnQgcHJvdG90eXBlLiBXZSBvbmx5IG5lZWQgdG8gZGVmaW5lIGNvbXB1dGVkIHByb3BlcnRpZXMgZGVmaW5lZFxuICAgIC8vIGF0IGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICBkZWZpbmVDb21wdXRlZCh2bSwga2V5LCB1c2VyRGVmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGtleSBpbiB2bS4kZGF0YSkge1xuICAgICAgICB3YXJuKChcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGluIGRhdGEuXCIpLCB2bSk7XG4gICAgICB9IGVsc2UgaWYgKHZtLiRvcHRpb25zLnByb3BzICYmIGtleSBpbiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgICAgICB3YXJuKChcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGFzIGEgcHJvcC5cIiksIHZtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lQ29tcHV0ZWQgKFxuICB0YXJnZXQsXG4gIGtleSxcbiAgdXNlckRlZlxuKSB7XG4gIHZhciBzaG91bGRDYWNoZSA9ICFpc1NlcnZlclJlbmRlcmluZygpO1xuICBpZiAodHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gc2hvdWxkQ2FjaGVcbiAgICAgID8gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KVxuICAgICAgOiB1c2VyRGVmO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBub29wO1xuICB9IGVsc2Uge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSB1c2VyRGVmLmdldFxuICAgICAgPyBzaG91bGRDYWNoZSAmJiB1c2VyRGVmLmNhY2hlICE9PSBmYWxzZVxuICAgICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcbiAgICAgICAgOiB1c2VyRGVmLmdldFxuICAgICAgOiBub29wO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSB1c2VyRGVmLnNldFxuICAgICAgPyB1c2VyRGVmLnNldFxuICAgICAgOiBub29wO1xuICB9XG4gIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9PT0gbm9vcCkge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAoXCJDb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgd2FzIGFzc2lnbmVkIHRvIGJ1dCBpdCBoYXMgbm8gc2V0dGVyLlwiKSxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIgKGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIgKCkge1xuICAgIHZhciB3YXRjaGVyID0gdGhpcy5fY29tcHV0ZWRXYXRjaGVycyAmJiB0aGlzLl9jb21wdXRlZFdhdGNoZXJzW2tleV07XG4gICAgaWYgKHdhdGNoZXIpIHtcbiAgICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XG4gICAgICAgIHdhdGNoZXIuZXZhbHVhdGUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIHdhdGNoZXIuZGVwZW5kKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2F0Y2hlci52YWx1ZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0TWV0aG9kcyAodm0sIG1ldGhvZHMpIHtcbiAgdmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XG4gIGZvciAodmFyIGtleSBpbiBtZXRob2RzKSB7XG4gICAge1xuICAgICAgaWYgKG1ldGhvZHNba2V5XSA9PSBudWxsKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbiB1bmRlZmluZWQgdmFsdWUgaW4gdGhlIGNvbXBvbmVudCBkZWZpbml0aW9uLiBcIiArXG4gICAgICAgICAgXCJEaWQgeW91IHJlZmVyZW5jZSB0aGUgZnVuY3Rpb24gY29ycmVjdGx5P1wiLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBwcm9wLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKChrZXkgaW4gdm0pICYmIGlzUmVzZXJ2ZWQoa2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBjb25mbGljdHMgd2l0aCBhbiBleGlzdGluZyBWdWUgaW5zdGFuY2UgbWV0aG9kLiBcIiArXG4gICAgICAgICAgXCJBdm9pZCBkZWZpbmluZyBjb21wb25lbnQgbWV0aG9kcyB0aGF0IHN0YXJ0IHdpdGggXyBvciAkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHZtW2tleV0gPSBtZXRob2RzW2tleV0gPT0gbnVsbCA/IG5vb3AgOiBiaW5kKG1ldGhvZHNba2V5XSwgdm0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRXYXRjaCAodm0sIHdhdGNoKSB7XG4gIGZvciAodmFyIGtleSBpbiB3YXRjaCkge1xuICAgIHZhciBoYW5kbGVyID0gd2F0Y2hba2V5XTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcltpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdhdGNoZXIgKFxuICB2bSxcbiAgZXhwT3JGbixcbiAgaGFuZGxlcixcbiAgb3B0aW9uc1xuKSB7XG4gIGlmIChpc1BsYWluT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgb3B0aW9ucyA9IGhhbmRsZXI7XG4gICAgaGFuZGxlciA9IGhhbmRsZXIuaGFuZGxlcjtcbiAgfVxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgaGFuZGxlciA9IHZtW2hhbmRsZXJdO1xuICB9XG4gIHJldHVybiB2bS4kd2F0Y2goZXhwT3JGbiwgaGFuZGxlciwgb3B0aW9ucylcbn1cblxuZnVuY3Rpb24gc3RhdGVNaXhpbiAoVnVlKSB7XG4gIC8vIGZsb3cgc29tZWhvdyBoYXMgcHJvYmxlbXMgd2l0aCBkaXJlY3RseSBkZWNsYXJlZCBkZWZpbml0aW9uIG9iamVjdFxuICAvLyB3aGVuIHVzaW5nIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgc28gd2UgaGF2ZSB0byBwcm9jZWR1cmFsbHkgYnVpbGQgdXBcbiAgLy8gdGhlIG9iamVjdCBoZXJlLlxuICB2YXIgZGF0YURlZiA9IHt9O1xuICBkYXRhRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RhdGEgfTtcbiAgdmFyIHByb3BzRGVmID0ge307XG4gIHByb3BzRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Byb3BzIH07XG4gIHtcbiAgICBkYXRhRGVmLnNldCA9IGZ1bmN0aW9uIChuZXdEYXRhKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnQXZvaWQgcmVwbGFjaW5nIGluc3RhbmNlIHJvb3QgJGRhdGEuICcgK1xuICAgICAgICAnVXNlIG5lc3RlZCBkYXRhIHByb3BlcnRpZXMgaW5zdGVhZC4nLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH07XG4gICAgcHJvcHNEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcIiRwcm9wcyBpcyByZWFkb25seS5cIiwgdGhpcyk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRkYXRhJywgZGF0YURlZik7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHByb3BzJywgcHJvcHNEZWYpO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHNldCA9IHNldDtcbiAgVnVlLnByb3RvdHlwZS4kZGVsZXRlID0gZGVsO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHdhdGNoID0gZnVuY3Rpb24gKFxuICAgIGV4cE9yRm4sXG4gICAgY2IsXG4gICAgb3B0aW9uc1xuICApIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChpc1BsYWluT2JqZWN0KGNiKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKVxuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLnVzZXIgPSB0cnVlO1xuICAgIHZhciB3YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5pbW1lZGlhdGUpIHtcbiAgICAgIGNiLmNhbGwodm0sIHdhdGNoZXIudmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gdW53YXRjaEZuICgpIHtcbiAgICAgIHdhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0UHJvdmlkZSAodm0pIHtcbiAgdmFyIHByb3ZpZGUgPSB2bS4kb3B0aW9ucy5wcm92aWRlO1xuICBpZiAocHJvdmlkZSkge1xuICAgIHZtLl9wcm92aWRlZCA9IHR5cGVvZiBwcm92aWRlID09PSAnZnVuY3Rpb24nXG4gICAgICA/IHByb3ZpZGUuY2FsbCh2bSlcbiAgICAgIDogcHJvdmlkZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0SW5qZWN0aW9ucyAodm0pIHtcbiAgdmFyIHJlc3VsdCA9IHJlc29sdmVJbmplY3Qodm0uJG9wdGlvbnMuaW5qZWN0LCB2bSk7XG4gIGlmIChyZXN1bHQpIHtcbiAgICB0b2dnbGVPYnNlcnZpbmcoZmFsc2UpO1xuICAgIE9iamVjdC5rZXlzKHJlc3VsdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSh2bSwga2V5LCByZXN1bHRba2V5XSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBcIkF2b2lkIG11dGF0aW5nIGFuIGluamVjdGVkIHZhbHVlIGRpcmVjdGx5IHNpbmNlIHRoZSBjaGFuZ2VzIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcHJvdmlkZWQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFwiICtcbiAgICAgICAgICAgIFwiaW5qZWN0aW9uIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUluamVjdCAoaW5qZWN0LCB2bSkge1xuICBpZiAoaW5qZWN0KSB7XG4gICAgLy8gaW5qZWN0IGlzIDphbnkgYmVjYXVzZSBmbG93IGlzIG5vdCBzbWFydCBlbm91Z2ggdG8gZmlndXJlIG91dCBjYWNoZWRcbiAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIga2V5cyA9IGhhc1N5bWJvbFxuICAgICAgPyBSZWZsZWN0Lm93bktleXMoaW5qZWN0KS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihpbmplY3QsIGtleSkuZW51bWVyYWJsZVxuICAgICAgfSlcbiAgICAgIDogT2JqZWN0LmtleXMoaW5qZWN0KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICB2YXIgcHJvdmlkZUtleSA9IGluamVjdFtrZXldLmZyb207XG4gICAgICB2YXIgc291cmNlID0gdm07XG4gICAgICB3aGlsZSAoc291cmNlKSB7XG4gICAgICAgIGlmIChzb3VyY2UuX3Byb3ZpZGVkICYmIGhhc093bihzb3VyY2UuX3Byb3ZpZGVkLCBwcm92aWRlS2V5KSkge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gc291cmNlLl9wcm92aWRlZFtwcm92aWRlS2V5XTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZSA9IHNvdXJjZS4kcGFyZW50O1xuICAgICAgfVxuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgaWYgKCdkZWZhdWx0JyBpbiBpbmplY3Rba2V5XSkge1xuICAgICAgICAgIHZhciBwcm92aWRlRGVmYXVsdCA9IGluamVjdFtrZXldLmRlZmF1bHQ7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB0eXBlb2YgcHJvdmlkZURlZmF1bHQgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gcHJvdmlkZURlZmF1bHQuY2FsbCh2bSlcbiAgICAgICAgICAgIDogcHJvdmlkZURlZmF1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybigoXCJJbmplY3Rpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIG5vdCBmb3VuZFwiKSwgdm0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHYtZm9yIGxpc3RzLlxuICovXG5mdW5jdGlvbiByZW5kZXJMaXN0IChcbiAgdmFsLFxuICByZW5kZXJcbikge1xuICB2YXIgcmV0LCBpLCBsLCBrZXlzLCBrZXk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkgfHwgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgbCA9IHZhbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxbaV0sIGkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHJldCA9IG5ldyBBcnJheSh2YWwpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB2YWw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVyKGkgKyAxLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIHJldCA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtrZXldLCBrZXksIGkpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNEZWYocmV0KSkge1xuICAgIChyZXQpLl9pc1ZMaXN0ID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgPHNsb3Q+XG4gKi9cbmZ1bmN0aW9uIHJlbmRlclNsb3QgKFxuICBuYW1lLFxuICBmYWxsYmFjayxcbiAgcHJvcHMsXG4gIGJpbmRPYmplY3Rcbikge1xuICB2YXIgc2NvcGVkU2xvdEZuID0gdGhpcy4kc2NvcGVkU2xvdHNbbmFtZV07XG4gIHZhciBub2RlcztcbiAgaWYgKHNjb3BlZFNsb3RGbikgeyAvLyBzY29wZWQgc2xvdFxuICAgIHByb3BzID0gcHJvcHMgfHwge307XG4gICAgaWYgKGJpbmRPYmplY3QpIHtcbiAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiAhaXNPYmplY3QoYmluZE9iamVjdCkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnc2xvdCB2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCcsXG4gICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcHJvcHMgPSBleHRlbmQoZXh0ZW5kKHt9LCBiaW5kT2JqZWN0KSwgcHJvcHMpO1xuICAgIH1cbiAgICBub2RlcyA9IHNjb3BlZFNsb3RGbihwcm9wcykgfHwgZmFsbGJhY2s7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsb3ROb2RlcyA9IHRoaXMuJHNsb3RzW25hbWVdO1xuICAgIC8vIHdhcm4gZHVwbGljYXRlIHNsb3QgdXNhZ2VcbiAgICBpZiAoc2xvdE5vZGVzKSB7XG4gICAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgc2xvdE5vZGVzLl9yZW5kZXJlZCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiRHVwbGljYXRlIHByZXNlbmNlIG9mIHNsb3QgXFxcIlwiICsgbmFtZSArIFwiXFxcIiBmb3VuZCBpbiB0aGUgc2FtZSByZW5kZXIgdHJlZSBcIiArXG4gICAgICAgICAgXCItIHRoaXMgd2lsbCBsaWtlbHkgY2F1c2UgcmVuZGVyIGVycm9ycy5cIixcbiAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBzbG90Tm9kZXMuX3JlbmRlcmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgbm9kZXMgPSBzbG90Tm9kZXMgfHwgZmFsbGJhY2s7XG4gIH1cblxuICB2YXIgdGFyZ2V0ID0gcHJvcHMgJiYgcHJvcHMuc2xvdDtcbiAgaWYgKHRhcmdldCkge1xuICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScsIHsgc2xvdDogdGFyZ2V0IH0sIG5vZGVzKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBub2Rlc1xuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgZmlsdGVyc1xuICovXG5mdW5jdGlvbiByZXNvbHZlRmlsdGVyIChpZCkge1xuICByZXR1cm4gcmVzb2x2ZUFzc2V0KHRoaXMuJG9wdGlvbnMsICdmaWx0ZXJzJywgaWQsIHRydWUpIHx8IGlkZW50aXR5XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpc0tleU5vdE1hdGNoIChleHBlY3QsIGFjdHVhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShleHBlY3QpKSB7XG4gICAgcmV0dXJuIGV4cGVjdC5pbmRleE9mKGFjdHVhbCkgPT09IC0xXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGV4cGVjdCAhPT0gYWN0dWFsXG4gIH1cbn1cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgY2hlY2tpbmcga2V5Q29kZXMgZnJvbSBjb25maWcuXG4gKiBleHBvc2VkIGFzIFZ1ZS5wcm90b3R5cGUuX2tcbiAqIHBhc3NpbmcgaW4gZXZlbnRLZXlOYW1lIGFzIGxhc3QgYXJndW1lbnQgc2VwYXJhdGVseSBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICovXG5mdW5jdGlvbiBjaGVja0tleUNvZGVzIChcbiAgZXZlbnRLZXlDb2RlLFxuICBrZXksXG4gIGJ1aWx0SW5LZXlDb2RlLFxuICBldmVudEtleU5hbWUsXG4gIGJ1aWx0SW5LZXlOYW1lXG4pIHtcbiAgdmFyIG1hcHBlZEtleUNvZGUgPSBjb25maWcua2V5Q29kZXNba2V5XSB8fCBidWlsdEluS2V5Q29kZTtcbiAgaWYgKGJ1aWx0SW5LZXlOYW1lICYmIGV2ZW50S2V5TmFtZSAmJiAhY29uZmlnLmtleUNvZGVzW2tleV0pIHtcbiAgICByZXR1cm4gaXNLZXlOb3RNYXRjaChidWlsdEluS2V5TmFtZSwgZXZlbnRLZXlOYW1lKVxuICB9IGVsc2UgaWYgKG1hcHBlZEtleUNvZGUpIHtcbiAgICByZXR1cm4gaXNLZXlOb3RNYXRjaChtYXBwZWRLZXlDb2RlLCBldmVudEtleUNvZGUpXG4gIH0gZWxzZSBpZiAoZXZlbnRLZXlOYW1lKSB7XG4gICAgcmV0dXJuIGh5cGhlbmF0ZShldmVudEtleU5hbWUpICE9PSBrZXlcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgbWVyZ2luZyB2LWJpbmQ9XCJvYmplY3RcIiBpbnRvIGEgVk5vZGUncyBkYXRhLlxuICovXG5mdW5jdGlvbiBiaW5kT2JqZWN0UHJvcHMgKFxuICBkYXRhLFxuICB0YWcsXG4gIHZhbHVlLFxuICBhc1Byb3AsXG4gIGlzU3luY1xuKSB7XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAndi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3Qgb3IgQXJyYXkgdmFsdWUnLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB0b09iamVjdCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICB2YXIgaGFzaDtcbiAgICAgIHZhciBsb29wID0gZnVuY3Rpb24gKCBrZXkgKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBrZXkgPT09ICdjbGFzcycgfHxcbiAgICAgICAgICBrZXkgPT09ICdzdHlsZScgfHxcbiAgICAgICAgICBpc1Jlc2VydmVkQXR0cmlidXRlKGtleSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgaGFzaCA9IGRhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMudHlwZTtcbiAgICAgICAgICBoYXNoID0gYXNQcm9wIHx8IGNvbmZpZy5tdXN0VXNlUHJvcCh0YWcsIHR5cGUsIGtleSlcbiAgICAgICAgICAgID8gZGF0YS5kb21Qcm9wcyB8fCAoZGF0YS5kb21Qcm9wcyA9IHt9KVxuICAgICAgICAgICAgOiBkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGtleSBpbiBoYXNoKSkge1xuICAgICAgICAgIGhhc2hba2V5XSA9IHZhbHVlW2tleV07XG5cbiAgICAgICAgICBpZiAoaXNTeW5jKSB7XG4gICAgICAgICAgICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICAgICAgICAgICAgb25bKFwidXBkYXRlOlwiICsga2V5KV0gPSBmdW5jdGlvbiAoJGV2ZW50KSB7XG4gICAgICAgICAgICAgIHZhbHVlW2tleV0gPSAkZXZlbnQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSBsb29wKCBrZXkgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyBzdGF0aWMgdHJlZXMuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlclN0YXRpYyAoXG4gIGluZGV4LFxuICBpc0luRm9yXG4pIHtcbiAgdmFyIGNhY2hlZCA9IHRoaXMuX3N0YXRpY1RyZWVzIHx8ICh0aGlzLl9zdGF0aWNUcmVlcyA9IFtdKTtcbiAgdmFyIHRyZWUgPSBjYWNoZWRbaW5kZXhdO1xuICAvLyBpZiBoYXMgYWxyZWFkeS1yZW5kZXJlZCBzdGF0aWMgdHJlZSBhbmQgbm90IGluc2lkZSB2LWZvcixcbiAgLy8gd2UgY2FuIHJldXNlIHRoZSBzYW1lIHRyZWUuXG4gIGlmICh0cmVlICYmICFpc0luRm9yKSB7XG4gICAgcmV0dXJuIHRyZWVcbiAgfVxuICAvLyBvdGhlcndpc2UsIHJlbmRlciBhIGZyZXNoIHRyZWUuXG4gIHRyZWUgPSBjYWNoZWRbaW5kZXhdID0gdGhpcy4kb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnNbaW5kZXhdLmNhbGwoXG4gICAgdGhpcy5fcmVuZGVyUHJveHksXG4gICAgbnVsbCxcbiAgICB0aGlzIC8vIGZvciByZW5kZXIgZm5zIGdlbmVyYXRlZCBmb3IgZnVuY3Rpb25hbCBjb21wb25lbnQgdGVtcGxhdGVzXG4gICk7XG4gIG1hcmtTdGF0aWModHJlZSwgKFwiX19zdGF0aWNfX1wiICsgaW5kZXgpLCBmYWxzZSk7XG4gIHJldHVybiB0cmVlXG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHYtb25jZS5cbiAqIEVmZmVjdGl2ZWx5IGl0IG1lYW5zIG1hcmtpbmcgdGhlIG5vZGUgYXMgc3RhdGljIHdpdGggYSB1bmlxdWUga2V5LlxuICovXG5mdW5jdGlvbiBtYXJrT25jZSAoXG4gIHRyZWUsXG4gIGluZGV4LFxuICBrZXlcbikge1xuICBtYXJrU3RhdGljKHRyZWUsIChcIl9fb25jZV9fXCIgKyBpbmRleCArIChrZXkgPyAoXCJfXCIgKyBrZXkpIDogXCJcIikpLCB0cnVlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpYyAoXG4gIHRyZWUsXG4gIGtleSxcbiAgaXNPbmNlXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodHJlZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0cmVlW2ldICYmIHR5cGVvZiB0cmVlW2ldICE9PSAnc3RyaW5nJykge1xuICAgICAgICBtYXJrU3RhdGljTm9kZSh0cmVlW2ldLCAoa2V5ICsgXCJfXCIgKyBpKSwgaXNPbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbWFya1N0YXRpY05vZGUodHJlZSwga2V5LCBpc09uY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWNOb2RlIChub2RlLCBrZXksIGlzT25jZSkge1xuICBub2RlLmlzU3RhdGljID0gdHJ1ZTtcbiAgbm9kZS5rZXkgPSBrZXk7XG4gIG5vZGUuaXNPbmNlID0gaXNPbmNlO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmluZE9iamVjdExpc3RlbmVycyAoZGF0YSwgdmFsdWUpIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ3Ytb24gd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCB2YWx1ZScsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvbiA9IGRhdGEub24gPSBkYXRhLm9uID8gZXh0ZW5kKHt9LCBkYXRhLm9uKSA6IHt9O1xuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIHZhciBleGlzdGluZyA9IG9uW2tleV07XG4gICAgICAgIHZhciBvdXJzID0gdmFsdWVba2V5XTtcbiAgICAgICAgb25ba2V5XSA9IGV4aXN0aW5nID8gW10uY29uY2F0KGV4aXN0aW5nLCBvdXJzKSA6IG91cnM7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbnN0YWxsUmVuZGVySGVscGVycyAodGFyZ2V0KSB7XG4gIHRhcmdldC5fbyA9IG1hcmtPbmNlO1xuICB0YXJnZXQuX24gPSB0b051bWJlcjtcbiAgdGFyZ2V0Ll9zID0gdG9TdHJpbmc7XG4gIHRhcmdldC5fbCA9IHJlbmRlckxpc3Q7XG4gIHRhcmdldC5fdCA9IHJlbmRlclNsb3Q7XG4gIHRhcmdldC5fcSA9IGxvb3NlRXF1YWw7XG4gIHRhcmdldC5faSA9IGxvb3NlSW5kZXhPZjtcbiAgdGFyZ2V0Ll9tID0gcmVuZGVyU3RhdGljO1xuICB0YXJnZXQuX2YgPSByZXNvbHZlRmlsdGVyO1xuICB0YXJnZXQuX2sgPSBjaGVja0tleUNvZGVzO1xuICB0YXJnZXQuX2IgPSBiaW5kT2JqZWN0UHJvcHM7XG4gIHRhcmdldC5fdiA9IGNyZWF0ZVRleHRWTm9kZTtcbiAgdGFyZ2V0Ll9lID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgdGFyZ2V0Ll91ID0gcmVzb2x2ZVNjb3BlZFNsb3RzO1xuICB0YXJnZXQuX2cgPSBiaW5kT2JqZWN0TGlzdGVuZXJzO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gRnVuY3Rpb25hbFJlbmRlckNvbnRleHQgKFxuICBkYXRhLFxuICBwcm9wcyxcbiAgY2hpbGRyZW4sXG4gIHBhcmVudCxcbiAgQ3RvclxuKSB7XG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICAvLyBlbnN1cmUgdGhlIGNyZWF0ZUVsZW1lbnQgZnVuY3Rpb24gaW4gZnVuY3Rpb25hbCBjb21wb25lbnRzXG4gIC8vIGdldHMgYSB1bmlxdWUgY29udGV4dCAtIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciBjb3JyZWN0IG5hbWVkIHNsb3QgY2hlY2tcbiAgdmFyIGNvbnRleHRWbTtcbiAgaWYgKGhhc093bihwYXJlbnQsICdfdWlkJykpIHtcbiAgICBjb250ZXh0Vm0gPSBPYmplY3QuY3JlYXRlKHBhcmVudCk7XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgY29udGV4dFZtLl9vcmlnaW5hbCA9IHBhcmVudDtcbiAgfSBlbHNlIHtcbiAgICAvLyB0aGUgY29udGV4dCB2bSBwYXNzZWQgaW4gaXMgYSBmdW5jdGlvbmFsIGNvbnRleHQgYXMgd2VsbC5cbiAgICAvLyBpbiB0aGlzIGNhc2Ugd2Ugd2FudCB0byBtYWtlIHN1cmUgd2UgYXJlIGFibGUgdG8gZ2V0IGEgaG9sZCB0byB0aGVcbiAgICAvLyByZWFsIGNvbnRleHQgaW5zdGFuY2UuXG4gICAgY29udGV4dFZtID0gcGFyZW50O1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHBhcmVudCA9IHBhcmVudC5fb3JpZ2luYWw7XG4gIH1cbiAgdmFyIGlzQ29tcGlsZWQgPSBpc1RydWUob3B0aW9ucy5fY29tcGlsZWQpO1xuICB2YXIgbmVlZE5vcm1hbGl6YXRpb24gPSAhaXNDb21waWxlZDtcblxuICB0aGlzLmRhdGEgPSBkYXRhO1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gIHRoaXMubGlzdGVuZXJzID0gZGF0YS5vbiB8fCBlbXB0eU9iamVjdDtcbiAgdGhpcy5pbmplY3Rpb25zID0gcmVzb2x2ZUluamVjdChvcHRpb25zLmluamVjdCwgcGFyZW50KTtcbiAgdGhpcy5zbG90cyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc29sdmVTbG90cyhjaGlsZHJlbiwgcGFyZW50KTsgfTtcblxuICAvLyBzdXBwb3J0IGZvciBjb21waWxlZCBmdW5jdGlvbmFsIHRlbXBsYXRlXG4gIGlmIChpc0NvbXBpbGVkKSB7XG4gICAgLy8gZXhwb3NpbmcgJG9wdGlvbnMgZm9yIHJlbmRlclN0YXRpYygpXG4gICAgdGhpcy4kb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgLy8gcHJlLXJlc29sdmUgc2xvdHMgZm9yIHJlbmRlclNsb3QoKVxuICAgIHRoaXMuJHNsb3RzID0gdGhpcy5zbG90cygpO1xuICAgIHRoaXMuJHNjb3BlZFNsb3RzID0gZGF0YS5zY29wZWRTbG90cyB8fCBlbXB0eU9iamVjdDtcbiAgfVxuXG4gIGlmIChvcHRpb25zLl9zY29wZUlkKSB7XG4gICAgdGhpcy5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XG4gICAgICB2YXIgdm5vZGUgPSBjcmVhdGVFbGVtZW50KGNvbnRleHRWbSwgYSwgYiwgYywgZCwgbmVlZE5vcm1hbGl6YXRpb24pO1xuICAgICAgaWYgKHZub2RlICYmICFBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgICB2bm9kZS5mblNjb3BlSWQgPSBvcHRpb25zLl9zY29wZUlkO1xuICAgICAgICB2bm9kZS5mbkNvbnRleHQgPSBwYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm5vZGVcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudChjb250ZXh0Vm0sIGEsIGIsIGMsIGQsIG5lZWROb3JtYWxpemF0aW9uKTsgfTtcbiAgfVxufVxuXG5pbnN0YWxsUmVuZGVySGVscGVycyhGdW5jdGlvbmFsUmVuZGVyQ29udGV4dC5wcm90b3R5cGUpO1xuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgcHJvcHNEYXRhLFxuICBkYXRhLFxuICBjb250ZXh0Vm0sXG4gIGNoaWxkcmVuXG4pIHtcbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIHZhciBwcm9wcyA9IHt9O1xuICB2YXIgcHJvcE9wdGlvbnMgPSBvcHRpb25zLnByb3BzO1xuICBpZiAoaXNEZWYocHJvcE9wdGlvbnMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSB8fCBlbXB0eU9iamVjdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc0RlZihkYXRhLmF0dHJzKSkgeyBtZXJnZVByb3BzKHByb3BzLCBkYXRhLmF0dHJzKTsgfVxuICAgIGlmIChpc0RlZihkYXRhLnByb3BzKSkgeyBtZXJnZVByb3BzKHByb3BzLCBkYXRhLnByb3BzKTsgfVxuICB9XG5cbiAgdmFyIHJlbmRlckNvbnRleHQgPSBuZXcgRnVuY3Rpb25hbFJlbmRlckNvbnRleHQoXG4gICAgZGF0YSxcbiAgICBwcm9wcyxcbiAgICBjaGlsZHJlbixcbiAgICBjb250ZXh0Vm0sXG4gICAgQ3RvclxuICApO1xuXG4gIHZhciB2bm9kZSA9IG9wdGlvbnMucmVuZGVyLmNhbGwobnVsbCwgcmVuZGVyQ29udGV4dC5fYywgcmVuZGVyQ29udGV4dCk7XG5cbiAgaWYgKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICByZXR1cm4gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCh2bm9kZSwgZGF0YSwgcmVuZGVyQ29udGV4dC5wYXJlbnQsIG9wdGlvbnMpXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICB2YXIgdm5vZGVzID0gbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUpIHx8IFtdO1xuICAgIHZhciByZXMgPSBuZXcgQXJyYXkodm5vZGVzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc1tpXSA9IGNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQodm5vZGVzW2ldLCBkYXRhLCByZW5kZXJDb250ZXh0LnBhcmVudCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfVxufVxuXG5mdW5jdGlvbiBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0ICh2bm9kZSwgZGF0YSwgY29udGV4dFZtLCBvcHRpb25zKSB7XG4gIC8vICM3ODE3IGNsb25lIG5vZGUgYmVmb3JlIHNldHRpbmcgZm5Db250ZXh0LCBvdGhlcndpc2UgaWYgdGhlIG5vZGUgaXMgcmV1c2VkXG4gIC8vIChlLmcuIGl0IHdhcyBmcm9tIGEgY2FjaGVkIG5vcm1hbCBzbG90KSB0aGUgZm5Db250ZXh0IGNhdXNlcyBuYW1lZCBzbG90c1xuICAvLyB0aGF0IHNob3VsZCBub3QgYmUgbWF0Y2hlZCB0byBtYXRjaC5cbiAgdmFyIGNsb25lID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gIGNsb25lLmZuQ29udGV4dCA9IGNvbnRleHRWbTtcbiAgY2xvbmUuZm5PcHRpb25zID0gb3B0aW9ucztcbiAgaWYgKGRhdGEuc2xvdCkge1xuICAgIChjbG9uZS5kYXRhIHx8IChjbG9uZS5kYXRhID0ge30pKS5zbG90ID0gZGF0YS5zbG90O1xuICB9XG4gIHJldHVybiBjbG9uZVxufVxuXG5mdW5jdGlvbiBtZXJnZVByb3BzICh0bywgZnJvbSkge1xuICBmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuICAgIHRvW2NhbWVsaXplKGtleSldID0gZnJvbVtrZXldO1xuICB9XG59XG5cbi8qICAqL1xuXG5cblxuXG4vLyBSZWdpc3RlciB0aGUgY29tcG9uZW50IGhvb2sgdG8gd2VleCBuYXRpdmUgcmVuZGVyIGVuZ2luZS5cbi8vIFRoZSBob29rIHdpbGwgYmUgdHJpZ2dlcmVkIGJ5IG5hdGl2ZSwgbm90IGphdmFzY3JpcHQuXG5cblxuLy8gVXBkYXRlcyB0aGUgc3RhdGUgb2YgdGhlIGNvbXBvbmVudCB0byB3ZWV4IG5hdGl2ZSByZW5kZXIgZW5naW5lLlxuXG4vKiAgKi9cblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL0hhbmtzMTAxMDAvd2VleC1uYXRpdmUtZGlyZWN0aXZlL3RyZWUvbWFzdGVyL2NvbXBvbmVudFxuXG4vLyBsaXN0ZW5pbmcgb24gbmF0aXZlIGNhbGxiYWNrXG5cbi8qICAqL1xuXG4vKiAgKi9cblxuLy8gaW5saW5lIGhvb2tzIHRvIGJlIGludm9rZWQgb24gY29tcG9uZW50IFZOb2RlcyBkdXJpbmcgcGF0Y2hcbnZhciBjb21wb25lbnRWTm9kZUhvb2tzID0ge1xuICBpbml0OiBmdW5jdGlvbiBpbml0IChcbiAgICB2bm9kZSxcbiAgICBoeWRyYXRpbmcsXG4gICAgcGFyZW50RWxtLFxuICAgIHJlZkVsbVxuICApIHtcbiAgICBpZiAoXG4gICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJlxuICAgICAgIXZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCAmJlxuICAgICAgdm5vZGUuZGF0YS5rZWVwQWxpdmVcbiAgICApIHtcbiAgICAgIC8vIGtlcHQtYWxpdmUgY29tcG9uZW50cywgdHJlYXQgYXMgYSBwYXRjaFxuICAgICAgdmFyIG1vdW50ZWROb2RlID0gdm5vZGU7IC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICAgIGNvbXBvbmVudFZOb2RlSG9va3MucHJlcGF0Y2gobW91bnRlZE5vZGUsIG1vdW50ZWROb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlKFxuICAgICAgICB2bm9kZSxcbiAgICAgICAgYWN0aXZlSW5zdGFuY2UsXG4gICAgICAgIHBhcmVudEVsbSxcbiAgICAgICAgcmVmRWxtXG4gICAgICApO1xuICAgICAgY2hpbGQuJG1vdW50KGh5ZHJhdGluZyA/IHZub2RlLmVsbSA6IHVuZGVmaW5lZCwgaHlkcmF0aW5nKTtcbiAgICB9XG4gIH0sXG5cbiAgcHJlcGF0Y2g6IGZ1bmN0aW9uIHByZXBhdGNoIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICB1cGRhdGVDaGlsZENvbXBvbmVudChcbiAgICAgIGNoaWxkLFxuICAgICAgb3B0aW9ucy5wcm9wc0RhdGEsIC8vIHVwZGF0ZWQgcHJvcHNcbiAgICAgIG9wdGlvbnMubGlzdGVuZXJzLCAvLyB1cGRhdGVkIGxpc3RlbmVyc1xuICAgICAgdm5vZGUsIC8vIG5ldyBwYXJlbnQgdm5vZGVcbiAgICAgIG9wdGlvbnMuY2hpbGRyZW4gLy8gbmV3IGNoaWxkcmVuXG4gICAgKTtcbiAgfSxcblxuICBpbnNlcnQ6IGZ1bmN0aW9uIGluc2VydCAodm5vZGUpIHtcbiAgICB2YXIgY29udGV4dCA9IHZub2RlLmNvbnRleHQ7XG4gICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgaWYgKCFjb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkKSB7XG4gICAgICBjb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgIGNhbGxIb29rKGNvbXBvbmVudEluc3RhbmNlLCAnbW91bnRlZCcpO1xuICAgIH1cbiAgICBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgIGlmIChjb250ZXh0Ll9pc01vdW50ZWQpIHtcbiAgICAgICAgLy8gdnVlLXJvdXRlciMxMjEyXG4gICAgICAgIC8vIER1cmluZyB1cGRhdGVzLCBhIGtlcHQtYWxpdmUgY29tcG9uZW50J3MgY2hpbGQgY29tcG9uZW50cyBtYXlcbiAgICAgICAgLy8gY2hhbmdlLCBzbyBkaXJlY3RseSB3YWxraW5nIHRoZSB0cmVlIGhlcmUgbWF5IGNhbGwgYWN0aXZhdGVkIGhvb2tzXG4gICAgICAgIC8vIG9uIGluY29ycmVjdCBjaGlsZHJlbi4gSW5zdGVhZCB3ZSBwdXNoIHRoZW0gaW50byBhIHF1ZXVlIHdoaWNoIHdpbGxcbiAgICAgICAgLy8gYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSB3aG9sZSBwYXRjaCBwcm9jZXNzIGVuZGVkLlxuICAgICAgICBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgaWYgKCFjb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQpIHtcbiAgICAgIGlmICghdm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgICAgY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIGhvb2tzVG9NZXJnZSA9IE9iamVjdC5rZXlzKGNvbXBvbmVudFZOb2RlSG9va3MpO1xuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKFxuICBDdG9yLFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlbixcbiAgdGFnXG4pIHtcbiAgaWYgKGlzVW5kZWYoQ3RvcikpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBiYXNlQ3RvciA9IGNvbnRleHQuJG9wdGlvbnMuX2Jhc2U7XG5cbiAgLy8gcGxhaW4gb3B0aW9ucyBvYmplY3Q6IHR1cm4gaXQgaW50byBhIGNvbnN0cnVjdG9yXG4gIGlmIChpc09iamVjdChDdG9yKSkge1xuICAgIEN0b3IgPSBiYXNlQ3Rvci5leHRlbmQoQ3Rvcik7XG4gIH1cblxuICAvLyBpZiBhdCB0aGlzIHN0YWdlIGl0J3Mgbm90IGEgY29uc3RydWN0b3Igb3IgYW4gYXN5bmMgY29tcG9uZW50IGZhY3RvcnksXG4gIC8vIHJlamVjdC5cbiAgaWYgKHR5cGVvZiBDdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgd2FybigoXCJJbnZhbGlkIENvbXBvbmVudCBkZWZpbml0aW9uOiBcIiArIChTdHJpbmcoQ3RvcikpKSwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gYXN5bmMgY29tcG9uZW50XG4gIHZhciBhc3luY0ZhY3Rvcnk7XG4gIGlmIChpc1VuZGVmKEN0b3IuY2lkKSkge1xuICAgIGFzeW5jRmFjdG9yeSA9IEN0b3I7XG4gICAgQ3RvciA9IHJlc29sdmVBc3luY0NvbXBvbmVudChhc3luY0ZhY3RvcnksIGJhc2VDdG9yLCBjb250ZXh0KTtcbiAgICBpZiAoQ3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciBub2RlIGZvciBhc3luYyBjb21wb25lbnQsIHdoaWNoIGlzIHJlbmRlcmVkXG4gICAgICAvLyBhcyBhIGNvbW1lbnQgbm9kZSBidXQgcHJlc2VydmVzIGFsbCB0aGUgcmF3IGluZm9ybWF0aW9uIGZvciB0aGUgbm9kZS5cbiAgICAgIC8vIHRoZSBpbmZvcm1hdGlvbiB3aWxsIGJlIHVzZWQgZm9yIGFzeW5jIHNlcnZlci1yZW5kZXJpbmcgYW5kIGh5ZHJhdGlvbi5cbiAgICAgIHJldHVybiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyKFxuICAgICAgICBhc3luY0ZhY3RvcnksXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICB0YWdcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICBkYXRhID0gZGF0YSB8fCB7fTtcblxuICAvLyByZXNvbHZlIGNvbnN0cnVjdG9yIG9wdGlvbnMgaW4gY2FzZSBnbG9iYWwgbWl4aW5zIGFyZSBhcHBsaWVkIGFmdGVyXG4gIC8vIGNvbXBvbmVudCBjb25zdHJ1Y3RvciBjcmVhdGlvblxuICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3IpO1xuXG4gIC8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBkYXRhIGludG8gcHJvcHMgJiBldmVudHNcbiAgaWYgKGlzRGVmKGRhdGEubW9kZWwpKSB7XG4gICAgdHJhbnNmb3JtTW9kZWwoQ3Rvci5vcHRpb25zLCBkYXRhKTtcbiAgfVxuXG4gIC8vIGV4dHJhY3QgcHJvcHNcbiAgdmFyIHByb3BzRGF0YSA9IGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEoZGF0YSwgQ3RvciwgdGFnKTtcblxuICAvLyBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5mdW5jdGlvbmFsKSkge1xuICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50KEN0b3IsIHByb3BzRGF0YSwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pXG4gIH1cblxuICAvLyBleHRyYWN0IGxpc3RlbmVycywgc2luY2UgdGhlc2UgbmVlZHMgdG8gYmUgdHJlYXRlZCBhc1xuICAvLyBjaGlsZCBjb21wb25lbnQgbGlzdGVuZXJzIGluc3RlYWQgb2YgRE9NIGxpc3RlbmVyc1xuICB2YXIgbGlzdGVuZXJzID0gZGF0YS5vbjtcbiAgLy8gcmVwbGFjZSB3aXRoIGxpc3RlbmVycyB3aXRoIC5uYXRpdmUgbW9kaWZpZXJcbiAgLy8gc28gaXQgZ2V0cyBwcm9jZXNzZWQgZHVyaW5nIHBhcmVudCBjb21wb25lbnQgcGF0Y2guXG4gIGRhdGEub24gPSBkYXRhLm5hdGl2ZU9uO1xuXG4gIGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmFic3RyYWN0KSkge1xuICAgIC8vIGFic3RyYWN0IGNvbXBvbmVudHMgZG8gbm90IGtlZXAgYW55dGhpbmdcbiAgICAvLyBvdGhlciB0aGFuIHByb3BzICYgbGlzdGVuZXJzICYgc2xvdFxuXG4gICAgLy8gd29yayBhcm91bmQgZmxvd1xuICAgIHZhciBzbG90ID0gZGF0YS5zbG90O1xuICAgIGRhdGEgPSB7fTtcbiAgICBpZiAoc2xvdCkge1xuICAgICAgZGF0YS5zbG90ID0gc2xvdDtcbiAgICB9XG4gIH1cblxuICAvLyBpbnN0YWxsIGNvbXBvbmVudCBtYW5hZ2VtZW50IGhvb2tzIG9udG8gdGhlIHBsYWNlaG9sZGVyIG5vZGVcbiAgaW5zdGFsbENvbXBvbmVudEhvb2tzKGRhdGEpO1xuXG4gIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIHZub2RlXG4gIHZhciBuYW1lID0gQ3Rvci5vcHRpb25zLm5hbWUgfHwgdGFnO1xuICB2YXIgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgKFwidnVlLWNvbXBvbmVudC1cIiArIChDdG9yLmNpZCkgKyAobmFtZSA/IChcIi1cIiArIG5hbWUpIDogJycpKSxcbiAgICBkYXRhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0LFxuICAgIHsgQ3RvcjogQ3RvciwgcHJvcHNEYXRhOiBwcm9wc0RhdGEsIGxpc3RlbmVyczogbGlzdGVuZXJzLCB0YWc6IHRhZywgY2hpbGRyZW46IGNoaWxkcmVuIH0sXG4gICAgYXN5bmNGYWN0b3J5XG4gICk7XG5cbiAgLy8gV2VleCBzcGVjaWZpYzogaW52b2tlIHJlY3ljbGUtbGlzdCBvcHRpbWl6ZWQgQHJlbmRlciBmdW5jdGlvbiBmb3JcbiAgLy8gZXh0cmFjdGluZyBjZWxsLXNsb3QgdGVtcGxhdGUuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9IYW5rczEwMTAwL3dlZXgtbmF0aXZlLWRpcmVjdGl2ZS90cmVlL21hc3Rlci9jb21wb25lbnRcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIHJldHVybiB2bm9kZVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlIChcbiAgdm5vZGUsIC8vIHdlIGtub3cgaXQncyBNb3VudGVkQ29tcG9uZW50Vk5vZGUgYnV0IGZsb3cgZG9lc24ndFxuICBwYXJlbnQsIC8vIGFjdGl2ZUluc3RhbmNlIGluIGxpZmVjeWNsZSBzdGF0ZVxuICBwYXJlbnRFbG0sXG4gIHJlZkVsbVxuKSB7XG4gIHZhciBvcHRpb25zID0ge1xuICAgIF9pc0NvbXBvbmVudDogdHJ1ZSxcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICBfcGFyZW50Vm5vZGU6IHZub2RlLFxuICAgIF9wYXJlbnRFbG06IHBhcmVudEVsbSB8fCBudWxsLFxuICAgIF9yZWZFbG06IHJlZkVsbSB8fCBudWxsXG4gIH07XG4gIC8vIGNoZWNrIGlubGluZS10ZW1wbGF0ZSByZW5kZXIgZnVuY3Rpb25zXG4gIHZhciBpbmxpbmVUZW1wbGF0ZSA9IHZub2RlLmRhdGEuaW5saW5lVGVtcGxhdGU7XG4gIGlmIChpc0RlZihpbmxpbmVUZW1wbGF0ZSkpIHtcbiAgICBvcHRpb25zLnJlbmRlciA9IGlubGluZVRlbXBsYXRlLnJlbmRlcjtcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGlubGluZVRlbXBsYXRlLnN0YXRpY1JlbmRlckZucztcbiAgfVxuICByZXR1cm4gbmV3IHZub2RlLmNvbXBvbmVudE9wdGlvbnMuQ3RvcihvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBpbnN0YWxsQ29tcG9uZW50SG9va3MgKGRhdGEpIHtcbiAgdmFyIGhvb2tzID0gZGF0YS5ob29rIHx8IChkYXRhLmhvb2sgPSB7fSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3NUb01lcmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGhvb2tzVG9NZXJnZVtpXTtcbiAgICBob29rc1trZXldID0gY29tcG9uZW50Vk5vZGVIb29rc1trZXldO1xuICB9XG59XG5cbi8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBpbmZvICh2YWx1ZSBhbmQgY2FsbGJhY2spIGludG9cbi8vIHByb3AgYW5kIGV2ZW50IGhhbmRsZXIgcmVzcGVjdGl2ZWx5LlxuZnVuY3Rpb24gdHJhbnNmb3JtTW9kZWwgKG9wdGlvbnMsIGRhdGEpIHtcbiAgdmFyIHByb3AgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLnByb3ApIHx8ICd2YWx1ZSc7XG4gIHZhciBldmVudCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwuZXZlbnQpIHx8ICdpbnB1dCc7KGRhdGEucHJvcHMgfHwgKGRhdGEucHJvcHMgPSB7fSkpW3Byb3BdID0gZGF0YS5tb2RlbC52YWx1ZTtcbiAgdmFyIG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcbiAgaWYgKGlzRGVmKG9uW2V2ZW50XSkpIHtcbiAgICBvbltldmVudF0gPSBbZGF0YS5tb2RlbC5jYWxsYmFja10uY29uY2F0KG9uW2V2ZW50XSk7XG4gIH0gZWxzZSB7XG4gICAgb25bZXZlbnRdID0gZGF0YS5tb2RlbC5jYWxsYmFjaztcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIFNJTVBMRV9OT1JNQUxJWkUgPSAxO1xudmFyIEFMV0FZU19OT1JNQUxJWkUgPSAyO1xuXG4vLyB3cmFwcGVyIGZ1bmN0aW9uIGZvciBwcm92aWRpbmcgYSBtb3JlIGZsZXhpYmxlIGludGVyZmFjZVxuLy8gd2l0aG91dCBnZXR0aW5nIHllbGxlZCBhdCBieSBmbG93XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGUsXG4gIGFsd2F5c05vcm1hbGl6ZVxuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGRhdGEpIHx8IGlzUHJpbWl0aXZlKGRhdGEpKSB7XG4gICAgbm9ybWFsaXphdGlvblR5cGUgPSBjaGlsZHJlbjtcbiAgICBjaGlsZHJlbiA9IGRhdGE7XG4gICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoaXNUcnVlKGFsd2F5c05vcm1hbGl6ZSkpIHtcbiAgICBub3JtYWxpemF0aW9uVHlwZSA9IEFMV0FZU19OT1JNQUxJWkU7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVFbGVtZW50KGNvbnRleHQsIHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlKVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlRWxlbWVudCAoXG4gIGNvbnRleHQsXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIG5vcm1hbGl6YXRpb25UeXBlXG4pIHtcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKChkYXRhKS5fX29iX18pKSB7XG4gICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiQXZvaWQgdXNpbmcgb2JzZXJ2ZWQgZGF0YSBvYmplY3QgYXMgdm5vZGUgZGF0YTogXCIgKyAoSlNPTi5zdHJpbmdpZnkoZGF0YSkpICsgXCJcXG5cIiArXG4gICAgICAnQWx3YXlzIGNyZWF0ZSBmcmVzaCB2bm9kZSBkYXRhIG9iamVjdHMgaW4gZWFjaCByZW5kZXIhJyxcbiAgICAgIGNvbnRleHRcbiAgICApO1xuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxuICAvLyBvYmplY3Qgc3ludGF4IGluIHYtYmluZFxuICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoZGF0YS5pcykpIHtcbiAgICB0YWcgPSBkYXRhLmlzO1xuICB9XG4gIGlmICghdGFnKSB7XG4gICAgLy8gaW4gY2FzZSBvZiBjb21wb25lbnQgOmlzIHNldCB0byBmYWxzeSB2YWx1ZVxuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxuICAvLyB3YXJuIGFnYWluc3Qgbm9uLXByaW1pdGl2ZSBrZXlcbiAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgaXNEZWYoZGF0YSkgJiYgaXNEZWYoZGF0YS5rZXkpICYmICFpc1ByaW1pdGl2ZShkYXRhLmtleSlcbiAgKSB7XG4gICAge1xuICAgICAgd2FybihcbiAgICAgICAgJ0F2b2lkIHVzaW5nIG5vbi1wcmltaXRpdmUgdmFsdWUgYXMga2V5LCAnICtcbiAgICAgICAgJ3VzZSBzdHJpbmcvbnVtYmVyIHZhbHVlIGluc3RlYWQuJyxcbiAgICAgICAgY29udGV4dFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLy8gc3VwcG9ydCBzaW5nbGUgZnVuY3Rpb24gY2hpbGRyZW4gYXMgZGVmYXVsdCBzY29wZWQgc2xvdFxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiZcbiAgICB0eXBlb2YgY2hpbGRyZW5bMF0gPT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgZGF0YS5zY29wZWRTbG90cyA9IHsgZGVmYXVsdDogY2hpbGRyZW5bMF0gfTtcbiAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xuICB9XG4gIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gQUxXQVlTX05PUk1BTElaRSkge1xuICAgIGNoaWxkcmVuID0gbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICB9IGVsc2UgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBTSU1QTEVfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH1cbiAgdmFyIHZub2RlLCBucztcbiAgaWYgKHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIEN0b3I7XG4gICAgbnMgPSAoY29udGV4dC4kdm5vZGUgJiYgY29udGV4dC4kdm5vZGUubnMpIHx8IGNvbmZpZy5nZXRUYWdOYW1lc3BhY2UodGFnKTtcbiAgICBpZiAoY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgICAgLy8gcGxhdGZvcm0gYnVpbHQtaW4gZWxlbWVudHNcbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICBjb25maWcucGFyc2VQbGF0Zm9ybVRhZ05hbWUodGFnKSwgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNEZWYoQ3RvciA9IHJlc29sdmVBc3NldChjb250ZXh0LiRvcHRpb25zLCAnY29tcG9uZW50cycsIHRhZykpKSB7XG4gICAgICAvLyBjb21wb25lbnRcbiAgICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KEN0b3IsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1bmtub3duIG9yIHVubGlzdGVkIG5hbWVzcGFjZWQgZWxlbWVudHNcbiAgICAgIC8vIGNoZWNrIGF0IHJ1bnRpbWUgYmVjYXVzZSBpdCBtYXkgZ2V0IGFzc2lnbmVkIGEgbmFtZXNwYWNlIHdoZW4gaXRzXG4gICAgICAvLyBwYXJlbnQgbm9ybWFsaXplcyBjaGlsZHJlblxuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIHRhZywgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBkaXJlY3QgY29tcG9uZW50IG9wdGlvbnMgLyBjb25zdHJ1Y3RvclxuICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KHRhZywgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgIHJldHVybiB2bm9kZVxuICB9IGVsc2UgaWYgKGlzRGVmKHZub2RlKSkge1xuICAgIGlmIChpc0RlZihucykpIHsgYXBwbHlOUyh2bm9kZSwgbnMpOyB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7IHJlZ2lzdGVyRGVlcEJpbmRpbmdzKGRhdGEpOyB9XG4gICAgcmV0dXJuIHZub2RlXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5TlMgKHZub2RlLCBucywgZm9yY2UpIHtcbiAgdm5vZGUubnMgPSBucztcbiAgaWYgKHZub2RlLnRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgLy8gdXNlIGRlZmF1bHQgbmFtZXNwYWNlIGluc2lkZSBmb3JlaWduT2JqZWN0XG4gICAgbnMgPSB1bmRlZmluZWQ7XG4gICAgZm9yY2UgPSB0cnVlO1xuICB9XG4gIGlmIChpc0RlZih2bm9kZS5jaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY2hpbGRyZW5baV07XG4gICAgICBpZiAoaXNEZWYoY2hpbGQudGFnKSAmJiAoXG4gICAgICAgIGlzVW5kZWYoY2hpbGQubnMpIHx8IChpc1RydWUoZm9yY2UpICYmIGNoaWxkLnRhZyAhPT0gJ3N2ZycpKSkge1xuICAgICAgICBhcHBseU5TKGNoaWxkLCBucywgZm9yY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyByZWYgIzUzMThcbi8vIG5lY2Vzc2FyeSB0byBlbnN1cmUgcGFyZW50IHJlLXJlbmRlciB3aGVuIGRlZXAgYmluZGluZ3MgbGlrZSA6c3R5bGUgYW5kXG4vLyA6Y2xhc3MgYXJlIHVzZWQgb24gc2xvdCBub2Rlc1xuZnVuY3Rpb24gcmVnaXN0ZXJEZWVwQmluZGluZ3MgKGRhdGEpIHtcbiAgaWYgKGlzT2JqZWN0KGRhdGEuc3R5bGUpKSB7XG4gICAgdHJhdmVyc2UoZGF0YS5zdHlsZSk7XG4gIH1cbiAgaWYgKGlzT2JqZWN0KGRhdGEuY2xhc3MpKSB7XG4gICAgdHJhdmVyc2UoZGF0YS5jbGFzcyk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRSZW5kZXIgKHZtKSB7XG4gIHZtLl92bm9kZSA9IG51bGw7IC8vIHRoZSByb290IG9mIHRoZSBjaGlsZCB0cmVlXG4gIHZtLl9zdGF0aWNUcmVlcyA9IG51bGw7IC8vIHYtb25jZSBjYWNoZWQgdHJlZXNcbiAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcbiAgdmFyIHBhcmVudFZub2RlID0gdm0uJHZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7IC8vIHRoZSBwbGFjZWhvbGRlciBub2RlIGluIHBhcmVudCB0cmVlXG4gIHZhciByZW5kZXJDb250ZXh0ID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuY29udGV4dDtcbiAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuLCByZW5kZXJDb250ZXh0KTtcbiAgdm0uJHNjb3BlZFNsb3RzID0gZW1wdHlPYmplY3Q7XG4gIC8vIGJpbmQgdGhlIGNyZWF0ZUVsZW1lbnQgZm4gdG8gdGhpcyBpbnN0YW5jZVxuICAvLyBzbyB0aGF0IHdlIGdldCBwcm9wZXIgcmVuZGVyIGNvbnRleHQgaW5zaWRlIGl0LlxuICAvLyBhcmdzIG9yZGVyOiB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSwgYWx3YXlzTm9ybWFsaXplXG4gIC8vIGludGVybmFsIHZlcnNpb24gaXMgdXNlZCBieSByZW5kZXIgZnVuY3Rpb25zIGNvbXBpbGVkIGZyb20gdGVtcGxhdGVzXG4gIHZtLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIGZhbHNlKTsgfTtcbiAgLy8gbm9ybWFsaXphdGlvbiBpcyBhbHdheXMgYXBwbGllZCBmb3IgdGhlIHB1YmxpYyB2ZXJzaW9uLCB1c2VkIGluXG4gIC8vIHVzZXItd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zLlxuICB2bS4kY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCB0cnVlKTsgfTtcblxuICAvLyAkYXR0cnMgJiAkbGlzdGVuZXJzIGFyZSBleHBvc2VkIGZvciBlYXNpZXIgSE9DIGNyZWF0aW9uLlxuICAvLyB0aGV5IG5lZWQgdG8gYmUgcmVhY3RpdmUgc28gdGhhdCBIT0NzIHVzaW5nIHRoZW0gYXJlIGFsd2F5cyB1cGRhdGVkXG4gIHZhciBwYXJlbnREYXRhID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuZGF0YTtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICB7XG4gICAgZGVmaW5lUmVhY3RpdmUodm0sICckYXR0cnMnLCBwYXJlbnREYXRhICYmIHBhcmVudERhdGEuYXR0cnMgfHwgZW1wdHlPYmplY3QsIGZ1bmN0aW9uICgpIHtcbiAgICAgICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgJiYgd2FybihcIiRhdHRycyBpcyByZWFkb25seS5cIiwgdm0pO1xuICAgIH0sIHRydWUpO1xuICAgIGRlZmluZVJlYWN0aXZlKHZtLCAnJGxpc3RlbmVycycsIG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyB8fCBlbXB0eU9iamVjdCwgZnVuY3Rpb24gKCkge1xuICAgICAgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCAmJiB3YXJuKFwiJGxpc3RlbmVycyBpcyByZWFkb25seS5cIiwgdm0pO1xuICAgIH0sIHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlck1peGluIChWdWUpIHtcbiAgLy8gaW5zdGFsbCBydW50aW1lIGNvbnZlbmllbmNlIGhlbHBlcnNcbiAgaW5zdGFsbFJlbmRlckhlbHBlcnMoVnVlLnByb3RvdHlwZSk7XG5cbiAgVnVlLnByb3RvdHlwZS4kbmV4dFRpY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gbmV4dFRpY2soZm4sIHRoaXMpXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgdmFyIHJlZiA9IHZtLiRvcHRpb25zO1xuICAgIHZhciByZW5kZXIgPSByZWYucmVuZGVyO1xuICAgIHZhciBfcGFyZW50Vm5vZGUgPSByZWYuX3BhcmVudFZub2RlO1xuXG4gICAgLy8gcmVzZXQgX3JlbmRlcmVkIGZsYWcgb24gc2xvdHMgZm9yIGR1cGxpY2F0ZSBzbG90IGNoZWNrXG4gICAge1xuICAgICAgZm9yICh2YXIga2V5IGluIHZtLiRzbG90cykge1xuICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgICAgdm0uJHNsb3RzW2tleV0uX3JlbmRlcmVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKF9wYXJlbnRWbm9kZSkge1xuICAgICAgdm0uJHNjb3BlZFNsb3RzID0gX3BhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMgfHwgZW1wdHlPYmplY3Q7XG4gICAgfVxuXG4gICAgLy8gc2V0IHBhcmVudCB2bm9kZS4gdGhpcyBhbGxvd3MgcmVuZGVyIGZ1bmN0aW9ucyB0byBoYXZlIGFjY2Vzc1xuICAgIC8vIHRvIHRoZSBkYXRhIG9uIHRoZSBwbGFjZWhvbGRlciBub2RlLlxuICAgIHZtLiR2bm9kZSA9IF9wYXJlbnRWbm9kZTtcbiAgICAvLyByZW5kZXIgc2VsZlxuICAgIHZhciB2bm9kZTtcbiAgICB0cnkge1xuICAgICAgdm5vZGUgPSByZW5kZXIuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJyZW5kZXJcIik7XG4gICAgICAvLyByZXR1cm4gZXJyb3IgcmVuZGVyIHJlc3VsdCxcbiAgICAgIC8vIG9yIHByZXZpb3VzIHZub2RlIHRvIHByZXZlbnQgcmVuZGVyIGVycm9yIGNhdXNpbmcgYmxhbmsgY29tcG9uZW50XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAge1xuICAgICAgICBpZiAodm0uJG9wdGlvbnMucmVuZGVyRXJyb3IpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdm5vZGUgPSB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQsIGUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcInJlbmRlckVycm9yXCIpO1xuICAgICAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHJldHVybiBlbXB0eSB2bm9kZSBpbiBjYXNlIHRoZSByZW5kZXIgZnVuY3Rpb24gZXJyb3JlZCBvdXRcbiAgICBpZiAoISh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSkge1xuICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ011bHRpcGxlIHJvb3Qgbm9kZXMgcmV0dXJuZWQgZnJvbSByZW5kZXIgZnVuY3Rpb24uIFJlbmRlciBmdW5jdGlvbiAnICtcbiAgICAgICAgICAnc2hvdWxkIHJldHVybiBhIHNpbmdsZSByb290IG5vZGUuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdm5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gICAgfVxuICAgIC8vIHNldCBwYXJlbnRcbiAgICB2bm9kZS5wYXJlbnQgPSBfcGFyZW50Vm5vZGU7XG4gICAgcmV0dXJuIHZub2RlXG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgdWlkJDMgPSAwO1xuXG5mdW5jdGlvbiBpbml0TWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGEgdWlkXG4gICAgdm0uX3VpZCA9IHVpZCQzKys7XG5cbiAgICB2YXIgc3RhcnRUYWcsIGVuZFRhZztcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArICh2bS5fdWlkKTtcbiAgICAgIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgKHZtLl91aWQpO1xuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgfVxuXG4gICAgLy8gYSBmbGFnIHRvIGF2b2lkIHRoaXMgYmVpbmcgb2JzZXJ2ZWRcbiAgICB2bS5faXNWdWUgPSB0cnVlO1xuICAgIC8vIG1lcmdlIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLl9pc0NvbXBvbmVudCkge1xuICAgICAgLy8gb3B0aW1pemUgaW50ZXJuYWwgY29tcG9uZW50IGluc3RhbnRpYXRpb25cbiAgICAgIC8vIHNpbmNlIGR5bmFtaWMgb3B0aW9ucyBtZXJnaW5nIGlzIHByZXR0eSBzbG93LCBhbmQgbm9uZSBvZiB0aGVcbiAgICAgIC8vIGludGVybmFsIGNvbXBvbmVudCBvcHRpb25zIG5lZWRzIHNwZWNpYWwgdHJlYXRtZW50LlxuICAgICAgaW5pdEludGVybmFsQ29tcG9uZW50KHZtLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uJG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICAgIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnModm0uY29uc3RydWN0b3IpLFxuICAgICAgICBvcHRpb25zIHx8IHt9LFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICB7XG4gICAgICBpbml0UHJveHkodm0pO1xuICAgIH1cbiAgICAvLyBleHBvc2UgcmVhbCBzZWxmXG4gICAgdm0uX3NlbGYgPSB2bTtcbiAgICBpbml0TGlmZWN5Y2xlKHZtKTtcbiAgICBpbml0RXZlbnRzKHZtKTtcbiAgICBpbml0UmVuZGVyKHZtKTtcbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZUNyZWF0ZScpO1xuICAgIGluaXRJbmplY3Rpb25zKHZtKTsgLy8gcmVzb2x2ZSBpbmplY3Rpb25zIGJlZm9yZSBkYXRhL3Byb3BzXG4gICAgaW5pdFN0YXRlKHZtKTtcbiAgICBpbml0UHJvdmlkZSh2bSk7IC8vIHJlc29sdmUgcHJvdmlkZSBhZnRlciBkYXRhL3Byb3BzXG4gICAgY2FsbEhvb2sodm0sICdjcmVhdGVkJyk7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHZtLl9uYW1lID0gZm9ybWF0Q29tcG9uZW50TmFtZSh2bSwgZmFsc2UpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyAodm0uX25hbWUpICsgXCIgaW5pdFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgfVxuXG4gICAgaWYgKHZtLiRvcHRpb25zLmVsKSB7XG4gICAgICB2bS4kbW91bnQodm0uJG9wdGlvbnMuZWwpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdEludGVybmFsQ29tcG9uZW50ICh2bSwgb3B0aW9ucykge1xuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh2bS5jb25zdHJ1Y3Rvci5vcHRpb25zKTtcbiAgLy8gZG9pbmcgdGhpcyBiZWNhdXNlIGl0J3MgZmFzdGVyIHRoYW4gZHluYW1pYyBlbnVtZXJhdGlvbi5cbiAgdmFyIHBhcmVudFZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7XG4gIG9wdHMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIG9wdHMuX3BhcmVudFZub2RlID0gcGFyZW50Vm5vZGU7XG4gIG9wdHMuX3BhcmVudEVsbSA9IG9wdGlvbnMuX3BhcmVudEVsbTtcbiAgb3B0cy5fcmVmRWxtID0gb3B0aW9ucy5fcmVmRWxtO1xuXG4gIHZhciB2bm9kZUNvbXBvbmVudE9wdGlvbnMgPSBwYXJlbnRWbm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBvcHRzLnByb3BzRGF0YSA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGE7XG4gIG9wdHMuX3BhcmVudExpc3RlbmVycyA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5saXN0ZW5lcnM7XG4gIG9wdHMuX3JlbmRlckNoaWxkcmVuID0gdm5vZGVDb21wb25lbnRPcHRpb25zLmNoaWxkcmVuO1xuICBvcHRzLl9jb21wb25lbnRUYWcgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMudGFnO1xuXG4gIGlmIChvcHRpb25zLnJlbmRlcikge1xuICAgIG9wdHMucmVuZGVyID0gb3B0aW9ucy5yZW5kZXI7XG4gICAgb3B0cy5zdGF0aWNSZW5kZXJGbnMgPSBvcHRpb25zLnN0YXRpY1JlbmRlckZucztcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zIChDdG9yKSB7XG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICBpZiAoQ3Rvci5zdXBlcikge1xuICAgIHZhciBzdXBlck9wdGlvbnMgPSByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3Iuc3VwZXIpO1xuICAgIHZhciBjYWNoZWRTdXBlck9wdGlvbnMgPSBDdG9yLnN1cGVyT3B0aW9ucztcbiAgICBpZiAoc3VwZXJPcHRpb25zICE9PSBjYWNoZWRTdXBlck9wdGlvbnMpIHtcbiAgICAgIC8vIHN1cGVyIG9wdGlvbiBjaGFuZ2VkLFxuICAgICAgLy8gbmVlZCB0byByZXNvbHZlIG5ldyBvcHRpb25zLlxuICAgICAgQ3Rvci5zdXBlck9wdGlvbnMgPSBzdXBlck9wdGlvbnM7XG4gICAgICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgYW55IGxhdGUtbW9kaWZpZWQvYXR0YWNoZWQgb3B0aW9ucyAoIzQ5NzYpXG4gICAgICB2YXIgbW9kaWZpZWRPcHRpb25zID0gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyhDdG9yKTtcbiAgICAgIC8vIHVwZGF0ZSBiYXNlIGV4dGVuZCBvcHRpb25zXG4gICAgICBpZiAobW9kaWZpZWRPcHRpb25zKSB7XG4gICAgICAgIGV4dGVuZChDdG9yLmV4dGVuZE9wdGlvbnMsIG1vZGlmaWVkT3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBvcHRpb25zID0gQ3Rvci5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHN1cGVyT3B0aW9ucywgQ3Rvci5leHRlbmRPcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgb3B0aW9ucy5jb21wb25lbnRzW29wdGlvbnMubmFtZV0gPSBDdG9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb3B0aW9uc1xufVxuXG5mdW5jdGlvbiByZXNvbHZlTW9kaWZpZWRPcHRpb25zIChDdG9yKSB7XG4gIHZhciBtb2RpZmllZDtcbiAgdmFyIGxhdGVzdCA9IEN0b3Iub3B0aW9ucztcbiAgdmFyIGV4dGVuZGVkID0gQ3Rvci5leHRlbmRPcHRpb25zO1xuICB2YXIgc2VhbGVkID0gQ3Rvci5zZWFsZWRPcHRpb25zO1xuICBmb3IgKHZhciBrZXkgaW4gbGF0ZXN0KSB7XG4gICAgaWYgKGxhdGVzdFtrZXldICE9PSBzZWFsZWRba2V5XSkge1xuICAgICAgaWYgKCFtb2RpZmllZCkgeyBtb2RpZmllZCA9IHt9OyB9XG4gICAgICBtb2RpZmllZFtrZXldID0gZGVkdXBlKGxhdGVzdFtrZXldLCBleHRlbmRlZFtrZXldLCBzZWFsZWRba2V5XSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtb2RpZmllZFxufVxuXG5mdW5jdGlvbiBkZWR1cGUgKGxhdGVzdCwgZXh0ZW5kZWQsIHNlYWxlZCkge1xuICAvLyBjb21wYXJlIGxhdGVzdCBhbmQgc2VhbGVkIHRvIGVuc3VyZSBsaWZlY3ljbGUgaG9va3Mgd29uJ3QgYmUgZHVwbGljYXRlZFxuICAvLyBiZXR3ZWVuIG1lcmdlc1xuICBpZiAoQXJyYXkuaXNBcnJheShsYXRlc3QpKSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIHNlYWxlZCA9IEFycmF5LmlzQXJyYXkoc2VhbGVkKSA/IHNlYWxlZCA6IFtzZWFsZWRdO1xuICAgIGV4dGVuZGVkID0gQXJyYXkuaXNBcnJheShleHRlbmRlZCkgPyBleHRlbmRlZCA6IFtleHRlbmRlZF07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXRlc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIHB1c2ggb3JpZ2luYWwgb3B0aW9ucyBhbmQgbm90IHNlYWxlZCBvcHRpb25zIHRvIGV4Y2x1ZGUgZHVwbGljYXRlZCBvcHRpb25zXG4gICAgICBpZiAoZXh0ZW5kZWQuaW5kZXhPZihsYXRlc3RbaV0pID49IDAgfHwgc2VhbGVkLmluZGV4T2YobGF0ZXN0W2ldKSA8IDApIHtcbiAgICAgICAgcmVzLnB1c2gobGF0ZXN0W2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsYXRlc3RcbiAgfVxufVxuXG5mdW5jdGlvbiBWdWUgKG9wdGlvbnMpIHtcbiAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgISh0aGlzIGluc3RhbmNlb2YgVnVlKVxuICApIHtcbiAgICB3YXJuKCdWdWUgaXMgYSBjb25zdHJ1Y3RvciBhbmQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkJyk7XG4gIH1cbiAgdGhpcy5faW5pdChvcHRpb25zKTtcbn1cblxuaW5pdE1peGluKFZ1ZSk7XG5zdGF0ZU1peGluKFZ1ZSk7XG5ldmVudHNNaXhpbihWdWUpO1xubGlmZWN5Y2xlTWl4aW4oVnVlKTtcbnJlbmRlck1peGluKFZ1ZSk7XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0VXNlIChWdWUpIHtcbiAgVnVlLnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICB2YXIgaW5zdGFsbGVkUGx1Z2lucyA9ICh0aGlzLl9pbnN0YWxsZWRQbHVnaW5zIHx8ICh0aGlzLl9pbnN0YWxsZWRQbHVnaW5zID0gW10pKTtcbiAgICBpZiAoaW5zdGFsbGVkUGx1Z2lucy5pbmRleE9mKHBsdWdpbikgPiAtMSkge1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvLyBhZGRpdGlvbmFsIHBhcmFtZXRlcnNcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgaWYgKHR5cGVvZiBwbHVnaW4uaW5zdGFsbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGx1Z2luLmluc3RhbGwuYXBwbHkocGx1Z2luLCBhcmdzKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwbHVnaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9XG4gICAgaW5zdGFsbGVkUGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgcmV0dXJuIHRoaXNcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRNaXhpbiQxIChWdWUpIHtcbiAgVnVlLm1peGluID0gZnVuY3Rpb24gKG1peGluKSB7XG4gICAgdGhpcy5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHRoaXMub3B0aW9ucywgbWl4aW4pO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0RXh0ZW5kIChWdWUpIHtcbiAgLyoqXG4gICAqIEVhY2ggaW5zdGFuY2UgY29uc3RydWN0b3IsIGluY2x1ZGluZyBWdWUsIGhhcyBhIHVuaXF1ZVxuICAgKiBjaWQuIFRoaXMgZW5hYmxlcyB1cyB0byBjcmVhdGUgd3JhcHBlZCBcImNoaWxkXG4gICAqIGNvbnN0cnVjdG9yc1wiIGZvciBwcm90b3R5cGFsIGluaGVyaXRhbmNlIGFuZCBjYWNoZSB0aGVtLlxuICAgKi9cbiAgVnVlLmNpZCA9IDA7XG4gIHZhciBjaWQgPSAxO1xuXG4gIC8qKlxuICAgKiBDbGFzcyBpbmhlcml0YW5jZVxuICAgKi9cbiAgVnVlLmV4dGVuZCA9IGZ1bmN0aW9uIChleHRlbmRPcHRpb25zKSB7XG4gICAgZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnMgfHwge307XG4gICAgdmFyIFN1cGVyID0gdGhpcztcbiAgICB2YXIgU3VwZXJJZCA9IFN1cGVyLmNpZDtcbiAgICB2YXIgY2FjaGVkQ3RvcnMgPSBleHRlbmRPcHRpb25zLl9DdG9yIHx8IChleHRlbmRPcHRpb25zLl9DdG9yID0ge30pO1xuICAgIGlmIChjYWNoZWRDdG9yc1tTdXBlcklkXSkge1xuICAgICAgcmV0dXJuIGNhY2hlZEN0b3JzW1N1cGVySWRdXG4gICAgfVxuXG4gICAgdmFyIG5hbWUgPSBleHRlbmRPcHRpb25zLm5hbWUgfHwgU3VwZXIub3B0aW9ucy5uYW1lO1xuICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBuYW1lKSB7XG4gICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIFN1YiA9IGZ1bmN0aW9uIFZ1ZUNvbXBvbmVudCAob3B0aW9ucykge1xuICAgICAgdGhpcy5faW5pdChvcHRpb25zKTtcbiAgICB9O1xuICAgIFN1Yi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN1cGVyLnByb3RvdHlwZSk7XG4gICAgU3ViLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN1YjtcbiAgICBTdWIuY2lkID0gY2lkKys7XG4gICAgU3ViLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICBTdXBlci5vcHRpb25zLFxuICAgICAgZXh0ZW5kT3B0aW9uc1xuICAgICk7XG4gICAgU3ViWydzdXBlciddID0gU3VwZXI7XG5cbiAgICAvLyBGb3IgcHJvcHMgYW5kIGNvbXB1dGVkIHByb3BlcnRpZXMsIHdlIGRlZmluZSB0aGUgcHJveHkgZ2V0dGVycyBvblxuICAgIC8vIHRoZSBWdWUgaW5zdGFuY2VzIGF0IGV4dGVuc2lvbiB0aW1lLCBvbiB0aGUgZXh0ZW5kZWQgcHJvdG90eXBlLiBUaGlzXG4gICAgLy8gYXZvaWRzIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBjYWxscyBmb3IgZWFjaCBpbnN0YW5jZSBjcmVhdGVkLlxuICAgIGlmIChTdWIub3B0aW9ucy5wcm9wcykge1xuICAgICAgaW5pdFByb3BzJDEoU3ViKTtcbiAgICB9XG4gICAgaWYgKFN1Yi5vcHRpb25zLmNvbXB1dGVkKSB7XG4gICAgICBpbml0Q29tcHV0ZWQkMShTdWIpO1xuICAgIH1cblxuICAgIC8vIGFsbG93IGZ1cnRoZXIgZXh0ZW5zaW9uL21peGluL3BsdWdpbiB1c2FnZVxuICAgIFN1Yi5leHRlbmQgPSBTdXBlci5leHRlbmQ7XG4gICAgU3ViLm1peGluID0gU3VwZXIubWl4aW47XG4gICAgU3ViLnVzZSA9IFN1cGVyLnVzZTtcblxuICAgIC8vIGNyZWF0ZSBhc3NldCByZWdpc3RlcnMsIHNvIGV4dGVuZGVkIGNsYXNzZXNcbiAgICAvLyBjYW4gaGF2ZSB0aGVpciBwcml2YXRlIGFzc2V0cyB0b28uXG4gICAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgU3ViW3R5cGVdID0gU3VwZXJbdHlwZV07XG4gICAgfSk7XG4gICAgLy8gZW5hYmxlIHJlY3Vyc2l2ZSBzZWxmLWxvb2t1cFxuICAgIGlmIChuYW1lKSB7XG4gICAgICBTdWIub3B0aW9ucy5jb21wb25lbnRzW25hbWVdID0gU3ViO1xuICAgIH1cblxuICAgIC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHN1cGVyIG9wdGlvbnMgYXQgZXh0ZW5zaW9uIHRpbWUuXG4gICAgLy8gbGF0ZXIgYXQgaW5zdGFudGlhdGlvbiB3ZSBjYW4gY2hlY2sgaWYgU3VwZXIncyBvcHRpb25zIGhhdmVcbiAgICAvLyBiZWVuIHVwZGF0ZWQuXG4gICAgU3ViLnN1cGVyT3B0aW9ucyA9IFN1cGVyLm9wdGlvbnM7XG4gICAgU3ViLmV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zO1xuICAgIFN1Yi5zZWFsZWRPcHRpb25zID0gZXh0ZW5kKHt9LCBTdWIub3B0aW9ucyk7XG5cbiAgICAvLyBjYWNoZSBjb25zdHJ1Y3RvclxuICAgIGNhY2hlZEN0b3JzW1N1cGVySWRdID0gU3ViO1xuICAgIHJldHVybiBTdWJcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzJDEgKENvbXApIHtcbiAgdmFyIHByb3BzID0gQ29tcC5vcHRpb25zLnByb3BzO1xuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICBwcm94eShDb21wLnByb3RvdHlwZSwgXCJfcHJvcHNcIiwga2V5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQkMSAoQ29tcCkge1xuICB2YXIgY29tcHV0ZWQgPSBDb21wLm9wdGlvbnMuY29tcHV0ZWQ7XG4gIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgIGRlZmluZUNvbXB1dGVkKENvbXAucHJvdG90eXBlLCBrZXksIGNvbXB1dGVkW2tleV0pO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0QXNzZXRSZWdpc3RlcnMgKFZ1ZSkge1xuICAvKipcbiAgICogQ3JlYXRlIGFzc2V0IHJlZ2lzdHJhdGlvbiBtZXRob2RzLlxuICAgKi9cbiAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIFZ1ZVt0eXBlXSA9IGZ1bmN0aW9uIChcbiAgICAgIGlkLFxuICAgICAgZGVmaW5pdGlvblxuICAgICkge1xuICAgICAgaWYgKCFkZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGUgPT09ICdjb21wb25lbnQnKSB7XG4gICAgICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKGlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgaXNQbGFpbk9iamVjdChkZWZpbml0aW9uKSkge1xuICAgICAgICAgIGRlZmluaXRpb24ubmFtZSA9IGRlZmluaXRpb24ubmFtZSB8fCBpZDtcbiAgICAgICAgICBkZWZpbml0aW9uID0gdGhpcy5vcHRpb25zLl9iYXNlLmV4dGVuZChkZWZpbml0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2RpcmVjdGl2ZScgJiYgdHlwZW9mIGRlZmluaXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBkZWZpbml0aW9uID0geyBiaW5kOiBkZWZpbml0aW9uLCB1cGRhdGU6IGRlZmluaXRpb24gfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdID0gZGVmaW5pdGlvbjtcbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb25cbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUgKG9wdHMpIHtcbiAgcmV0dXJuIG9wdHMgJiYgKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcpXG59XG5cbmZ1bmN0aW9uIG1hdGNoZXMgKHBhdHRlcm4sIG5hbWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi5pbmRleE9mKG5hbWUpID4gLTFcbiAgfSBlbHNlIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGF0dGVybi5zcGxpdCgnLCcpLmluZGV4T2YobmFtZSkgPiAtMVxuICB9IGVsc2UgaWYgKGlzUmVnRXhwKHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4udGVzdChuYW1lKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlIChrZWVwQWxpdmVJbnN0YW5jZSwgZmlsdGVyKSB7XG4gIHZhciBjYWNoZSA9IGtlZXBBbGl2ZUluc3RhbmNlLmNhY2hlO1xuICB2YXIga2V5cyA9IGtlZXBBbGl2ZUluc3RhbmNlLmtleXM7XG4gIHZhciBfdm5vZGUgPSBrZWVwQWxpdmVJbnN0YW5jZS5fdm5vZGU7XG4gIGZvciAodmFyIGtleSBpbiBjYWNoZSkge1xuICAgIHZhciBjYWNoZWROb2RlID0gY2FjaGVba2V5XTtcbiAgICBpZiAoY2FjaGVkTm9kZSkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNhY2hlZE5vZGUuY29tcG9uZW50T3B0aW9ucyk7XG4gICAgICBpZiAobmFtZSAmJiAhZmlsdGVyKG5hbWUpKSB7XG4gICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZSwga2V5LCBrZXlzLCBfdm5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlRW50cnkgKFxuICBjYWNoZSxcbiAga2V5LFxuICBrZXlzLFxuICBjdXJyZW50XG4pIHtcbiAgdmFyIGNhY2hlZCQkMSA9IGNhY2hlW2tleV07XG4gIGlmIChjYWNoZWQkJDEgJiYgKCFjdXJyZW50IHx8IGNhY2hlZCQkMS50YWcgIT09IGN1cnJlbnQudGFnKSkge1xuICAgIGNhY2hlZCQkMS5jb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICB9XG4gIGNhY2hlW2tleV0gPSBudWxsO1xuICByZW1vdmUoa2V5cywga2V5KTtcbn1cblxudmFyIHBhdHRlcm5UeXBlcyA9IFtTdHJpbmcsIFJlZ0V4cCwgQXJyYXldO1xuXG52YXIgS2VlcEFsaXZlID0ge1xuICBuYW1lOiAna2VlcC1hbGl2ZScsXG4gIGFic3RyYWN0OiB0cnVlLFxuXG4gIHByb3BzOiB7XG4gICAgaW5jbHVkZTogcGF0dGVyblR5cGVzLFxuICAgIGV4Y2x1ZGU6IHBhdHRlcm5UeXBlcyxcbiAgICBtYXg6IFtTdHJpbmcsIE51bWJlcl1cbiAgfSxcblxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkICgpIHtcbiAgICB0aGlzLmNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmtleXMgPSBbXTtcbiAgfSxcblxuICBkZXN0cm95ZWQ6IGZ1bmN0aW9uIGRlc3Ryb3llZCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcyQxLmNhY2hlKSB7XG4gICAgICBwcnVuZUNhY2hlRW50cnkodGhpcyQxLmNhY2hlLCBrZXksIHRoaXMkMS5rZXlzKTtcbiAgICB9XG4gIH0sXG5cbiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB0aGlzLiR3YXRjaCgnaW5jbHVkZScsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHBydW5lQ2FjaGUodGhpcyQxLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcbiAgICB9KTtcbiAgICB0aGlzLiR3YXRjaCgnZXhjbHVkZScsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHBydW5lQ2FjaGUodGhpcyQxLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gIW1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKCkge1xuICAgIHZhciBzbG90ID0gdGhpcy4kc2xvdHMuZGVmYXVsdDtcbiAgICB2YXIgdm5vZGUgPSBnZXRGaXJzdENvbXBvbmVudENoaWxkKHNsb3QpO1xuICAgIHZhciBjb21wb25lbnRPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICBpZiAoY29tcG9uZW50T3B0aW9ucykge1xuICAgICAgLy8gY2hlY2sgcGF0dGVyblxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgICB2YXIgaW5jbHVkZSA9IHJlZi5pbmNsdWRlO1xuICAgICAgdmFyIGV4Y2x1ZGUgPSByZWYuZXhjbHVkZTtcbiAgICAgIGlmIChcbiAgICAgICAgLy8gbm90IGluY2x1ZGVkXG4gICAgICAgIChpbmNsdWRlICYmICghbmFtZSB8fCAhbWF0Y2hlcyhpbmNsdWRlLCBuYW1lKSkpIHx8XG4gICAgICAgIC8vIGV4Y2x1ZGVkXG4gICAgICAgIChleGNsdWRlICYmIG5hbWUgJiYgbWF0Y2hlcyhleGNsdWRlLCBuYW1lKSlcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gdm5vZGVcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZiQxID0gdGhpcztcbiAgICAgIHZhciBjYWNoZSA9IHJlZiQxLmNhY2hlO1xuICAgICAgdmFyIGtleXMgPSByZWYkMS5rZXlzO1xuICAgICAgdmFyIGtleSA9IHZub2RlLmtleSA9PSBudWxsXG4gICAgICAgIC8vIHNhbWUgY29uc3RydWN0b3IgbWF5IGdldCByZWdpc3RlcmVkIGFzIGRpZmZlcmVudCBsb2NhbCBjb21wb25lbnRzXG4gICAgICAgIC8vIHNvIGNpZCBhbG9uZSBpcyBub3QgZW5vdWdoICgjMzI2OSlcbiAgICAgICAgPyBjb21wb25lbnRPcHRpb25zLkN0b3IuY2lkICsgKGNvbXBvbmVudE9wdGlvbnMudGFnID8gKFwiOjpcIiArIChjb21wb25lbnRPcHRpb25zLnRhZykpIDogJycpXG4gICAgICAgIDogdm5vZGUua2V5O1xuICAgICAgaWYgKGNhY2hlW2tleV0pIHtcbiAgICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjYWNoZVtrZXldLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgICAvLyBtYWtlIGN1cnJlbnQga2V5IGZyZXNoZXN0XG4gICAgICAgIHJlbW92ZShrZXlzLCBrZXkpO1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhY2hlW2tleV0gPSB2bm9kZTtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIC8vIHBydW5lIG9sZGVzdCBlbnRyeVxuICAgICAgICBpZiAodGhpcy5tYXggJiYga2V5cy5sZW5ndGggPiBwYXJzZUludCh0aGlzLm1heCkpIHtcbiAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGUsIGtleXNbMF0sIGtleXMsIHRoaXMuX3Zub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB2bm9kZSB8fCAoc2xvdCAmJiBzbG90WzBdKVxuICB9XG59XG5cbnZhciBidWlsdEluQ29tcG9uZW50cyA9IHtcbiAgS2VlcEFsaXZlOiBLZWVwQWxpdmVcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRHbG9iYWxBUEkgKFZ1ZSkge1xuICAvLyBjb25maWdcbiAgdmFyIGNvbmZpZ0RlZiA9IHt9O1xuICBjb25maWdEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlnOyB9O1xuICB7XG4gICAgY29uZmlnRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdEbyBub3QgcmVwbGFjZSB0aGUgVnVlLmNvbmZpZyBvYmplY3QsIHNldCBpbmRpdmlkdWFsIGZpZWxkcyBpbnN0ZWFkLidcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLCAnY29uZmlnJywgY29uZmlnRGVmKTtcblxuICAvLyBleHBvc2VkIHV0aWwgbWV0aG9kcy5cbiAgLy8gTk9URTogdGhlc2UgYXJlIG5vdCBjb25zaWRlcmVkIHBhcnQgb2YgdGhlIHB1YmxpYyBBUEkgLSBhdm9pZCByZWx5aW5nIG9uXG4gIC8vIHRoZW0gdW5sZXNzIHlvdSBhcmUgYXdhcmUgb2YgdGhlIHJpc2suXG4gIFZ1ZS51dGlsID0ge1xuICAgIHdhcm46IHdhcm4sXG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgbWVyZ2VPcHRpb25zOiBtZXJnZU9wdGlvbnMsXG4gICAgZGVmaW5lUmVhY3RpdmU6IGRlZmluZVJlYWN0aXZlXG4gIH07XG5cbiAgVnVlLnNldCA9IHNldDtcbiAgVnVlLmRlbGV0ZSA9IGRlbDtcbiAgVnVlLm5leHRUaWNrID0gbmV4dFRpY2s7XG5cbiAgVnVlLm9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgVnVlLm9wdGlvbnNbdHlwZSArICdzJ10gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9KTtcblxuICAvLyB0aGlzIGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIFwiYmFzZVwiIGNvbnN0cnVjdG9yIHRvIGV4dGVuZCBhbGwgcGxhaW4tb2JqZWN0XG4gIC8vIGNvbXBvbmVudHMgd2l0aCBpbiBXZWV4J3MgbXVsdGktaW5zdGFuY2Ugc2NlbmFyaW9zLlxuICBWdWUub3B0aW9ucy5fYmFzZSA9IFZ1ZTtcblxuICBleHRlbmQoVnVlLm9wdGlvbnMuY29tcG9uZW50cywgYnVpbHRJbkNvbXBvbmVudHMpO1xuXG4gIGluaXRVc2UoVnVlKTtcbiAgaW5pdE1peGluJDEoVnVlKTtcbiAgaW5pdEV4dGVuZChWdWUpO1xuICBpbml0QXNzZXRSZWdpc3RlcnMoVnVlKTtcbn1cblxuaW5pdEdsb2JhbEFQSShWdWUpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRpc1NlcnZlcicsIHtcbiAgZ2V0OiBpc1NlcnZlclJlbmRlcmluZ1xufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHNzckNvbnRleHQnLCB7XG4gIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiB0aGlzLiR2bm9kZSAmJiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0XG4gIH1cbn0pO1xuXG4vLyBleHBvc2UgRnVuY3Rpb25hbFJlbmRlckNvbnRleHQgZm9yIHNzciBydW50aW1lIGhlbHBlciBpbnN0YWxsYXRpb25cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCcsIHtcbiAgdmFsdWU6IEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0XG59KTtcblxuVnVlLnZlcnNpb24gPSAnMi41LjE2JztcblxuLyogICovXG5cbi8vIHRoZXNlIGFyZSByZXNlcnZlZCBmb3Igd2ViIGJlY2F1c2UgdGhleSBhcmUgZGlyZWN0bHkgY29tcGlsZWQgYXdheVxuLy8gZHVyaW5nIHRlbXBsYXRlIGNvbXBpbGF0aW9uXG52YXIgaXNSZXNlcnZlZEF0dHIgPSBtYWtlTWFwKCdzdHlsZSxjbGFzcycpO1xuXG4vLyBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGJlIHVzaW5nIHByb3BzIGZvciBiaW5kaW5nXG52YXIgYWNjZXB0VmFsdWUgPSBtYWtlTWFwKCdpbnB1dCx0ZXh0YXJlYSxvcHRpb24sc2VsZWN0LHByb2dyZXNzJyk7XG52YXIgbXVzdFVzZVByb3AgPSBmdW5jdGlvbiAodGFnLCB0eXBlLCBhdHRyKSB7XG4gIHJldHVybiAoXG4gICAgKGF0dHIgPT09ICd2YWx1ZScgJiYgYWNjZXB0VmFsdWUodGFnKSkgJiYgdHlwZSAhPT0gJ2J1dHRvbicgfHxcbiAgICAoYXR0ciA9PT0gJ3NlbGVjdGVkJyAmJiB0YWcgPT09ICdvcHRpb24nKSB8fFxuICAgIChhdHRyID09PSAnY2hlY2tlZCcgJiYgdGFnID09PSAnaW5wdXQnKSB8fFxuICAgIChhdHRyID09PSAnbXV0ZWQnICYmIHRhZyA9PT0gJ3ZpZGVvJylcbiAgKVxufTtcblxudmFyIGlzRW51bWVyYXRlZEF0dHIgPSBtYWtlTWFwKCdjb250ZW50ZWRpdGFibGUsZHJhZ2dhYmxlLHNwZWxsY2hlY2snKTtcblxudmFyIGlzQm9vbGVhbkF0dHIgPSBtYWtlTWFwKFxuICAnYWxsb3dmdWxsc2NyZWVuLGFzeW5jLGF1dG9mb2N1cyxhdXRvcGxheSxjaGVja2VkLGNvbXBhY3QsY29udHJvbHMsZGVjbGFyZSwnICtcbiAgJ2RlZmF1bHQsZGVmYXVsdGNoZWNrZWQsZGVmYXVsdG11dGVkLGRlZmF1bHRzZWxlY3RlZCxkZWZlcixkaXNhYmxlZCwnICtcbiAgJ2VuYWJsZWQsZm9ybW5vdmFsaWRhdGUsaGlkZGVuLGluZGV0ZXJtaW5hdGUsaW5lcnQsaXNtYXAsaXRlbXNjb3BlLGxvb3AsbXVsdGlwbGUsJyArXG4gICdtdXRlZCxub2hyZWYsbm9yZXNpemUsbm9zaGFkZSxub3ZhbGlkYXRlLG5vd3JhcCxvcGVuLHBhdXNlb25leGl0LHJlYWRvbmx5LCcgK1xuICAncmVxdWlyZWQscmV2ZXJzZWQsc2NvcGVkLHNlYW1sZXNzLHNlbGVjdGVkLHNvcnRhYmxlLHRyYW5zbGF0ZSwnICtcbiAgJ3RydWVzcGVlZCx0eXBlbXVzdG1hdGNoLHZpc2libGUnXG4pO1xuXG52YXIgeGxpbmtOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcblxudmFyIGlzWGxpbmsgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gbmFtZS5jaGFyQXQoNSkgPT09ICc6JyAmJiBuYW1lLnNsaWNlKDAsIDUpID09PSAneGxpbmsnXG59O1xuXG52YXIgZ2V0WGxpbmtQcm9wID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIGlzWGxpbmsobmFtZSkgPyBuYW1lLnNsaWNlKDYsIG5hbWUubGVuZ3RoKSA6ICcnXG59O1xuXG52YXIgaXNGYWxzeUF0dHJWYWx1ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsIHx8IHZhbCA9PT0gZmFsc2Vcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZW5DbGFzc0ZvclZub2RlICh2bm9kZSkge1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKGlzRGVmKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIGlmIChjaGlsZE5vZGUgJiYgY2hpbGROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShjaGlsZE5vZGUuZGF0YSwgZGF0YSk7XG4gICAgfVxuICB9XG4gIHdoaWxlIChpc0RlZihwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUgJiYgcGFyZW50Tm9kZS5kYXRhKSB7XG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoZGF0YSwgcGFyZW50Tm9kZS5kYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlbmRlckNsYXNzKGRhdGEuc3RhdGljQ2xhc3MsIGRhdGEuY2xhc3MpXG59XG5cbmZ1bmN0aW9uIG1lcmdlQ2xhc3NEYXRhIChjaGlsZCwgcGFyZW50KSB7XG4gIHJldHVybiB7XG4gICAgc3RhdGljQ2xhc3M6IGNvbmNhdChjaGlsZC5zdGF0aWNDbGFzcywgcGFyZW50LnN0YXRpY0NsYXNzKSxcbiAgICBjbGFzczogaXNEZWYoY2hpbGQuY2xhc3MpXG4gICAgICA/IFtjaGlsZC5jbGFzcywgcGFyZW50LmNsYXNzXVxuICAgICAgOiBwYXJlbnQuY2xhc3NcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJDbGFzcyAoXG4gIHN0YXRpY0NsYXNzLFxuICBkeW5hbWljQ2xhc3Ncbikge1xuICBpZiAoaXNEZWYoc3RhdGljQ2xhc3MpIHx8IGlzRGVmKGR5bmFtaWNDbGFzcykpIHtcbiAgICByZXR1cm4gY29uY2F0KHN0YXRpY0NsYXNzLCBzdHJpbmdpZnlDbGFzcyhkeW5hbWljQ2xhc3MpKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBjb25jYXQgKGEsIGIpIHtcbiAgcmV0dXJuIGEgPyBiID8gKGEgKyAnICcgKyBiKSA6IGEgOiAoYiB8fCAnJylcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5Q2xhc3MgKHZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlBcnJheSh2YWx1ZSlcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeU9iamVjdCh2YWx1ZSlcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlBcnJheSAodmFsdWUpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICB2YXIgc3RyaW5naWZpZWQ7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGlzRGVmKHN0cmluZ2lmaWVkID0gc3RyaW5naWZ5Q2xhc3ModmFsdWVbaV0pKSAmJiBzdHJpbmdpZmllZCAhPT0gJycpIHtcbiAgICAgIGlmIChyZXMpIHsgcmVzICs9ICcgJzsgfVxuICAgICAgcmVzICs9IHN0cmluZ2lmaWVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeU9iamVjdCAodmFsdWUpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAodmFsdWVba2V5XSkge1xuICAgICAgaWYgKHJlcykgeyByZXMgKz0gJyAnOyB9XG4gICAgICByZXMgKz0ga2V5O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgbmFtZXNwYWNlTWFwID0ge1xuICBzdmc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG4gIG1hdGg6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJ1xufTtcblxudmFyIGlzSFRNTFRhZyA9IG1ha2VNYXAoXG4gICdodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSwnICtcbiAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGgxLGgyLGgzLGg0LGg1LGg2LGhncm91cCxuYXYsc2VjdGlvbiwnICtcbiAgJ2RpdixkZCxkbCxkdCxmaWdjYXB0aW9uLGZpZ3VyZSxwaWN0dXJlLGhyLGltZyxsaSxtYWluLG9sLHAscHJlLHVsLCcgK1xuICAnYSxiLGFiYnIsYmRpLGJkbyxicixjaXRlLGNvZGUsZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ0YyxydWJ5LCcgK1xuICAncyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsdGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sJyArXG4gICdlbWJlZCxvYmplY3QscGFyYW0sc291cmNlLGNhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucywnICtcbiAgJ2NhcHRpb24sY29sLGNvbGdyb3VwLHRhYmxlLHRoZWFkLHRib2R5LHRkLHRoLHRyLCcgK1xuICAnYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLG9wdGlvbiwnICtcbiAgJ291dHB1dCxwcm9ncmVzcyxzZWxlY3QsdGV4dGFyZWEsJyArXG4gICdkZXRhaWxzLGRpYWxvZyxtZW51LG1lbnVpdGVtLHN1bW1hcnksJyArXG4gICdjb250ZW50LGVsZW1lbnQsc2hhZG93LHRlbXBsYXRlLGJsb2NrcXVvdGUsaWZyYW1lLHRmb290J1xuKTtcblxuLy8gdGhpcyBtYXAgaXMgaW50ZW50aW9uYWxseSBzZWxlY3RpdmUsIG9ubHkgY292ZXJpbmcgU1ZHIGVsZW1lbnRzIHRoYXQgbWF5XG4vLyBjb250YWluIGNoaWxkIGVsZW1lbnRzLlxudmFyIGlzU1ZHID0gbWFrZU1hcChcbiAgJ3N2ZyxhbmltYXRlLGNpcmNsZSxjbGlwcGF0aCxjdXJzb3IsZGVmcyxkZXNjLGVsbGlwc2UsZmlsdGVyLGZvbnQtZmFjZSwnICtcbiAgJ2ZvcmVpZ25PYmplY3QsZyxnbHlwaCxpbWFnZSxsaW5lLG1hcmtlcixtYXNrLG1pc3NpbmctZ2x5cGgscGF0aCxwYXR0ZXJuLCcgK1xuICAncG9seWdvbixwb2x5bGluZSxyZWN0LHN3aXRjaCxzeW1ib2wsdGV4dCx0ZXh0cGF0aCx0c3Bhbix1c2UsdmlldycsXG4gIHRydWVcbik7XG5cbnZhciBpc1ByZVRhZyA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHRhZyA9PT0gJ3ByZSc7IH07XG5cbnZhciBpc1Jlc2VydmVkVGFnID0gZnVuY3Rpb24gKHRhZykge1xuICByZXR1cm4gaXNIVE1MVGFnKHRhZykgfHwgaXNTVkcodGFnKVxufTtcblxuZnVuY3Rpb24gZ2V0VGFnTmFtZXNwYWNlICh0YWcpIHtcbiAgaWYgKGlzU1ZHKHRhZykpIHtcbiAgICByZXR1cm4gJ3N2ZydcbiAgfVxuICAvLyBiYXNpYyBzdXBwb3J0IGZvciBNYXRoTUxcbiAgLy8gbm90ZSBpdCBkb2Vzbid0IHN1cHBvcnQgb3RoZXIgTWF0aE1MIGVsZW1lbnRzIGJlaW5nIGNvbXBvbmVudCByb290c1xuICBpZiAodGFnID09PSAnbWF0aCcpIHtcbiAgICByZXR1cm4gJ21hdGgnXG4gIH1cbn1cblxudmFyIHVua25vd25FbGVtZW50Q2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZnVuY3Rpb24gaXNVbmtub3duRWxlbWVudCAodGFnKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWluQnJvd3Nlcikge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKGlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHRhZyA9IHRhZy50b0xvd2VyQ2FzZSgpO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHVua25vd25FbGVtZW50Q2FjaGVbdGFnXVxuICB9XG4gIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgaWYgKHRhZy5pbmRleE9mKCctJykgPiAtMSkge1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI4MjEwMzY0LzEwNzAyNDRcbiAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IChcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTFVua25vd25FbGVtZW50IHx8XG4gICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxFbGVtZW50XG4gICAgKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IC9IVE1MVW5rbm93bkVsZW1lbnQvLnRlc3QoZWwudG9TdHJpbmcoKSkpXG4gIH1cbn1cblxudmFyIGlzVGV4dElucHV0VHlwZSA9IG1ha2VNYXAoJ3RleHQsbnVtYmVyLHBhc3N3b3JkLHNlYXJjaCxlbWFpbCx0ZWwsdXJsJyk7XG5cbi8qICAqL1xuXG4vKipcbiAqIFF1ZXJ5IGFuIGVsZW1lbnQgc2VsZWN0b3IgaWYgaXQncyBub3QgYW4gZWxlbWVudCBhbHJlYWR5LlxuICovXG5mdW5jdGlvbiBxdWVyeSAoZWwpIHtcbiAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgc2VsZWN0ZWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKTtcbiAgICBpZiAoIXNlbGVjdGVkKSB7XG4gICAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAnQ2Fubm90IGZpbmQgZWxlbWVudDogJyArIGVsXG4gICAgICApO1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgfVxuICAgIHJldHVybiBzZWxlY3RlZFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBlbFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50JDEgKHRhZ05hbWUsIHZub2RlKSB7XG4gIHZhciBlbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICBpZiAodGFnTmFtZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICByZXR1cm4gZWxtXG4gIH1cbiAgLy8gZmFsc2Ugb3IgbnVsbCB3aWxsIHJlbW92ZSB0aGUgYXR0cmlidXRlIGJ1dCB1bmRlZmluZWQgd2lsbCBub3RcbiAgaWYgKHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS5hdHRycyAmJiB2bm9kZS5kYXRhLmF0dHJzLm11bHRpcGxlICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbG0uc2V0QXR0cmlidXRlKCdtdWx0aXBsZScsICdtdWx0aXBsZScpO1xuICB9XG4gIHJldHVybiBlbG1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudE5TIChuYW1lc3BhY2UsIHRhZ05hbWUpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VNYXBbbmFtZXNwYWNlXSwgdGFnTmFtZSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUgKHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnQgKHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQodGV4dClcbn1cblxuZnVuY3Rpb24gaW5zZXJ0QmVmb3JlIChwYXJlbnROb2RlLCBuZXdOb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgbm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIGFwcGVuZENoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gcGFyZW50Tm9kZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS5wYXJlbnROb2RlXG59XG5cbmZ1bmN0aW9uIG5leHRTaWJsaW5nIChub2RlKSB7XG4gIHJldHVybiBub2RlLm5leHRTaWJsaW5nXG59XG5cbmZ1bmN0aW9uIHRhZ05hbWUgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudGFnTmFtZVxufVxuXG5mdW5jdGlvbiBzZXRUZXh0Q29udGVudCAobm9kZSwgdGV4dCkge1xuICBub2RlLnRleHRDb250ZW50ID0gdGV4dDtcbn1cblxuZnVuY3Rpb24gc2V0U3R5bGVTY29wZSAobm9kZSwgc2NvcGVJZCkge1xuICBub2RlLnNldEF0dHJpYnV0ZShzY29wZUlkLCAnJyk7XG59XG5cblxudmFyIG5vZGVPcHMgPSBPYmplY3QuZnJlZXplKHtcblx0Y3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCQxLFxuXHRjcmVhdGVFbGVtZW50TlM6IGNyZWF0ZUVsZW1lbnROUyxcblx0Y3JlYXRlVGV4dE5vZGU6IGNyZWF0ZVRleHROb2RlLFxuXHRjcmVhdGVDb21tZW50OiBjcmVhdGVDb21tZW50LFxuXHRpbnNlcnRCZWZvcmU6IGluc2VydEJlZm9yZSxcblx0cmVtb3ZlQ2hpbGQ6IHJlbW92ZUNoaWxkLFxuXHRhcHBlbmRDaGlsZDogYXBwZW5kQ2hpbGQsXG5cdHBhcmVudE5vZGU6IHBhcmVudE5vZGUsXG5cdG5leHRTaWJsaW5nOiBuZXh0U2libGluZyxcblx0dGFnTmFtZTogdGFnTmFtZSxcblx0c2V0VGV4dENvbnRlbnQ6IHNldFRleHRDb250ZW50LFxuXHRzZXRTdHlsZVNjb3BlOiBzZXRTdHlsZVNjb3BlXG59KTtcblxuLyogICovXG5cbnZhciByZWYgPSB7XG4gIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlIChfLCB2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgfSxcbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIGlmIChvbGRWbm9kZS5kYXRhLnJlZiAhPT0gdm5vZGUuZGF0YS5yZWYpIHtcbiAgICAgIHJlZ2lzdGVyUmVmKG9sZFZub2RlLCB0cnVlKTtcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICB9XG4gIH0sXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgcmVnaXN0ZXJSZWYodm5vZGUsIHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyUmVmICh2bm9kZSwgaXNSZW1vdmFsKSB7XG4gIHZhciBrZXkgPSB2bm9kZS5kYXRhLnJlZjtcbiAgaWYgKCFpc0RlZihrZXkpKSB7IHJldHVybiB9XG5cbiAgdmFyIHZtID0gdm5vZGUuY29udGV4dDtcbiAgdmFyIHJlZiA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlIHx8IHZub2RlLmVsbTtcbiAgdmFyIHJlZnMgPSB2bS4kcmVmcztcbiAgaWYgKGlzUmVtb3ZhbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcbiAgICAgIHJlbW92ZShyZWZzW2tleV0sIHJlZik7XG4gICAgfSBlbHNlIGlmIChyZWZzW2tleV0gPT09IHJlZikge1xuICAgICAgcmVmc1trZXldID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodm5vZGUuZGF0YS5yZWZJbkZvcikge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcbiAgICAgICAgcmVmc1trZXldID0gW3JlZl07XG4gICAgICB9IGVsc2UgaWYgKHJlZnNba2V5XS5pbmRleE9mKHJlZikgPCAwKSB7XG4gICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgICByZWZzW2tleV0ucHVzaChyZWYpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWZzW2tleV0gPSByZWY7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVmlydHVhbCBET00gcGF0Y2hpbmcgYWxnb3JpdGhtIGJhc2VkIG9uIFNuYWJiZG9tIGJ5XG4gKiBTaW1vbiBGcmlpcyBWaW5kdW0gKEBwYWxkZXBpbmQpXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9wYWxkZXBpbmQvc25hYmJkb20vYmxvYi9tYXN0ZXIvTElDRU5TRVxuICpcbiAqIG1vZGlmaWVkIGJ5IEV2YW4gWW91IChAeXl4OTkwODAzKVxuICpcbiAqIE5vdCB0eXBlLWNoZWNraW5nIHRoaXMgYmVjYXVzZSB0aGlzIGZpbGUgaXMgcGVyZi1jcml0aWNhbCBhbmQgdGhlIGNvc3RcbiAqIG9mIG1ha2luZyBmbG93IHVuZGVyc3RhbmQgaXQgaXMgbm90IHdvcnRoIGl0LlxuICovXG5cbnZhciBlbXB0eU5vZGUgPSBuZXcgVk5vZGUoJycsIHt9LCBbXSk7XG5cbnZhciBob29rcyA9IFsnY3JlYXRlJywgJ2FjdGl2YXRlJywgJ3VwZGF0ZScsICdyZW1vdmUnLCAnZGVzdHJveSddO1xuXG5mdW5jdGlvbiBzYW1lVm5vZGUgKGEsIGIpIHtcbiAgcmV0dXJuIChcbiAgICBhLmtleSA9PT0gYi5rZXkgJiYgKFxuICAgICAgKFxuICAgICAgICBhLnRhZyA9PT0gYi50YWcgJiZcbiAgICAgICAgYS5pc0NvbW1lbnQgPT09IGIuaXNDb21tZW50ICYmXG4gICAgICAgIGlzRGVmKGEuZGF0YSkgPT09IGlzRGVmKGIuZGF0YSkgJiZcbiAgICAgICAgc2FtZUlucHV0VHlwZShhLCBiKVxuICAgICAgKSB8fCAoXG4gICAgICAgIGlzVHJ1ZShhLmlzQXN5bmNQbGFjZWhvbGRlcikgJiZcbiAgICAgICAgYS5hc3luY0ZhY3RvcnkgPT09IGIuYXN5bmNGYWN0b3J5ICYmXG4gICAgICAgIGlzVW5kZWYoYi5hc3luY0ZhY3RvcnkuZXJyb3IpXG4gICAgICApXG4gICAgKVxuICApXG59XG5cbmZ1bmN0aW9uIHNhbWVJbnB1dFR5cGUgKGEsIGIpIHtcbiAgaWYgKGEudGFnICE9PSAnaW5wdXQnKSB7IHJldHVybiB0cnVlIH1cbiAgdmFyIGk7XG4gIHZhciB0eXBlQSA9IGlzRGVmKGkgPSBhLmRhdGEpICYmIGlzRGVmKGkgPSBpLmF0dHJzKSAmJiBpLnR5cGU7XG4gIHZhciB0eXBlQiA9IGlzRGVmKGkgPSBiLmRhdGEpICYmIGlzRGVmKGkgPSBpLmF0dHJzKSAmJiBpLnR5cGU7XG4gIHJldHVybiB0eXBlQSA9PT0gdHlwZUIgfHwgaXNUZXh0SW5wdXRUeXBlKHR5cGVBKSAmJiBpc1RleHRJbnB1dFR5cGUodHlwZUIpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleVRvT2xkSWR4IChjaGlsZHJlbiwgYmVnaW5JZHgsIGVuZElkeCkge1xuICB2YXIgaSwga2V5O1xuICB2YXIgbWFwID0ge307XG4gIGZvciAoaSA9IGJlZ2luSWR4OyBpIDw9IGVuZElkeDsgKytpKSB7XG4gICAga2V5ID0gY2hpbGRyZW5baV0ua2V5O1xuICAgIGlmIChpc0RlZihrZXkpKSB7IG1hcFtrZXldID0gaTsgfVxuICB9XG4gIHJldHVybiBtYXBcbn1cblxuZnVuY3Rpb24gY3JlYXRlUGF0Y2hGdW5jdGlvbiAoYmFja2VuZCkge1xuICB2YXIgaSwgajtcbiAgdmFyIGNicyA9IHt9O1xuXG4gIHZhciBtb2R1bGVzID0gYmFja2VuZC5tb2R1bGVzO1xuICB2YXIgbm9kZU9wcyA9IGJhY2tlbmQubm9kZU9wcztcblxuICBmb3IgKGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyArK2kpIHtcbiAgICBjYnNbaG9va3NbaV1dID0gW107XG4gICAgZm9yIChqID0gMDsgaiA8IG1vZHVsZXMubGVuZ3RoOyArK2opIHtcbiAgICAgIGlmIChpc0RlZihtb2R1bGVzW2pdW2hvb2tzW2ldXSkpIHtcbiAgICAgICAgY2JzW2hvb2tzW2ldXS5wdXNoKG1vZHVsZXNbal1baG9va3NbaV1dKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbXB0eU5vZGVBdCAoZWxtKSB7XG4gICAgcmV0dXJuIG5ldyBWTm9kZShub2RlT3BzLnRhZ05hbWUoZWxtKS50b0xvd2VyQ2FzZSgpLCB7fSwgW10sIHVuZGVmaW5lZCwgZWxtKVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUm1DYiAoY2hpbGRFbG0sIGxpc3RlbmVycykge1xuICAgIGZ1bmN0aW9uIHJlbW92ZSAoKSB7XG4gICAgICBpZiAoLS1yZW1vdmUubGlzdGVuZXJzID09PSAwKSB7XG4gICAgICAgIHJlbW92ZU5vZGUoY2hpbGRFbG0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZW1vdmUubGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICAgIHJldHVybiByZW1vdmVcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZU5vZGUgKGVsKSB7XG4gICAgdmFyIHBhcmVudCA9IG5vZGVPcHMucGFyZW50Tm9kZShlbCk7XG4gICAgLy8gZWxlbWVudCBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gcmVtb3ZlZCBkdWUgdG8gdi1odG1sIC8gdi10ZXh0XG4gICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcbiAgICAgIG5vZGVPcHMucmVtb3ZlQ2hpbGQocGFyZW50LCBlbCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNVbmtub3duRWxlbWVudCQkMSAodm5vZGUsIGluVlByZSkge1xuICAgIHJldHVybiAoXG4gICAgICAhaW5WUHJlICYmXG4gICAgICAhdm5vZGUubnMgJiZcbiAgICAgICEoXG4gICAgICAgIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMubGVuZ3RoICYmXG4gICAgICAgIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMuc29tZShmdW5jdGlvbiAoaWdub3JlKSB7XG4gICAgICAgICAgcmV0dXJuIGlzUmVnRXhwKGlnbm9yZSlcbiAgICAgICAgICAgID8gaWdub3JlLnRlc3Qodm5vZGUudGFnKVxuICAgICAgICAgICAgOiBpZ25vcmUgPT09IHZub2RlLnRhZ1xuICAgICAgICB9KVxuICAgICAgKSAmJlxuICAgICAgY29uZmlnLmlzVW5rbm93bkVsZW1lbnQodm5vZGUudGFnKVxuICAgIClcbiAgfVxuXG4gIHZhciBjcmVhdGluZ0VsbUluVlByZSA9IDA7XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxtIChcbiAgICB2bm9kZSxcbiAgICBpbnNlcnRlZFZub2RlUXVldWUsXG4gICAgcGFyZW50RWxtLFxuICAgIHJlZkVsbSxcbiAgICBuZXN0ZWQsXG4gICAgb3duZXJBcnJheSxcbiAgICBpbmRleFxuICApIHtcbiAgICBpZiAoaXNEZWYodm5vZGUuZWxtKSAmJiBpc0RlZihvd25lckFycmF5KSkge1xuICAgICAgLy8gVGhpcyB2bm9kZSB3YXMgdXNlZCBpbiBhIHByZXZpb3VzIHJlbmRlciFcbiAgICAgIC8vIG5vdyBpdCdzIHVzZWQgYXMgYSBuZXcgbm9kZSwgb3ZlcndyaXRpbmcgaXRzIGVsbSB3b3VsZCBjYXVzZVxuICAgICAgLy8gcG90ZW50aWFsIHBhdGNoIGVycm9ycyBkb3duIHRoZSByb2FkIHdoZW4gaXQncyB1c2VkIGFzIGFuIGluc2VydGlvblxuICAgICAgLy8gcmVmZXJlbmNlIG5vZGUuIEluc3RlYWQsIHdlIGNsb25lIHRoZSBub2RlIG9uLWRlbWFuZCBiZWZvcmUgY3JlYXRpbmdcbiAgICAgIC8vIGFzc29jaWF0ZWQgRE9NIGVsZW1lbnQgZm9yIGl0LlxuICAgICAgdm5vZGUgPSBvd25lckFycmF5W2luZGV4XSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICAgIH1cblxuICAgIHZub2RlLmlzUm9vdEluc2VydCA9ICFuZXN0ZWQ7IC8vIGZvciB0cmFuc2l0aW9uIGVudGVyIGNoZWNrXG4gICAgaWYgKGNyZWF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICB2YXIgdGFnID0gdm5vZGUudGFnO1xuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgICAgY3JlYXRpbmdFbG1JblZQcmUrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNVbmtub3duRWxlbWVudCQkMSh2bm9kZSwgY3JlYXRpbmdFbG1JblZQcmUpKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgICdVbmtub3duIGN1c3RvbSBlbGVtZW50OiA8JyArIHRhZyArICc+IC0gZGlkIHlvdSAnICtcbiAgICAgICAgICAgICdyZWdpc3RlciB0aGUgY29tcG9uZW50IGNvcnJlY3RseT8gRm9yIHJlY3Vyc2l2ZSBjb21wb25lbnRzLCAnICtcbiAgICAgICAgICAgICdtYWtlIHN1cmUgdG8gcHJvdmlkZSB0aGUgXCJuYW1lXCIgb3B0aW9uLicsXG4gICAgICAgICAgICB2bm9kZS5jb250ZXh0XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2bm9kZS5lbG0gPSB2bm9kZS5uc1xuICAgICAgICA/IG5vZGVPcHMuY3JlYXRlRWxlbWVudE5TKHZub2RlLm5zLCB0YWcpXG4gICAgICAgIDogbm9kZU9wcy5jcmVhdGVFbGVtZW50KHRhZywgdm5vZGUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIHtcbiAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgIGNyZWF0aW5nRWxtSW5WUHJlLS07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1RydWUodm5vZGUuaXNDb21tZW50KSkge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVDb21tZW50KHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICB2YXIgaSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICB2YXIgaXNSZWFjdGl2YXRlZCA9IGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpLmtlZXBBbGl2ZTtcbiAgICAgIGlmIChpc0RlZihpID0gaS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkge1xuICAgICAgICBpKHZub2RlLCBmYWxzZSAvKiBoeWRyYXRpbmcgKi8sIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICAgIH1cbiAgICAgIC8vIGFmdGVyIGNhbGxpbmcgdGhlIGluaXQgaG9vaywgaWYgdGhlIHZub2RlIGlzIGEgY2hpbGQgY29tcG9uZW50XG4gICAgICAvLyBpdCBzaG91bGQndmUgY3JlYXRlZCBhIGNoaWxkIGluc3RhbmNlIGFuZCBtb3VudGVkIGl0LiB0aGUgY2hpbGRcbiAgICAgIC8vIGNvbXBvbmVudCBhbHNvIGhhcyBzZXQgdGhlIHBsYWNlaG9sZGVyIHZub2RlJ3MgZWxtLlxuICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIGNhbiBqdXN0IHJldHVybiB0aGUgZWxlbWVudCBhbmQgYmUgZG9uZS5cbiAgICAgIGlmIChpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaWYgKGlzVHJ1ZShpc1JlYWN0aXZhdGVkKSkge1xuICAgICAgICAgIHJlYWN0aXZhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdENvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChpc0RlZih2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpKSB7XG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaC5hcHBseShpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCk7XG4gICAgICB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQgPSBudWxsO1xuICAgIH1cbiAgICB2bm9kZS5lbG0gPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kZWw7XG4gICAgaWYgKGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICBzZXRTY29wZSh2bm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVtcHR5IGNvbXBvbmVudCByb290LlxuICAgICAgLy8gc2tpcCBhbGwgZWxlbWVudC1yZWxhdGVkIG1vZHVsZXMgZXhjZXB0IGZvciByZWYgKCMzNDU1KVxuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgICAgLy8gbWFrZSBzdXJlIHRvIGludm9rZSB0aGUgaW5zZXJ0IGhvb2tcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFjdGl2YXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIHZhciBpO1xuICAgIC8vIGhhY2sgZm9yICM0MzM5OiBhIHJlYWN0aXZhdGVkIGNvbXBvbmVudCB3aXRoIGlubmVyIHRyYW5zaXRpb25cbiAgICAvLyBkb2VzIG5vdCB0cmlnZ2VyIGJlY2F1c2UgdGhlIGlubmVyIG5vZGUncyBjcmVhdGVkIGhvb2tzIGFyZSBub3QgY2FsbGVkXG4gICAgLy8gYWdhaW4uIEl0J3Mgbm90IGlkZWFsIHRvIGludm9sdmUgbW9kdWxlLXNwZWNpZmljIGxvZ2ljIGluIGhlcmUgYnV0XG4gICAgLy8gdGhlcmUgZG9lc24ndCBzZWVtIHRvIGJlIGEgYmV0dGVyIHdheSB0byBkbyBpdC5cbiAgICB2YXIgaW5uZXJOb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgaW5uZXJOb2RlID0gaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgIGlmIChpc0RlZihpID0gaW5uZXJOb2RlLmRhdGEpICYmIGlzRGVmKGkgPSBpLnRyYW5zaXRpb24pKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuYWN0aXZhdGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBjYnMuYWN0aXZhdGVbaV0oZW1wdHlOb2RlLCBpbm5lck5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKGlubmVyTm9kZSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVubGlrZSBhIG5ld2x5IGNyZWF0ZWQgY29tcG9uZW50LFxuICAgIC8vIGEgcmVhY3RpdmF0ZWQga2VlcC1hbGl2ZSBjb21wb25lbnQgZG9lc24ndCBpbnNlcnQgaXRzZWxmXG4gICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0IChwYXJlbnQsIGVsbSwgcmVmJCQxKSB7XG4gICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcbiAgICAgIGlmIChpc0RlZihyZWYkJDEpKSB7XG4gICAgICAgIGlmIChyZWYkJDEucGFyZW50Tm9kZSA9PT0gcGFyZW50KSB7XG4gICAgICAgICAgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50LCBlbG0sIHJlZiQkMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQocGFyZW50LCBlbG0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkcmVuICh2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAge1xuICAgICAgICBjaGVja0R1cGxpY2F0ZUtleXMoY2hpbGRyZW4pO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICBjcmVhdGVFbG0oY2hpbGRyZW5baV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZWxtLCBudWxsLCB0cnVlLCBjaGlsZHJlbiwgaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZSh2bm9kZS50ZXh0KSkge1xuICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZCh2bm9kZS5lbG0sIG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKHZub2RlLnRleHQpKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNQYXRjaGFibGUgKHZub2RlKSB7XG4gICAgd2hpbGUgKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICB2bm9kZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzRGVmKHZub2RlLnRhZylcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUNyZWF0ZUhvb2tzICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSQxKSB7XG4gICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIGkgPSB2bm9kZS5kYXRhLmhvb2s7IC8vIFJldXNlIHZhcmlhYmxlXG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICBpZiAoaXNEZWYoaS5jcmVhdGUpKSB7IGkuY3JlYXRlKGVtcHR5Tm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaXNEZWYoaS5pbnNlcnQpKSB7IGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTsgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHNldCBzY29wZSBpZCBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBDU1MuXG4gIC8vIHRoaXMgaXMgaW1wbGVtZW50ZWQgYXMgYSBzcGVjaWFsIGNhc2UgdG8gYXZvaWQgdGhlIG92ZXJoZWFkXG4gIC8vIG9mIGdvaW5nIHRocm91Z2ggdGhlIG5vcm1hbCBhdHRyaWJ1dGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAgZnVuY3Rpb24gc2V0U2NvcGUgKHZub2RlKSB7XG4gICAgdmFyIGk7XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5mblNjb3BlSWQpKSB7XG4gICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGU7XG4gICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgaWYgKGlzRGVmKGkgPSBhbmNlc3Rvci5jb250ZXh0KSAmJiBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZCkpIHtcbiAgICAgICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcbiAgICAgICAgfVxuICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZm9yIHNsb3QgY29udGVudCB0aGV5IHNob3VsZCBhbHNvIGdldCB0aGUgc2NvcGVJZCBmcm9tIHRoZSBob3N0IGluc3RhbmNlLlxuICAgIGlmIChpc0RlZihpID0gYWN0aXZlSW5zdGFuY2UpICYmXG4gICAgICBpICE9PSB2bm9kZS5jb250ZXh0ICYmXG4gICAgICBpICE9PSB2bm9kZS5mbkNvbnRleHQgJiZcbiAgICAgIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKVxuICAgICkge1xuICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkVm5vZGVzIChwYXJlbnRFbG0sIHJlZkVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICBjcmVhdGVFbG0odm5vZGVzW3N0YXJ0SWR4XSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSwgZmFsc2UsIHZub2Rlcywgc3RhcnRJZHgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZURlc3Ryb3lIb29rICh2bm9kZSkge1xuICAgIHZhciBpLCBqO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5kZXN0cm95KSkgeyBpKHZub2RlKTsgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSB7IGNicy5kZXN0cm95W2ldKHZub2RlKTsgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNoaWxkcmVuKSkge1xuICAgICAgZm9yIChqID0gMDsgaiA8IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGludm9rZURlc3Ryb3lIb29rKHZub2RlLmNoaWxkcmVuW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVWbm9kZXMgKHBhcmVudEVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4KSB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgdmFyIGNoID0gdm5vZGVzW3N0YXJ0SWR4XTtcbiAgICAgIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKGlzRGVmKGNoLnRhZykpIHtcbiAgICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGNoKTtcbiAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhjaCk7XG4gICAgICAgIH0gZWxzZSB7IC8vIFRleHQgbm9kZVxuICAgICAgICAgIHJlbW92ZU5vZGUoY2guZWxtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2sgKHZub2RlLCBybSkge1xuICAgIGlmIChpc0RlZihybSkgfHwgaXNEZWYodm5vZGUuZGF0YSkpIHtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxpc3RlbmVycyA9IGNicy5yZW1vdmUubGVuZ3RoICsgMTtcbiAgICAgIGlmIChpc0RlZihybSkpIHtcbiAgICAgICAgLy8gd2UgaGF2ZSBhIHJlY3Vyc2l2ZWx5IHBhc3NlZCBkb3duIHJtIGNhbGxiYWNrXG4gICAgICAgIC8vIGluY3JlYXNlIHRoZSBsaXN0ZW5lcnMgY291bnRcbiAgICAgICAgcm0ubGlzdGVuZXJzICs9IGxpc3RlbmVycztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRpcmVjdGx5IHJlbW92aW5nXG4gICAgICAgIHJtID0gY3JlYXRlUm1DYih2bm9kZS5lbG0sIGxpc3RlbmVycyk7XG4gICAgICB9XG4gICAgICAvLyByZWN1cnNpdmVseSBpbnZva2UgaG9va3Mgb24gY2hpbGQgY29tcG9uZW50IHJvb3Qgbm9kZVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaXNEZWYoaSA9IGkuX3Zub2RlKSAmJiBpc0RlZihpLmRhdGEpKSB7XG4gICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soaSwgcm0pO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5yZW1vdmUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY2JzLnJlbW92ZVtpXSh2bm9kZSwgcm0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5kYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnJlbW92ZSkpIHtcbiAgICAgICAgaSh2bm9kZSwgcm0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm0oKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlTm9kZSh2bm9kZS5lbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNoaWxkcmVuIChwYXJlbnRFbG0sIG9sZENoLCBuZXdDaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KSB7XG4gICAgdmFyIG9sZFN0YXJ0SWR4ID0gMDtcbiAgICB2YXIgbmV3U3RhcnRJZHggPSAwO1xuICAgIHZhciBvbGRFbmRJZHggPSBvbGRDaC5sZW5ndGggLSAxO1xuICAgIHZhciBvbGRTdGFydFZub2RlID0gb2xkQ2hbMF07XG4gICAgdmFyIG9sZEVuZFZub2RlID0gb2xkQ2hbb2xkRW5kSWR4XTtcbiAgICB2YXIgbmV3RW5kSWR4ID0gbmV3Q2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWzBdO1xuICAgIHZhciBuZXdFbmRWbm9kZSA9IG5ld0NoW25ld0VuZElkeF07XG4gICAgdmFyIG9sZEtleVRvSWR4LCBpZHhJbk9sZCwgdm5vZGVUb01vdmUsIHJlZkVsbTtcblxuICAgIC8vIHJlbW92ZU9ubHkgaXMgYSBzcGVjaWFsIGZsYWcgdXNlZCBvbmx5IGJ5IDx0cmFuc2l0aW9uLWdyb3VwPlxuICAgIC8vIHRvIGVuc3VyZSByZW1vdmVkIGVsZW1lbnRzIHN0YXkgaW4gY29ycmVjdCByZWxhdGl2ZSBwb3NpdGlvbnNcbiAgICAvLyBkdXJpbmcgbGVhdmluZyB0cmFuc2l0aW9uc1xuICAgIHZhciBjYW5Nb3ZlID0gIXJlbW92ZU9ubHk7XG5cbiAgICB7XG4gICAgICBjaGVja0R1cGxpY2F0ZUtleXMobmV3Q2gpO1xuICAgIH1cblxuICAgIHdoaWxlIChvbGRTdGFydElkeCA8PSBvbGRFbmRJZHggJiYgbmV3U3RhcnRJZHggPD0gbmV3RW5kSWR4KSB7XG4gICAgICBpZiAoaXNVbmRlZihvbGRTdGFydFZub2RlKSkge1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07IC8vIFZub2RlIGhhcyBiZWVuIG1vdmVkIGxlZnRcbiAgICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGRFbmRWbm9kZSkpIHtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIHJpZ2h0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbmRWbm9kZS5lbG0pKTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCBsZWZ0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRFbmRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1VuZGVmKG9sZEtleVRvSWR4KSkgeyBvbGRLZXlUb0lkeCA9IGNyZWF0ZUtleVRvT2xkSWR4KG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTsgfVxuICAgICAgICBpZHhJbk9sZCA9IGlzRGVmKG5ld1N0YXJ0Vm5vZGUua2V5KVxuICAgICAgICAgID8gb2xkS2V5VG9JZHhbbmV3U3RhcnRWbm9kZS5rZXldXG4gICAgICAgICAgOiBmaW5kSWR4SW5PbGQobmV3U3RhcnRWbm9kZSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgICAgICBpZiAoaXNVbmRlZihpZHhJbk9sZCkpIHsgLy8gTmV3IGVsZW1lbnRcbiAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBmYWxzZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2bm9kZVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcbiAgICAgICAgICBpZiAoc2FtZVZub2RlKHZub2RlVG9Nb3ZlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICAgICAgcGF0Y2hWbm9kZSh2bm9kZVRvTW92ZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIG9sZENoW2lkeEluT2xkXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCB2bm9kZVRvTW92ZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc2FtZSBrZXkgYnV0IGRpZmZlcmVudCBlbGVtZW50LiB0cmVhdCBhcyBuZXcgZWxlbWVudFxuICAgICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgZmFsc2UsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9sZFN0YXJ0SWR4ID4gb2xkRW5kSWR4KSB7XG4gICAgICByZWZFbG0gPSBpc1VuZGVmKG5ld0NoW25ld0VuZElkeCArIDFdKSA/IG51bGwgOiBuZXdDaFtuZXdFbmRJZHggKyAxXS5lbG07XG4gICAgICBhZGRWbm9kZXMocGFyZW50RWxtLCByZWZFbG0sIG5ld0NoLCBuZXdTdGFydElkeCwgbmV3RW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgIH0gZWxzZSBpZiAobmV3U3RhcnRJZHggPiBuZXdFbmRJZHgpIHtcbiAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0sIG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0R1cGxpY2F0ZUtleXMgKGNoaWxkcmVuKSB7XG4gICAgdmFyIHNlZW5LZXlzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZub2RlID0gY2hpbGRyZW5baV07XG4gICAgICB2YXIga2V5ID0gdm5vZGUua2V5O1xuICAgICAgaWYgKGlzRGVmKGtleSkpIHtcbiAgICAgICAgaWYgKHNlZW5LZXlzW2tleV0pIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgKFwiRHVwbGljYXRlIGtleXMgZGV0ZWN0ZWQ6ICdcIiArIGtleSArIFwiJy4gVGhpcyBtYXkgY2F1c2UgYW4gdXBkYXRlIGVycm9yLlwiKSxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlZW5LZXlzW2tleV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmluZElkeEluT2xkIChub2RlLCBvbGRDaCwgc3RhcnQsIGVuZCkge1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IG9sZENoW2ldO1xuICAgICAgaWYgKGlzRGVmKGMpICYmIHNhbWVWbm9kZShub2RlLCBjKSkgeyByZXR1cm4gaSB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGF0Y2hWbm9kZSAob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpIHtcbiAgICBpZiAob2xkVm5vZGUgPT09IHZub2RlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgZWxtID0gdm5vZGUuZWxtID0gb2xkVm5vZGUuZWxtO1xuXG4gICAgaWYgKGlzVHJ1ZShvbGRWbm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIpKSB7XG4gICAgICBpZiAoaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICBoeWRyYXRlKG9sZFZub2RlLmVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gcmV1c2UgZWxlbWVudCBmb3Igc3RhdGljIHRyZWVzLlxuICAgIC8vIG5vdGUgd2Ugb25seSBkbyB0aGlzIGlmIHRoZSB2bm9kZSBpcyBjbG9uZWQgLVxuICAgIC8vIGlmIHRoZSBuZXcgbm9kZSBpcyBub3QgY2xvbmVkIGl0IG1lYW5zIHRoZSByZW5kZXIgZnVuY3Rpb25zIGhhdmUgYmVlblxuICAgIC8vIHJlc2V0IGJ5IHRoZSBob3QtcmVsb2FkLWFwaSBhbmQgd2UgbmVlZCB0byBkbyBhIHByb3BlciByZS1yZW5kZXIuXG4gICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc1N0YXRpYykgJiZcbiAgICAgIGlzVHJ1ZShvbGRWbm9kZS5pc1N0YXRpYykgJiZcbiAgICAgIHZub2RlLmtleSA9PT0gb2xkVm5vZGUua2V5ICYmXG4gICAgICAoaXNUcnVlKHZub2RlLmlzQ2xvbmVkKSB8fCBpc1RydWUodm5vZGUuaXNPbmNlKSlcbiAgICApIHtcbiAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnByZXBhdGNoKSkge1xuICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgIH1cblxuICAgIHZhciBvbGRDaCA9IG9sZFZub2RlLmNoaWxkcmVuO1xuICAgIHZhciBjaCA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMudXBkYXRlLmxlbmd0aDsgKytpKSB7IGNicy51cGRhdGVbaV0ob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnVwZGF0ZSkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgfVxuICAgIGlmIChpc1VuZGVmKHZub2RlLnRleHQpKSB7XG4gICAgICBpZiAoaXNEZWYob2xkQ2gpICYmIGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAob2xkQ2ggIT09IGNoKSB7IHVwZGF0ZUNoaWxkcmVuKGVsbSwgb2xkQ2gsIGNoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpOyB9XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHsgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTsgfVxuICAgICAgICBhZGRWbm9kZXMoZWxtLCBudWxsLCBjaCwgMCwgY2gubGVuZ3RoIC0gMSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkQ2gpKSB7XG4gICAgICAgIHJlbW92ZVZub2RlcyhlbG0sIG9sZENoLCAwLCBvbGRDaC5sZW5ndGggLSAxKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHtcbiAgICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9sZFZub2RlLnRleHQgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCB2bm9kZS50ZXh0KTtcbiAgICB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucG9zdHBhdGNoKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VJbnNlcnRIb29rICh2bm9kZSwgcXVldWUsIGluaXRpYWwpIHtcbiAgICAvLyBkZWxheSBpbnNlcnQgaG9va3MgZm9yIGNvbXBvbmVudCByb290IG5vZGVzLCBpbnZva2UgdGhlbSBhZnRlciB0aGVcbiAgICAvLyBlbGVtZW50IGlzIHJlYWxseSBpbnNlcnRlZFxuICAgIGlmIChpc1RydWUoaW5pdGlhbCkgJiYgaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgdm5vZGUucGFyZW50LmRhdGEucGVuZGluZ0luc2VydCA9IHF1ZXVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHF1ZXVlW2ldLmRhdGEuaG9vay5pbnNlcnQocXVldWVbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBoeWRyYXRpb25CYWlsZWQgPSBmYWxzZTtcbiAgLy8gbGlzdCBvZiBtb2R1bGVzIHRoYXQgY2FuIHNraXAgY3JlYXRlIGhvb2sgZHVyaW5nIGh5ZHJhdGlvbiBiZWNhdXNlIHRoZXlcbiAgLy8gYXJlIGFscmVhZHkgcmVuZGVyZWQgb24gdGhlIGNsaWVudCBvciBoYXMgbm8gbmVlZCBmb3IgaW5pdGlhbGl6YXRpb25cbiAgLy8gTm90ZTogc3R5bGUgaXMgZXhjbHVkZWQgYmVjYXVzZSBpdCByZWxpZXMgb24gaW5pdGlhbCBjbG9uZSBmb3IgZnV0dXJlXG4gIC8vIGRlZXAgdXBkYXRlcyAoIzcwNjMpLlxuICB2YXIgaXNSZW5kZXJlZE1vZHVsZSA9IG1ha2VNYXAoJ2F0dHJzLGNsYXNzLHN0YXRpY0NsYXNzLHN0YXRpY1N0eWxlLGtleScpO1xuXG4gIC8vIE5vdGU6IHRoaXMgaXMgYSBicm93c2VyLW9ubHkgZnVuY3Rpb24gc28gd2UgY2FuIGFzc3VtZSBlbG1zIGFyZSBET00gbm9kZXMuXG4gIGZ1bmN0aW9uIGh5ZHJhdGUgKGVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaW5WUHJlID0gaW5WUHJlIHx8IChkYXRhICYmIGRhdGEucHJlKTtcbiAgICB2bm9kZS5lbG0gPSBlbG07XG5cbiAgICBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkgJiYgaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5KSkge1xuICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIC8vIGFzc2VydCBub2RlIG1hdGNoXG4gICAge1xuICAgICAgaWYgKCFhc3NlcnROb2RlTWF0Y2goZWxtLCB2bm9kZSwgaW5WUHJlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHsgaSh2bm9kZSwgdHJ1ZSAvKiBoeWRyYXRpbmcgKi8pOyB9XG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICAvLyBjaGlsZCBjb21wb25lbnQuIGl0IHNob3VsZCBoYXZlIGh5ZHJhdGVkIGl0cyBvd24gdHJlZS5cbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKHRhZykpIHtcbiAgICAgIGlmIChpc0RlZihjaGlsZHJlbikpIHtcbiAgICAgICAgLy8gZW1wdHkgZWxlbWVudCwgYWxsb3cgY2xpZW50IHRvIHBpY2sgdXAgYW5kIHBvcHVsYXRlIGNoaWxkcmVuXG4gICAgICAgIGlmICghZWxtLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB2LWh0bWwgYW5kIGRvbVByb3BzOiBpbm5lckhUTUxcbiAgICAgICAgICBpZiAoaXNEZWYoaSA9IGRhdGEpICYmIGlzRGVmKGkgPSBpLmRvbVByb3BzKSAmJiBpc0RlZihpID0gaS5pbm5lckhUTUwpKSB7XG4gICAgICAgICAgICBpZiAoaSAhPT0gZWxtLmlubmVySFRNTCkge1xuICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgIWh5ZHJhdGlvbkJhaWxlZFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBoeWRyYXRpb25CYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybignc2VydmVyIGlubmVySFRNTDogJywgaSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdjbGllbnQgaW5uZXJIVE1MOiAnLCBlbG0uaW5uZXJIVE1MKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaXRlcmF0ZSBhbmQgY29tcGFyZSBjaGlsZHJlbiBsaXN0c1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGVsbS5maXJzdENoaWxkO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgICAgICBpZiAoIWNoaWxkTm9kZSB8fCAhaHlkcmF0ZShjaGlsZE5vZGUsIGNoaWxkcmVuW2kkMV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGNoaWxkTm9kZSBpcyBub3QgbnVsbCwgaXQgbWVhbnMgdGhlIGFjdHVhbCBjaGlsZE5vZGVzIGxpc3QgaXNcbiAgICAgICAgICAgIC8vIGxvbmdlciB0aGFuIHRoZSB2aXJ0dWFsIGNoaWxkcmVuIGxpc3QuXG4gICAgICAgICAgICBpZiAoIWNoaWxkcmVuTWF0Y2ggfHwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAhaHlkcmF0aW9uQmFpbGVkXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGh5ZHJhdGlvbkJhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQYXJlbnQ6ICcsIGVsbSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdNaXNtYXRjaGluZyBjaGlsZE5vZGVzIHZzLiBWTm9kZXM6ICcsIGVsbS5jaGlsZE5vZGVzLCBjaGlsZHJlbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgdmFyIGZ1bGxJbnZva2UgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICBpZiAoIWlzUmVuZGVyZWRNb2R1bGUoa2V5KSkge1xuICAgICAgICAgICAgZnVsbEludm9rZSA9IHRydWU7XG4gICAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZnVsbEludm9rZSAmJiBkYXRhWydjbGFzcyddKSB7XG4gICAgICAgICAgLy8gZW5zdXJlIGNvbGxlY3RpbmcgZGVwcyBmb3IgZGVlcCBjbGFzcyBiaW5kaW5ncyBmb3IgZnV0dXJlIHVwZGF0ZXNcbiAgICAgICAgICB0cmF2ZXJzZShkYXRhWydjbGFzcyddKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZWxtLmRhdGEgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIGVsbS5kYXRhID0gdm5vZGUudGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2VydE5vZGVNYXRjaCAobm9kZSwgdm5vZGUsIGluVlByZSkge1xuICAgIGlmIChpc0RlZih2bm9kZS50YWcpKSB7XG4gICAgICByZXR1cm4gdm5vZGUudGFnLmluZGV4T2YoJ3Z1ZS1jb21wb25lbnQnKSA9PT0gMCB8fCAoXG4gICAgICAgICFpc1Vua25vd25FbGVtZW50JCQxKHZub2RlLCBpblZQcmUpICYmXG4gICAgICAgIHZub2RlLnRhZy50b0xvd2VyQ2FzZSgpID09PSAobm9kZS50YWdOYW1lICYmIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKVxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gKHZub2RlLmlzQ29tbWVudCA/IDggOiAzKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBwYXRjaCAob2xkVm5vZGUsIHZub2RlLCBoeWRyYXRpbmcsIHJlbW92ZU9ubHksIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgaWYgKGlzVW5kZWYodm5vZGUpKSB7XG4gICAgICBpZiAoaXNEZWYob2xkVm5vZGUpKSB7IGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTsgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGlzSW5pdGlhbFBhdGNoID0gZmFsc2U7XG4gICAgdmFyIGluc2VydGVkVm5vZGVRdWV1ZSA9IFtdO1xuXG4gICAgaWYgKGlzVW5kZWYob2xkVm5vZGUpKSB7XG4gICAgICAvLyBlbXB0eSBtb3VudCAobGlrZWx5IGFzIGNvbXBvbmVudCksIGNyZWF0ZSBuZXcgcm9vdCBlbGVtZW50XG4gICAgICBpc0luaXRpYWxQYXRjaCA9IHRydWU7XG4gICAgICBjcmVhdGVFbG0odm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXNSZWFsRWxlbWVudCA9IGlzRGVmKG9sZFZub2RlLm5vZGVUeXBlKTtcbiAgICAgIGlmICghaXNSZWFsRWxlbWVudCAmJiBzYW1lVm5vZGUob2xkVm5vZGUsIHZub2RlKSkge1xuICAgICAgICAvLyBwYXRjaCBleGlzdGluZyByb290IG5vZGVcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNSZWFsRWxlbWVudCkge1xuICAgICAgICAgIC8vIG1vdW50aW5nIHRvIGEgcmVhbCBlbGVtZW50XG4gICAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBzZXJ2ZXItcmVuZGVyZWQgY29udGVudCBhbmQgaWYgd2UgY2FuIHBlcmZvcm1cbiAgICAgICAgICAvLyBhIHN1Y2Nlc3NmdWwgaHlkcmF0aW9uLlxuICAgICAgICAgIGlmIChvbGRWbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBvbGRWbm9kZS5oYXNBdHRyaWJ1dGUoU1NSX0FUVFIpKSB7XG4gICAgICAgICAgICBvbGRWbm9kZS5yZW1vdmVBdHRyaWJ1dGUoU1NSX0FUVFIpO1xuICAgICAgICAgICAgaHlkcmF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzVHJ1ZShoeWRyYXRpbmcpKSB7XG4gICAgICAgICAgICBpZiAoaHlkcmF0ZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkpIHtcbiAgICAgICAgICAgICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG9sZFZub2RlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgICdUaGUgY2xpZW50LXNpZGUgcmVuZGVyZWQgdmlydHVhbCBET00gdHJlZSBpcyBub3QgbWF0Y2hpbmcgJyArXG4gICAgICAgICAgICAgICAgJ3NlcnZlci1yZW5kZXJlZCBjb250ZW50LiBUaGlzIGlzIGxpa2VseSBjYXVzZWQgYnkgaW5jb3JyZWN0ICcgK1xuICAgICAgICAgICAgICAgICdIVE1MIG1hcmt1cCwgZm9yIGV4YW1wbGUgbmVzdGluZyBibG9jay1sZXZlbCBlbGVtZW50cyBpbnNpZGUgJyArXG4gICAgICAgICAgICAgICAgJzxwPiwgb3IgbWlzc2luZyA8dGJvZHk+LiBCYWlsaW5nIGh5ZHJhdGlvbiBhbmQgcGVyZm9ybWluZyAnICtcbiAgICAgICAgICAgICAgICAnZnVsbCBjbGllbnQtc2lkZSByZW5kZXIuJ1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBlaXRoZXIgbm90IHNlcnZlci1yZW5kZXJlZCwgb3IgaHlkcmF0aW9uIGZhaWxlZC5cbiAgICAgICAgICAvLyBjcmVhdGUgYW4gZW1wdHkgbm9kZSBhbmQgcmVwbGFjZSBpdFxuICAgICAgICAgIG9sZFZub2RlID0gZW1wdHlOb2RlQXQob2xkVm5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVwbGFjaW5nIGV4aXN0aW5nIGVsZW1lbnRcbiAgICAgICAgdmFyIG9sZEVsbSA9IG9sZFZub2RlLmVsbTtcbiAgICAgICAgdmFyIHBhcmVudEVsbSQxID0gbm9kZU9wcy5wYXJlbnROb2RlKG9sZEVsbSk7XG5cbiAgICAgICAgLy8gY3JlYXRlIG5ldyBub2RlXG4gICAgICAgIGNyZWF0ZUVsbShcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUsXG4gICAgICAgICAgLy8gZXh0cmVtZWx5IHJhcmUgZWRnZSBjYXNlOiBkbyBub3QgaW5zZXJ0IGlmIG9sZCBlbGVtZW50IGlzIGluIGFcbiAgICAgICAgICAvLyBsZWF2aW5nIHRyYW5zaXRpb24uIE9ubHkgaGFwcGVucyB3aGVuIGNvbWJpbmluZyB0cmFuc2l0aW9uICtcbiAgICAgICAgICAvLyBrZWVwLWFsaXZlICsgSE9Dcy4gKCM0NTkwKVxuICAgICAgICAgIG9sZEVsbS5fbGVhdmVDYiA/IG51bGwgOiBwYXJlbnRFbG0kMSxcbiAgICAgICAgICBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVsbSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyB1cGRhdGUgcGFyZW50IHBsYWNlaG9sZGVyIG5vZGUgZWxlbWVudCwgcmVjdXJzaXZlbHlcbiAgICAgICAgaWYgKGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgICAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZS5wYXJlbnQ7XG4gICAgICAgICAgdmFyIHBhdGNoYWJsZSA9IGlzUGF0Y2hhYmxlKHZub2RlKTtcbiAgICAgICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgY2JzLmRlc3Ryb3lbaV0oYW5jZXN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5jZXN0b3IuZWxtID0gdm5vZGUuZWxtO1xuICAgICAgICAgICAgaWYgKHBhdGNoYWJsZSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgICAgICAgICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCBhbmNlc3Rvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gIzY1MTNcbiAgICAgICAgICAgICAgLy8gaW52b2tlIGluc2VydCBob29rcyB0aGF0IG1heSBoYXZlIGJlZW4gbWVyZ2VkIGJ5IGNyZWF0ZSBob29rcy5cbiAgICAgICAgICAgICAgLy8gZS5nLiBmb3IgZGlyZWN0aXZlcyB0aGF0IHVzZXMgdGhlIFwiaW5zZXJ0ZWRcIiBob29rLlxuICAgICAgICAgICAgICB2YXIgaW5zZXJ0ID0gYW5jZXN0b3IuZGF0YS5ob29rLmluc2VydDtcbiAgICAgICAgICAgICAgaWYgKGluc2VydC5tZXJnZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBzdGFydCBhdCBpbmRleCAxIHRvIGF2b2lkIHJlLWludm9raW5nIGNvbXBvbmVudCBtb3VudGVkIGhvb2tcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDIgPSAxOyBpJDIgPCBpbnNlcnQuZm5zLmxlbmd0aDsgaSQyKyspIHtcbiAgICAgICAgICAgICAgICAgIGluc2VydC5mbnNbaSQyXSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVnaXN0ZXJSZWYoYW5jZXN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGVzdHJveSBvbGQgbm9kZVxuICAgICAgICBpZiAoaXNEZWYocGFyZW50RWxtJDEpKSB7XG4gICAgICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSQxLCBbb2xkVm5vZGVdLCAwLCAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50YWcpKSB7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpc0luaXRpYWxQYXRjaCk7XG4gICAgcmV0dXJuIHZub2RlLmVsbVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgZGlyZWN0aXZlcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICB1cGRhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIHVuYmluZERpcmVjdGl2ZXMgKHZub2RlKSB7XG4gICAgdXBkYXRlRGlyZWN0aXZlcyh2bm9kZSwgZW1wdHlOb2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVEaXJlY3RpdmVzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcyB8fCB2bm9kZS5kYXRhLmRpcmVjdGl2ZXMpIHtcbiAgICBfdXBkYXRlKG9sZFZub2RlLCB2bm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX3VwZGF0ZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBpc0NyZWF0ZSA9IG9sZFZub2RlID09PSBlbXB0eU5vZGU7XG4gIHZhciBpc0Rlc3Ryb3kgPSB2bm9kZSA9PT0gZW1wdHlOb2RlO1xuICB2YXIgb2xkRGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMShvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMsIG9sZFZub2RlLmNvbnRleHQpO1xuICB2YXIgbmV3RGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSh2bm9kZS5kYXRhLmRpcmVjdGl2ZXMsIHZub2RlLmNvbnRleHQpO1xuXG4gIHZhciBkaXJzV2l0aEluc2VydCA9IFtdO1xuICB2YXIgZGlyc1dpdGhQb3N0cGF0Y2ggPSBbXTtcblxuICB2YXIga2V5LCBvbGREaXIsIGRpcjtcbiAgZm9yIChrZXkgaW4gbmV3RGlycykge1xuICAgIG9sZERpciA9IG9sZERpcnNba2V5XTtcbiAgICBkaXIgPSBuZXdEaXJzW2tleV07XG4gICAgaWYgKCFvbGREaXIpIHtcbiAgICAgIC8vIG5ldyBkaXJlY3RpdmUsIGJpbmRcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAnYmluZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmluc2VydGVkKSB7XG4gICAgICAgIGRpcnNXaXRoSW5zZXJ0LnB1c2goZGlyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXhpc3RpbmcgZGlyZWN0aXZlLCB1cGRhdGVcbiAgICAgIGRpci5vbGRWYWx1ZSA9IG9sZERpci52YWx1ZTtcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAndXBkYXRlJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuY29tcG9uZW50VXBkYXRlZCkge1xuICAgICAgICBkaXJzV2l0aFBvc3RwYXRjaC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aCkge1xuICAgIHZhciBjYWxsSW5zZXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aEluc2VydC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoSW5zZXJ0W2ldLCAnaW5zZXJ0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlzQ3JlYXRlKSB7XG4gICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ2luc2VydCcsIGNhbGxJbnNlcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsSW5zZXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aCkge1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoUG9zdHBhdGNoW2ldLCAnY29tcG9uZW50VXBkYXRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAoIWlzQ3JlYXRlKSB7XG4gICAgZm9yIChrZXkgaW4gb2xkRGlycykge1xuICAgICAgaWYgKCFuZXdEaXJzW2tleV0pIHtcbiAgICAgICAgLy8gbm8gbG9uZ2VyIHByZXNlbnQsIHVuYmluZFxuICAgICAgICBjYWxsSG9vayQxKG9sZERpcnNba2V5XSwgJ3VuYmluZCcsIG9sZFZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGVtcHR5TW9kaWZpZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyQxIChcbiAgZGlycyxcbiAgdm1cbikge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKCFkaXJzKSB7XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgcmV0dXJuIHJlc1xuICB9XG4gIHZhciBpLCBkaXI7XG4gIGZvciAoaSA9IDA7IGkgPCBkaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGlyID0gZGlyc1tpXTtcbiAgICBpZiAoIWRpci5tb2RpZmllcnMpIHtcbiAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgZGlyLm1vZGlmaWVycyA9IGVtcHR5TW9kaWZpZXJzO1xuICAgIH1cbiAgICByZXNbZ2V0UmF3RGlyTmFtZShkaXIpXSA9IGRpcjtcbiAgICBkaXIuZGVmID0gcmVzb2x2ZUFzc2V0KHZtLiRvcHRpb25zLCAnZGlyZWN0aXZlcycsIGRpci5uYW1lLCB0cnVlKTtcbiAgfVxuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBnZXRSYXdEaXJOYW1lIChkaXIpIHtcbiAgcmV0dXJuIGRpci5yYXdOYW1lIHx8ICgoZGlyLm5hbWUpICsgXCIuXCIgKyAoT2JqZWN0LmtleXMoZGlyLm1vZGlmaWVycyB8fCB7fSkuam9pbignLicpKSlcbn1cblxuZnVuY3Rpb24gY2FsbEhvb2skMSAoZGlyLCBob29rLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSkge1xuICB2YXIgZm4gPSBkaXIuZGVmICYmIGRpci5kZWZbaG9va107XG4gIGlmIChmbikge1xuICAgIHRyeSB7XG4gICAgICBmbih2bm9kZS5lbG0sIGRpciwgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZub2RlLmNvbnRleHQsIChcImRpcmVjdGl2ZSBcIiArIChkaXIubmFtZSkgKyBcIiBcIiArIGhvb2sgKyBcIiBob29rXCIpKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGJhc2VNb2R1bGVzID0gW1xuICByZWYsXG4gIGRpcmVjdGl2ZXNcbl1cblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZUF0dHJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIG9wdHMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBpZiAoaXNEZWYob3B0cykgJiYgb3B0cy5DdG9yLm9wdGlvbnMuaW5oZXJpdEF0dHJzID09PSBmYWxzZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEuYXR0cnMpICYmIGlzVW5kZWYodm5vZGUuZGF0YS5hdHRycykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIga2V5LCBjdXIsIG9sZDtcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZEF0dHJzID0gb2xkVm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgdmFyIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gIGlmIChpc0RlZihhdHRycy5fX29iX18pKSB7XG4gICAgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzID0gZXh0ZW5kKHt9LCBhdHRycyk7XG4gIH1cblxuICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgIGN1ciA9IGF0dHJzW2tleV07XG4gICAgb2xkID0gb2xkQXR0cnNba2V5XTtcbiAgICBpZiAob2xkICE9PSBjdXIpIHtcbiAgICAgIHNldEF0dHIoZWxtLCBrZXksIGN1cik7XG4gICAgfVxuICB9XG4gIC8vICM0MzkxOiBpbiBJRTksIHNldHRpbmcgdHlwZSBjYW4gcmVzZXQgdmFsdWUgZm9yIGlucHV0W3R5cGU9cmFkaW9dXG4gIC8vICM2NjY2OiBJRS9FZGdlIGZvcmNlcyBwcm9ncmVzcyB2YWx1ZSBkb3duIHRvIDEgYmVmb3JlIHNldHRpbmcgYSBtYXhcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICgoaXNJRSB8fCBpc0VkZ2UpICYmIGF0dHJzLnZhbHVlICE9PSBvbGRBdHRycy52YWx1ZSkge1xuICAgIHNldEF0dHIoZWxtLCAndmFsdWUnLCBhdHRycy52YWx1ZSk7XG4gIH1cbiAgZm9yIChrZXkgaW4gb2xkQXR0cnMpIHtcbiAgICBpZiAoaXNVbmRlZihhdHRyc1trZXldKSkge1xuICAgICAgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xuICAgICAgfSBlbHNlIGlmICghaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0QXR0ciAoZWwsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGVsLnRhZ05hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICBiYXNlU2V0QXR0cihlbCwga2V5LCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoaXNCb29sZWFuQXR0cihrZXkpKSB7XG4gICAgLy8gc2V0IGF0dHJpYnV0ZSBmb3IgYmxhbmsgdmFsdWVcbiAgICAvLyBlLmcuIDxvcHRpb24gZGlzYWJsZWQ+U2VsZWN0IG9uZTwvb3B0aW9uPlxuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRlY2huaWNhbGx5IGFsbG93ZnVsbHNjcmVlbiBpcyBhIGJvb2xlYW4gYXR0cmlidXRlIGZvciA8aWZyYW1lPixcbiAgICAgIC8vIGJ1dCBGbGFzaCBleHBlY3RzIGEgdmFsdWUgb2YgXCJ0cnVlXCIgd2hlbiB1c2VkIG9uIDxlbWJlZD4gdGFnXG4gICAgICB2YWx1ZSA9IGtleSA9PT0gJ2FsbG93ZnVsbHNjcmVlbicgJiYgZWwudGFnTmFtZSA9PT0gJ0VNQkVEJ1xuICAgICAgICA/ICd0cnVlJ1xuICAgICAgICA6IGtleTtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKGtleSwgaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkgfHwgdmFsdWUgPT09ICdmYWxzZScgPyAnZmFsc2UnIDogJ3RydWUnKTtcbiAgfSBlbHNlIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlTlMoeGxpbmtOUywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJhc2VTZXRBdHRyKGVsLCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlU2V0QXR0ciAoZWwsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gIzcxMzg6IElFMTAgJiAxMSBmaXJlcyBpbnB1dCBldmVudCB3aGVuIHNldHRpbmcgcGxhY2Vob2xkZXIgb25cbiAgICAvLyA8dGV4dGFyZWE+Li4uIGJsb2NrIHRoZSBmaXJzdCBpbnB1dCBldmVudCBhbmQgcmVtb3ZlIHRoZSBibG9ja2VyXG4gICAgLy8gaW1tZWRpYXRlbHkuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKFxuICAgICAgaXNJRSAmJiAhaXNJRTkgJiZcbiAgICAgIGVsLnRhZ05hbWUgPT09ICdURVhUQVJFQScgJiZcbiAgICAgIGtleSA9PT0gJ3BsYWNlaG9sZGVyJyAmJiAhZWwuX19pZXBoXG4gICAgKSB7XG4gICAgICB2YXIgYmxvY2tlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgYmxvY2tlcik7XG4gICAgICB9O1xuICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyKTtcbiAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgZWwuX19pZXBoID0gdHJ1ZTsgLyogSUUgcGxhY2Vob2xkZXIgcGF0Y2hlZCAqL1xuICAgIH1cbiAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxudmFyIGF0dHJzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUF0dHJzLFxuICB1cGRhdGU6IHVwZGF0ZUF0dHJzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVDbGFzcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XG4gIGlmIChcbiAgICBpc1VuZGVmKGRhdGEuc3RhdGljQ2xhc3MpICYmXG4gICAgaXNVbmRlZihkYXRhLmNsYXNzKSAmJiAoXG4gICAgICBpc1VuZGVmKG9sZERhdGEpIHx8IChcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLnN0YXRpY0NsYXNzKSAmJlxuICAgICAgICBpc1VuZGVmKG9sZERhdGEuY2xhc3MpXG4gICAgICApXG4gICAgKVxuICApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjbHMgPSBnZW5DbGFzc0ZvclZub2RlKHZub2RlKTtcblxuICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBjbGFzc2VzXG4gIHZhciB0cmFuc2l0aW9uQ2xhc3MgPSBlbC5fdHJhbnNpdGlvbkNsYXNzZXM7XG4gIGlmIChpc0RlZih0cmFuc2l0aW9uQ2xhc3MpKSB7XG4gICAgY2xzID0gY29uY2F0KGNscywgc3RyaW5naWZ5Q2xhc3ModHJhbnNpdGlvbkNsYXNzKSk7XG4gIH1cblxuICAvLyBzZXQgdGhlIGNsYXNzXG4gIGlmIChjbHMgIT09IGVsLl9wcmV2Q2xhc3MpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY2xzKTtcbiAgICBlbC5fcHJldkNsYXNzID0gY2xzO1xuICB9XG59XG5cbnZhciBrbGFzcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVDbGFzcyxcbiAgdXBkYXRlOiB1cGRhdGVDbGFzc1xufVxuXG4vKiAgKi9cblxudmFyIHZhbGlkRGl2aXNpb25DaGFyUkUgPSAvW1xcdykuK1xcLV8kXFxdXS87XG5cbmZ1bmN0aW9uIHBhcnNlRmlsdGVycyAoZXhwKSB7XG4gIHZhciBpblNpbmdsZSA9IGZhbHNlO1xuICB2YXIgaW5Eb3VibGUgPSBmYWxzZTtcbiAgdmFyIGluVGVtcGxhdGVTdHJpbmcgPSBmYWxzZTtcbiAgdmFyIGluUmVnZXggPSBmYWxzZTtcbiAgdmFyIGN1cmx5ID0gMDtcbiAgdmFyIHNxdWFyZSA9IDA7XG4gIHZhciBwYXJlbiA9IDA7XG4gIHZhciBsYXN0RmlsdGVySW5kZXggPSAwO1xuICB2YXIgYywgcHJldiwgaSwgZXhwcmVzc2lvbiwgZmlsdGVycztcblxuICBmb3IgKGkgPSAwOyBpIDwgZXhwLmxlbmd0aDsgaSsrKSB7XG4gICAgcHJldiA9IGM7XG4gICAgYyA9IGV4cC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChpblNpbmdsZSkge1xuICAgICAgaWYgKGMgPT09IDB4MjcgJiYgcHJldiAhPT0gMHg1QykgeyBpblNpbmdsZSA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChpbkRvdWJsZSkge1xuICAgICAgaWYgKGMgPT09IDB4MjIgJiYgcHJldiAhPT0gMHg1QykgeyBpbkRvdWJsZSA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChpblRlbXBsYXRlU3RyaW5nKSB7XG4gICAgICBpZiAoYyA9PT0gMHg2MCAmJiBwcmV2ICE9PSAweDVDKSB7IGluVGVtcGxhdGVTdHJpbmcgPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoaW5SZWdleCkge1xuICAgICAgaWYgKGMgPT09IDB4MmYgJiYgcHJldiAhPT0gMHg1QykgeyBpblJlZ2V4ID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgYyA9PT0gMHg3QyAmJiAvLyBwaXBlXG4gICAgICBleHAuY2hhckNvZGVBdChpICsgMSkgIT09IDB4N0MgJiZcbiAgICAgIGV4cC5jaGFyQ29kZUF0KGkgLSAxKSAhPT0gMHg3QyAmJlxuICAgICAgIWN1cmx5ICYmICFzcXVhcmUgJiYgIXBhcmVuXG4gICAgKSB7XG4gICAgICBpZiAoZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGZpcnN0IGZpbHRlciwgZW5kIG9mIGV4cHJlc3Npb25cbiAgICAgICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG4gICAgICAgIGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHVzaEZpbHRlcigpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgY2FzZSAweDIyOiBpbkRvdWJsZSA9IHRydWU7IGJyZWFrICAgICAgICAgLy8gXCJcbiAgICAgICAgY2FzZSAweDI3OiBpblNpbmdsZSA9IHRydWU7IGJyZWFrICAgICAgICAgLy8gJ1xuICAgICAgICBjYXNlIDB4NjA6IGluVGVtcGxhdGVTdHJpbmcgPSB0cnVlOyBicmVhayAvLyBgXG4gICAgICAgIGNhc2UgMHgyODogcGFyZW4rKzsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIChcbiAgICAgICAgY2FzZSAweDI5OiBwYXJlbi0tOyBicmVhayAgICAgICAgICAgICAgICAgLy8gKVxuICAgICAgICBjYXNlIDB4NUI6IHNxdWFyZSsrOyBicmVhayAgICAgICAgICAgICAgICAvLyBbXG4gICAgICAgIGNhc2UgMHg1RDogc3F1YXJlLS07IGJyZWFrICAgICAgICAgICAgICAgIC8vIF1cbiAgICAgICAgY2FzZSAweDdCOiBjdXJseSsrOyBicmVhayAgICAgICAgICAgICAgICAgLy8ge1xuICAgICAgICBjYXNlIDB4N0Q6IGN1cmx5LS07IGJyZWFrICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICB9XG4gICAgICBpZiAoYyA9PT0gMHgyZikgeyAvLyAvXG4gICAgICAgIHZhciBqID0gaSAtIDE7XG4gICAgICAgIHZhciBwID0gKHZvaWQgMCk7XG4gICAgICAgIC8vIGZpbmQgZmlyc3Qgbm9uLXdoaXRlc3BhY2UgcHJldiBjaGFyXG4gICAgICAgIGZvciAoOyBqID49IDA7IGotLSkge1xuICAgICAgICAgIHAgPSBleHAuY2hhckF0KGopO1xuICAgICAgICAgIGlmIChwICE9PSAnICcpIHsgYnJlYWsgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcCB8fCAhdmFsaWREaXZpc2lvbkNoYXJSRS50ZXN0KHApKSB7XG4gICAgICAgICAgaW5SZWdleCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XG4gIH0gZWxzZSBpZiAobGFzdEZpbHRlckluZGV4ICE9PSAwKSB7XG4gICAgcHVzaEZpbHRlcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaEZpbHRlciAoKSB7XG4gICAgKGZpbHRlcnMgfHwgKGZpbHRlcnMgPSBbXSkpLnB1c2goZXhwLnNsaWNlKGxhc3RGaWx0ZXJJbmRleCwgaSkudHJpbSgpKTtcbiAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbiAgfVxuXG4gIGlmIChmaWx0ZXJzKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGZpbHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGV4cHJlc3Npb24gPSB3cmFwRmlsdGVyKGV4cHJlc3Npb24sIGZpbHRlcnNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBleHByZXNzaW9uXG59XG5cbmZ1bmN0aW9uIHdyYXBGaWx0ZXIgKGV4cCwgZmlsdGVyKSB7XG4gIHZhciBpID0gZmlsdGVyLmluZGV4T2YoJygnKTtcbiAgaWYgKGkgPCAwKSB7XG4gICAgLy8gX2Y6IHJlc29sdmVGaWx0ZXJcbiAgICByZXR1cm4gKFwiX2YoXFxcIlwiICsgZmlsdGVyICsgXCJcXFwiKShcIiArIGV4cCArIFwiKVwiKVxuICB9IGVsc2Uge1xuICAgIHZhciBuYW1lID0gZmlsdGVyLnNsaWNlKDAsIGkpO1xuICAgIHZhciBhcmdzID0gZmlsdGVyLnNsaWNlKGkgKyAxKTtcbiAgICByZXR1cm4gKFwiX2YoXFxcIlwiICsgbmFtZSArIFwiXFxcIikoXCIgKyBleHAgKyAoYXJncyAhPT0gJyknID8gJywnICsgYXJncyA6IGFyZ3MpKVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiYXNlV2FybiAobXNnKSB7XG4gIGNvbnNvbGUuZXJyb3IoKFwiW1Z1ZSBjb21waWxlcl06IFwiICsgbXNnKSk7XG59XG5cbmZ1bmN0aW9uIHBsdWNrTW9kdWxlRnVuY3Rpb24gKFxuICBtb2R1bGVzLFxuICBrZXlcbikge1xuICByZXR1cm4gbW9kdWxlc1xuICAgID8gbW9kdWxlcy5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG1ba2V5XTsgfSkuZmlsdGVyKGZ1bmN0aW9uIChfKSB7IHJldHVybiBfOyB9KVxuICAgIDogW11cbn1cblxuZnVuY3Rpb24gYWRkUHJvcCAoZWwsIG5hbWUsIHZhbHVlKSB7XG4gIChlbC5wcm9wcyB8fCAoZWwucHJvcHMgPSBbXSkpLnB1c2goeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfSk7XG4gIGVsLnBsYWluID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHIgKGVsLCBuYW1lLCB2YWx1ZSkge1xuICAoZWwuYXR0cnMgfHwgKGVsLmF0dHJzID0gW10pKS5wdXNoKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlIH0pO1xuICBlbC5wbGFpbiA9IGZhbHNlO1xufVxuXG4vLyBhZGQgYSByYXcgYXR0ciAodXNlIHRoaXMgaW4gcHJlVHJhbnNmb3JtcylcbmZ1bmN0aW9uIGFkZFJhd0F0dHIgKGVsLCBuYW1lLCB2YWx1ZSkge1xuICBlbC5hdHRyc01hcFtuYW1lXSA9IHZhbHVlO1xuICBlbC5hdHRyc0xpc3QucHVzaCh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KTtcbn1cblxuZnVuY3Rpb24gYWRkRGlyZWN0aXZlIChcbiAgZWwsXG4gIG5hbWUsXG4gIHJhd05hbWUsXG4gIHZhbHVlLFxuICBhcmcsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIChlbC5kaXJlY3RpdmVzIHx8IChlbC5kaXJlY3RpdmVzID0gW10pKS5wdXNoKHsgbmFtZTogbmFtZSwgcmF3TmFtZTogcmF3TmFtZSwgdmFsdWU6IHZhbHVlLCBhcmc6IGFyZywgbW9kaWZpZXJzOiBtb2RpZmllcnMgfSk7XG4gIGVsLnBsYWluID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGFkZEhhbmRsZXIgKFxuICBlbCxcbiAgbmFtZSxcbiAgdmFsdWUsXG4gIG1vZGlmaWVycyxcbiAgaW1wb3J0YW50LFxuICB3YXJuXG4pIHtcbiAgbW9kaWZpZXJzID0gbW9kaWZpZXJzIHx8IGVtcHR5T2JqZWN0O1xuICAvLyB3YXJuIHByZXZlbnQgYW5kIHBhc3NpdmUgbW9kaWZpZXJcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChcbiAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuICYmXG4gICAgbW9kaWZpZXJzLnByZXZlbnQgJiYgbW9kaWZpZXJzLnBhc3NpdmVcbiAgKSB7XG4gICAgd2FybihcbiAgICAgICdwYXNzaXZlIGFuZCBwcmV2ZW50IGNhblxcJ3QgYmUgdXNlZCB0b2dldGhlci4gJyArXG4gICAgICAnUGFzc2l2ZSBoYW5kbGVyIGNhblxcJ3QgcHJldmVudCBkZWZhdWx0IGV2ZW50LidcbiAgICApO1xuICB9XG5cbiAgLy8gY2hlY2sgY2FwdHVyZSBtb2RpZmllclxuICBpZiAobW9kaWZpZXJzLmNhcHR1cmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLmNhcHR1cmU7XG4gICAgbmFtZSA9ICchJyArIG5hbWU7IC8vIG1hcmsgdGhlIGV2ZW50IGFzIGNhcHR1cmVkXG4gIH1cbiAgaWYgKG1vZGlmaWVycy5vbmNlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5vbmNlO1xuICAgIG5hbWUgPSAnficgKyBuYW1lOyAvLyBtYXJrIHRoZSBldmVudCBhcyBvbmNlXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChtb2RpZmllcnMucGFzc2l2ZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMucGFzc2l2ZTtcbiAgICBuYW1lID0gJyYnICsgbmFtZTsgLy8gbWFyayB0aGUgZXZlbnQgYXMgcGFzc2l2ZVxuICB9XG5cbiAgLy8gbm9ybWFsaXplIGNsaWNrLnJpZ2h0IGFuZCBjbGljay5taWRkbGUgc2luY2UgdGhleSBkb24ndCBhY3R1YWxseSBmaXJlXG4gIC8vIHRoaXMgaXMgdGVjaG5pY2FsbHkgYnJvd3Nlci1zcGVjaWZpYywgYnV0IGF0IGxlYXN0IGZvciBub3cgYnJvd3NlcnMgYXJlXG4gIC8vIHRoZSBvbmx5IHRhcmdldCBlbnZzIHRoYXQgaGF2ZSByaWdodC9taWRkbGUgY2xpY2tzLlxuICBpZiAobmFtZSA9PT0gJ2NsaWNrJykge1xuICAgIGlmIChtb2RpZmllcnMucmlnaHQpIHtcbiAgICAgIG5hbWUgPSAnY29udGV4dG1lbnUnO1xuICAgICAgZGVsZXRlIG1vZGlmaWVycy5yaWdodDtcbiAgICB9IGVsc2UgaWYgKG1vZGlmaWVycy5taWRkbGUpIHtcbiAgICAgIG5hbWUgPSAnbW91c2V1cCc7XG4gICAgfVxuICB9XG5cbiAgdmFyIGV2ZW50cztcbiAgaWYgKG1vZGlmaWVycy5uYXRpdmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLm5hdGl2ZTtcbiAgICBldmVudHMgPSBlbC5uYXRpdmVFdmVudHMgfHwgKGVsLm5hdGl2ZUV2ZW50cyA9IHt9KTtcbiAgfSBlbHNlIHtcbiAgICBldmVudHMgPSBlbC5ldmVudHMgfHwgKGVsLmV2ZW50cyA9IHt9KTtcbiAgfVxuXG4gIHZhciBuZXdIYW5kbGVyID0ge1xuICAgIHZhbHVlOiB2YWx1ZS50cmltKClcbiAgfTtcbiAgaWYgKG1vZGlmaWVycyAhPT0gZW1wdHlPYmplY3QpIHtcbiAgICBuZXdIYW5kbGVyLm1vZGlmaWVycyA9IG1vZGlmaWVycztcbiAgfVxuXG4gIHZhciBoYW5kbGVycyA9IGV2ZW50c1tuYW1lXTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXJzKSkge1xuICAgIGltcG9ydGFudCA/IGhhbmRsZXJzLnVuc2hpZnQobmV3SGFuZGxlcikgOiBoYW5kbGVycy5wdXNoKG5ld0hhbmRsZXIpO1xuICB9IGVsc2UgaWYgKGhhbmRsZXJzKSB7XG4gICAgZXZlbnRzW25hbWVdID0gaW1wb3J0YW50ID8gW25ld0hhbmRsZXIsIGhhbmRsZXJzXSA6IFtoYW5kbGVycywgbmV3SGFuZGxlcl07XG4gIH0gZWxzZSB7XG4gICAgZXZlbnRzW25hbWVdID0gbmV3SGFuZGxlcjtcbiAgfVxuXG4gIGVsLnBsYWluID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldEJpbmRpbmdBdHRyIChcbiAgZWwsXG4gIG5hbWUsXG4gIGdldFN0YXRpY1xuKSB7XG4gIHZhciBkeW5hbWljVmFsdWUgPVxuICAgIGdldEFuZFJlbW92ZUF0dHIoZWwsICc6JyArIG5hbWUpIHx8XG4gICAgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtYmluZDonICsgbmFtZSk7XG4gIGlmIChkeW5hbWljVmFsdWUgIT0gbnVsbCkge1xuICAgIHJldHVybiBwYXJzZUZpbHRlcnMoZHluYW1pY1ZhbHVlKVxuICB9IGVsc2UgaWYgKGdldFN0YXRpYyAhPT0gZmFsc2UpIHtcbiAgICB2YXIgc3RhdGljVmFsdWUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCBuYW1lKTtcbiAgICBpZiAoc3RhdGljVmFsdWUgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHN0YXRpY1ZhbHVlKVxuICAgIH1cbiAgfVxufVxuXG4vLyBub3RlOiB0aGlzIG9ubHkgcmVtb3ZlcyB0aGUgYXR0ciBmcm9tIHRoZSBBcnJheSAoYXR0cnNMaXN0KSBzbyB0aGF0IGl0XG4vLyBkb2Vzbid0IGdldCBwcm9jZXNzZWQgYnkgcHJvY2Vzc0F0dHJzLlxuLy8gQnkgZGVmYXVsdCBpdCBkb2VzIE5PVCByZW1vdmUgaXQgZnJvbSB0aGUgbWFwIChhdHRyc01hcCkgYmVjYXVzZSB0aGUgbWFwIGlzXG4vLyBuZWVkZWQgZHVyaW5nIGNvZGVnZW4uXG5mdW5jdGlvbiBnZXRBbmRSZW1vdmVBdHRyIChcbiAgZWwsXG4gIG5hbWUsXG4gIHJlbW92ZUZyb21NYXBcbikge1xuICB2YXIgdmFsO1xuICBpZiAoKHZhbCA9IGVsLmF0dHJzTWFwW25hbWVdKSAhPSBudWxsKSB7XG4gICAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGxpc3RbaV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICBsaXN0LnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHJlbW92ZUZyb21NYXApIHtcbiAgICBkZWxldGUgZWwuYXR0cnNNYXBbbmFtZV07XG4gIH1cbiAgcmV0dXJuIHZhbFxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlIGdlbmVyYXRpb24gZm9yIGNvbXBvbmVudCB2LW1vZGVsXG4gKi9cbmZ1bmN0aW9uIGdlbkNvbXBvbmVudE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgcmVmID0gbW9kaWZpZXJzIHx8IHt9O1xuICB2YXIgbnVtYmVyID0gcmVmLm51bWJlcjtcbiAgdmFyIHRyaW0gPSByZWYudHJpbTtcblxuICB2YXIgYmFzZVZhbHVlRXhwcmVzc2lvbiA9ICckJHYnO1xuICB2YXIgdmFsdWVFeHByZXNzaW9uID0gYmFzZVZhbHVlRXhwcmVzc2lvbjtcbiAgaWYgKHRyaW0pIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPVxuICAgICAgXCIodHlwZW9mIFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiID09PSAnc3RyaW5nJ1wiICtcbiAgICAgIFwiPyBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIi50cmltKClcIiArXG4gICAgICBcIjogXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG4gIH1cbiAgaWYgKG51bWJlcikge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiX24oXCIgKyB2YWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuICB2YXIgYXNzaWdubWVudCA9IGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUV4cHJlc3Npb24pO1xuXG4gIGVsLm1vZGVsID0ge1xuICAgIHZhbHVlOiAoXCIoXCIgKyB2YWx1ZSArIFwiKVwiKSxcbiAgICBleHByZXNzaW9uOiAoXCJcXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSxcbiAgICBjYWxsYmFjazogKFwiZnVuY3Rpb24gKFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiKSB7XCIgKyBhc3NpZ25tZW50ICsgXCJ9XCIpXG4gIH07XG59XG5cbi8qKlxuICogQ3Jvc3MtcGxhdGZvcm0gY29kZWdlbiBoZWxwZXIgZm9yIGdlbmVyYXRpbmcgdi1tb2RlbCB2YWx1ZSBhc3NpZ25tZW50IGNvZGUuXG4gKi9cbmZ1bmN0aW9uIGdlbkFzc2lnbm1lbnRDb2RlIChcbiAgdmFsdWUsXG4gIGFzc2lnbm1lbnRcbikge1xuICB2YXIgcmVzID0gcGFyc2VNb2RlbCh2YWx1ZSk7XG4gIGlmIChyZXMua2V5ID09PSBudWxsKSB7XG4gICAgcmV0dXJuICh2YWx1ZSArIFwiPVwiICsgYXNzaWdubWVudClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKFwiJHNldChcIiArIChyZXMuZXhwKSArIFwiLCBcIiArIChyZXMua2V5KSArIFwiLCBcIiArIGFzc2lnbm1lbnQgKyBcIilcIilcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIGEgdi1tb2RlbCBleHByZXNzaW9uIGludG8gYSBiYXNlIHBhdGggYW5kIGEgZmluYWwga2V5IHNlZ21lbnQuXG4gKiBIYW5kbGVzIGJvdGggZG90LXBhdGggYW5kIHBvc3NpYmxlIHNxdWFyZSBicmFja2V0cy5cbiAqXG4gKiBQb3NzaWJsZSBjYXNlczpcbiAqXG4gKiAtIHRlc3RcbiAqIC0gdGVzdFtrZXldXG4gKiAtIHRlc3RbdGVzdDFba2V5XV1cbiAqIC0gdGVzdFtcImFcIl1ba2V5XVxuICogLSB4eHgudGVzdFthW2FdLnRlc3QxW2tleV1dXG4gKiAtIHRlc3QueHh4LmFbXCJhc2FcIl1bdGVzdDFba2V5XV1cbiAqXG4gKi9cblxudmFyIGxlbjtcbnZhciBzdHI7XG52YXIgY2hyO1xudmFyIGluZGV4JDE7XG52YXIgZXhwcmVzc2lvblBvcztcbnZhciBleHByZXNzaW9uRW5kUG9zO1xuXG5cblxuZnVuY3Rpb24gcGFyc2VNb2RlbCAodmFsKSB7XG4gIC8vIEZpeCBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlL3B1bGwvNzczMFxuICAvLyBhbGxvdyB2LW1vZGVsPVwib2JqLnZhbCBcIiAodHJhaWxpbmcgd2hpdGVzcGFjZSlcbiAgdmFsID0gdmFsLnRyaW0oKTtcbiAgbGVuID0gdmFsLmxlbmd0aDtcblxuICBpZiAodmFsLmluZGV4T2YoJ1snKSA8IDAgfHwgdmFsLmxhc3RJbmRleE9mKCddJykgPCBsZW4gLSAxKSB7XG4gICAgaW5kZXgkMSA9IHZhbC5sYXN0SW5kZXhPZignLicpO1xuICAgIGlmIChpbmRleCQxID4gLTEpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGV4cDogdmFsLnNsaWNlKDAsIGluZGV4JDEpLFxuICAgICAgICBrZXk6ICdcIicgKyB2YWwuc2xpY2UoaW5kZXgkMSArIDEpICsgJ1wiJ1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBleHA6IHZhbCxcbiAgICAgICAga2V5OiBudWxsXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3RyID0gdmFsO1xuICBpbmRleCQxID0gZXhwcmVzc2lvblBvcyA9IGV4cHJlc3Npb25FbmRQb3MgPSAwO1xuXG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xuICAgICAgcGFyc2VTdHJpbmcoY2hyKTtcbiAgICB9IGVsc2UgaWYgKGNociA9PT0gMHg1Qikge1xuICAgICAgcGFyc2VCcmFja2V0KGNocik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBleHA6IHZhbC5zbGljZSgwLCBleHByZXNzaW9uUG9zKSxcbiAgICBrZXk6IHZhbC5zbGljZShleHByZXNzaW9uUG9zICsgMSwgZXhwcmVzc2lvbkVuZFBvcylcbiAgfVxufVxuXG5mdW5jdGlvbiBuZXh0ICgpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQ29kZUF0KCsraW5kZXgkMSlcbn1cblxuZnVuY3Rpb24gZW9mICgpIHtcbiAgcmV0dXJuIGluZGV4JDEgPj0gbGVuXG59XG5cbmZ1bmN0aW9uIGlzU3RyaW5nU3RhcnQgKGNocikge1xuICByZXR1cm4gY2hyID09PSAweDIyIHx8IGNociA9PT0gMHgyN1xufVxuXG5mdW5jdGlvbiBwYXJzZUJyYWNrZXQgKGNocikge1xuICB2YXIgaW5CcmFja2V0ID0gMTtcbiAgZXhwcmVzc2lvblBvcyA9IGluZGV4JDE7XG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xuICAgICAgcGFyc2VTdHJpbmcoY2hyKTtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmIChjaHIgPT09IDB4NUIpIHsgaW5CcmFja2V0Kys7IH1cbiAgICBpZiAoY2hyID09PSAweDVEKSB7IGluQnJhY2tldC0tOyB9XG4gICAgaWYgKGluQnJhY2tldCA9PT0gMCkge1xuICAgICAgZXhwcmVzc2lvbkVuZFBvcyA9IGluZGV4JDE7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZVN0cmluZyAoY2hyKSB7XG4gIHZhciBzdHJpbmdRdW90ZSA9IGNocjtcbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICBpZiAoY2hyID09PSBzdHJpbmdRdW90ZSkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciB3YXJuJDE7XG5cbi8vIGluIHNvbWUgY2FzZXMsIHRoZSBldmVudCB1c2VkIGhhcyB0byBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWVcbi8vIHNvIHdlIHVzZWQgc29tZSByZXNlcnZlZCB0b2tlbnMgZHVyaW5nIGNvbXBpbGUuXG52YXIgUkFOR0VfVE9LRU4gPSAnX19yJztcbnZhciBDSEVDS0JPWF9SQURJT19UT0tFTiA9ICdfX2MnO1xuXG5mdW5jdGlvbiBtb2RlbCAoXG4gIGVsLFxuICBkaXIsXG4gIF93YXJuXG4pIHtcbiAgd2FybiQxID0gX3dhcm47XG4gIHZhciB2YWx1ZSA9IGRpci52YWx1ZTtcbiAgdmFyIG1vZGlmaWVycyA9IGRpci5tb2RpZmllcnM7XG4gIHZhciB0YWcgPSBlbC50YWc7XG4gIHZhciB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcblxuICB7XG4gICAgLy8gaW5wdXRzIHdpdGggdHlwZT1cImZpbGVcIiBhcmUgcmVhZCBvbmx5IGFuZCBzZXR0aW5nIHRoZSBpbnB1dCdzXG4gICAgLy8gdmFsdWUgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdmaWxlJykge1xuICAgICAgd2FybiQxKFxuICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIiB0eXBlPVxcXCJmaWxlXFxcIj46XFxuXCIgK1xuICAgICAgICBcIkZpbGUgaW5wdXRzIGFyZSByZWFkIG9ubHkuIFVzZSBhIHYtb246Y2hhbmdlIGxpc3RlbmVyIGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgIGdlbkNvbXBvbmVudE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICAvLyBjb21wb25lbnQgdi1tb2RlbCBkb2Vzbid0IG5lZWQgZXh0cmEgcnVudGltZVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICBnZW5TZWxlY3QoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgZ2VuQ2hlY2tib3hNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdyYWRpbycpIHtcbiAgICBnZW5SYWRpb01vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgfHwgdGFnID09PSAndGV4dGFyZWEnKSB7XG4gICAgZ2VuRGVmYXVsdE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICghY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgIGdlbkNvbXBvbmVudE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICAvLyBjb21wb25lbnQgdi1tb2RlbCBkb2Vzbid0IG5lZWQgZXh0cmEgcnVudGltZVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2Uge1xuICAgIHdhcm4kMShcbiAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiPjogXCIgK1xuICAgICAgXCJ2LW1vZGVsIGlzIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBlbGVtZW50IHR5cGUuIFwiICtcbiAgICAgICdJZiB5b3UgYXJlIHdvcmtpbmcgd2l0aCBjb250ZW50ZWRpdGFibGUsIGl0XFwncyByZWNvbW1lbmRlZCB0byAnICtcbiAgICAgICd3cmFwIGEgbGlicmFyeSBkZWRpY2F0ZWQgZm9yIHRoYXQgcHVycG9zZSBpbnNpZGUgYSBjdXN0b20gY29tcG9uZW50LidcbiAgICApO1xuICB9XG5cbiAgLy8gZW5zdXJlIHJ1bnRpbWUgZGlyZWN0aXZlIG1ldGFkYXRhXG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGdlbkNoZWNrYm94TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgdmFyIHZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndmFsdWUnKSB8fCAnbnVsbCc7XG4gIHZhciB0cnVlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd0cnVlLXZhbHVlJykgfHwgJ3RydWUnO1xuICB2YXIgZmFsc2VWYWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2ZhbHNlLXZhbHVlJykgfHwgJ2ZhbHNlJztcbiAgYWRkUHJvcChlbCwgJ2NoZWNrZWQnLFxuICAgIFwiQXJyYXkuaXNBcnJheShcIiArIHZhbHVlICsgXCIpXCIgK1xuICAgIFwiP19pKFwiICsgdmFsdWUgKyBcIixcIiArIHZhbHVlQmluZGluZyArIFwiKT4tMVwiICsgKFxuICAgICAgdHJ1ZVZhbHVlQmluZGluZyA9PT0gJ3RydWUnXG4gICAgICAgID8gKFwiOihcIiArIHZhbHVlICsgXCIpXCIpXG4gICAgICAgIDogKFwiOl9xKFwiICsgdmFsdWUgKyBcIixcIiArIHRydWVWYWx1ZUJpbmRpbmcgKyBcIilcIilcbiAgICApXG4gICk7XG4gIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLFxuICAgIFwidmFyICQkYT1cIiArIHZhbHVlICsgXCIsXCIgK1xuICAgICAgICAnJCRlbD0kZXZlbnQudGFyZ2V0LCcgK1xuICAgICAgICBcIiQkYz0kJGVsLmNoZWNrZWQ/KFwiICsgdHJ1ZVZhbHVlQmluZGluZyArIFwiKTooXCIgKyBmYWxzZVZhbHVlQmluZGluZyArIFwiKTtcIiArXG4gICAgJ2lmKEFycmF5LmlzQXJyYXkoJCRhKSl7JyArXG4gICAgICBcInZhciAkJHY9XCIgKyAobnVtYmVyID8gJ19uKCcgKyB2YWx1ZUJpbmRpbmcgKyAnKScgOiB2YWx1ZUJpbmRpbmcpICsgXCIsXCIgK1xuICAgICAgICAgICckJGk9X2koJCRhLCQkdik7JyArXG4gICAgICBcImlmKCQkZWwuY2hlY2tlZCl7JCRpPDAmJihcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgJyQkYS5jb25jYXQoWyQkdl0pJykpICsgXCIpfVwiICtcbiAgICAgIFwiZWxzZXskJGk+LTEmJihcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgJyQkYS5zbGljZSgwLCQkaSkuY29uY2F0KCQkYS5zbGljZSgkJGkrMSkpJykpICsgXCIpfVwiICtcbiAgICBcIn1lbHNle1wiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCAnJCRjJykpICsgXCJ9XCIsXG4gICAgbnVsbCwgdHJ1ZVxuICApO1xufVxuXG5mdW5jdGlvbiBnZW5SYWRpb01vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIHZhciB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xuICB2YWx1ZUJpbmRpbmcgPSBudW1iZXIgPyAoXCJfbihcIiArIHZhbHVlQmluZGluZyArIFwiKVwiKSA6IHZhbHVlQmluZGluZztcbiAgYWRkUHJvcChlbCwgJ2NoZWNrZWQnLCAoXCJfcShcIiArIHZhbHVlICsgXCIsXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIilcIikpO1xuICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJywgZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlQmluZGluZyksIG51bGwsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBnZW5TZWxlY3QgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgdmFyIHNlbGVjdGVkVmFsID0gXCJBcnJheS5wcm90b3R5cGUuZmlsdGVyXCIgK1xuICAgIFwiLmNhbGwoJGV2ZW50LnRhcmdldC5vcHRpb25zLGZ1bmN0aW9uKG8pe3JldHVybiBvLnNlbGVjdGVkfSlcIiArXG4gICAgXCIubWFwKGZ1bmN0aW9uKG8pe3ZhciB2YWwgPSBcXFwiX3ZhbHVlXFxcIiBpbiBvID8gby5fdmFsdWUgOiBvLnZhbHVlO1wiICtcbiAgICBcInJldHVybiBcIiArIChudW1iZXIgPyAnX24odmFsKScgOiAndmFsJykgKyBcIn0pXCI7XG5cbiAgdmFyIGFzc2lnbm1lbnQgPSAnJGV2ZW50LnRhcmdldC5tdWx0aXBsZSA/ICQkc2VsZWN0ZWRWYWwgOiAkJHNlbGVjdGVkVmFsWzBdJztcbiAgdmFyIGNvZGUgPSBcInZhciAkJHNlbGVjdGVkVmFsID0gXCIgKyBzZWxlY3RlZFZhbCArIFwiO1wiO1xuICBjb2RlID0gY29kZSArIFwiIFwiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCBhc3NpZ25tZW50KSk7XG4gIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLCBjb2RlLCBudWxsLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gZ2VuRGVmYXVsdE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgdHlwZSA9IGVsLmF0dHJzTWFwLnR5cGU7XG5cbiAgLy8gd2FybiBpZiB2LWJpbmQ6dmFsdWUgY29uZmxpY3RzIHdpdGggdi1tb2RlbFxuICAvLyBleGNlcHQgZm9yIGlucHV0cyB3aXRoIHYtYmluZDp0eXBlXG4gIHtcbiAgICB2YXIgdmFsdWUkMSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dmFsdWUnXSB8fCBlbC5hdHRyc01hcFsnOnZhbHVlJ107XG4gICAgdmFyIHR5cGVCaW5kaW5nID0gZWwuYXR0cnNNYXBbJ3YtYmluZDp0eXBlJ10gfHwgZWwuYXR0cnNNYXBbJzp0eXBlJ107XG4gICAgaWYgKHZhbHVlJDEgJiYgIXR5cGVCaW5kaW5nKSB7XG4gICAgICB2YXIgYmluZGluZyA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dmFsdWUnXSA/ICd2LWJpbmQ6dmFsdWUnIDogJzp2YWx1ZSc7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGJpbmRpbmcgKyBcIj1cXFwiXCIgKyB2YWx1ZSQxICsgXCJcXFwiIGNvbmZsaWN0cyB3aXRoIHYtbW9kZWwgb24gdGhlIHNhbWUgZWxlbWVudCBcIiArXG4gICAgICAgICdiZWNhdXNlIHRoZSBsYXR0ZXIgYWxyZWFkeSBleHBhbmRzIHRvIGEgdmFsdWUgYmluZGluZyBpbnRlcm5hbGx5J1xuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcmVmID0gbW9kaWZpZXJzIHx8IHt9O1xuICB2YXIgbGF6eSA9IHJlZi5sYXp5O1xuICB2YXIgbnVtYmVyID0gcmVmLm51bWJlcjtcbiAgdmFyIHRyaW0gPSByZWYudHJpbTtcbiAgdmFyIG5lZWRDb21wb3NpdGlvbkd1YXJkID0gIWxhenkgJiYgdHlwZSAhPT0gJ3JhbmdlJztcbiAgdmFyIGV2ZW50ID0gbGF6eVxuICAgID8gJ2NoYW5nZSdcbiAgICA6IHR5cGUgPT09ICdyYW5nZSdcbiAgICAgID8gUkFOR0VfVE9LRU5cbiAgICAgIDogJ2lucHV0JztcblxuICB2YXIgdmFsdWVFeHByZXNzaW9uID0gJyRldmVudC50YXJnZXQudmFsdWUnO1xuICBpZiAodHJpbSkge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiJGV2ZW50LnRhcmdldC52YWx1ZS50cmltKClcIjtcbiAgfVxuICBpZiAobnVtYmVyKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID0gXCJfbihcIiArIHZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICB9XG5cbiAgdmFyIGNvZGUgPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVFeHByZXNzaW9uKTtcbiAgaWYgKG5lZWRDb21wb3NpdGlvbkd1YXJkKSB7XG4gICAgY29kZSA9IFwiaWYoJGV2ZW50LnRhcmdldC5jb21wb3NpbmcpcmV0dXJuO1wiICsgY29kZTtcbiAgfVxuXG4gIGFkZFByb3AoZWwsICd2YWx1ZScsIChcIihcIiArIHZhbHVlICsgXCIpXCIpKTtcbiAgYWRkSGFuZGxlcihlbCwgZXZlbnQsIGNvZGUsIG51bGwsIHRydWUpO1xuICBpZiAodHJpbSB8fCBudW1iZXIpIHtcbiAgICBhZGRIYW5kbGVyKGVsLCAnYmx1cicsICckZm9yY2VVcGRhdGUoKScpO1xuICB9XG59XG5cbi8qICAqL1xuXG4vLyBub3JtYWxpemUgdi1tb2RlbCBldmVudCB0b2tlbnMgdGhhdCBjYW4gb25seSBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWUuXG4vLyBpdCdzIGltcG9ydGFudCB0byBwbGFjZSB0aGUgZXZlbnQgYXMgdGhlIGZpcnN0IGluIHRoZSBhcnJheSBiZWNhdXNlXG4vLyB0aGUgd2hvbGUgcG9pbnQgaXMgZW5zdXJpbmcgdGhlIHYtbW9kZWwgY2FsbGJhY2sgZ2V0cyBjYWxsZWQgYmVmb3JlXG4vLyB1c2VyLWF0dGFjaGVkIGhhbmRsZXJzLlxuZnVuY3Rpb24gbm9ybWFsaXplRXZlbnRzIChvbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKG9uW1JBTkdFX1RPS0VOXSkpIHtcbiAgICAvLyBJRSBpbnB1dFt0eXBlPXJhbmdlXSBvbmx5IHN1cHBvcnRzIGBjaGFuZ2VgIGV2ZW50XG4gICAgdmFyIGV2ZW50ID0gaXNJRSA/ICdjaGFuZ2UnIDogJ2lucHV0JztcbiAgICBvbltldmVudF0gPSBbXS5jb25jYXQob25bUkFOR0VfVE9LRU5dLCBvbltldmVudF0gfHwgW10pO1xuICAgIGRlbGV0ZSBvbltSQU5HRV9UT0tFTl07XG4gIH1cbiAgLy8gVGhpcyB3YXMgb3JpZ2luYWxseSBpbnRlbmRlZCB0byBmaXggIzQ1MjEgYnV0IG5vIGxvbmdlciBuZWNlc3NhcnlcbiAgLy8gYWZ0ZXIgMi41LiBLZWVwaW5nIGl0IGZvciBiYWNrd2FyZHMgY29tcGF0IHdpdGggZ2VuZXJhdGVkIGNvZGUgZnJvbSA8IDIuNFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSkpIHtcbiAgICBvbi5jaGFuZ2UgPSBbXS5jb25jYXQob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dLCBvbi5jaGFuZ2UgfHwgW10pO1xuICAgIGRlbGV0ZSBvbltDSEVDS0JPWF9SQURJT19UT0tFTl07XG4gIH1cbn1cblxudmFyIHRhcmdldCQxO1xuXG5mdW5jdGlvbiBjcmVhdGVPbmNlSGFuZGxlciAoaGFuZGxlciwgZXZlbnQsIGNhcHR1cmUpIHtcbiAgdmFyIF90YXJnZXQgPSB0YXJnZXQkMTsgLy8gc2F2ZSBjdXJyZW50IHRhcmdldCBlbGVtZW50IGluIGNsb3N1cmVcbiAgcmV0dXJuIGZ1bmN0aW9uIG9uY2VIYW5kbGVyICgpIHtcbiAgICB2YXIgcmVzID0gaGFuZGxlci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIGlmIChyZXMgIT09IG51bGwpIHtcbiAgICAgIHJlbW92ZSQyKGV2ZW50LCBvbmNlSGFuZGxlciwgY2FwdHVyZSwgX3RhcmdldCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZCQxIChcbiAgZXZlbnQsXG4gIGhhbmRsZXIsXG4gIG9uY2UkJDEsXG4gIGNhcHR1cmUsXG4gIHBhc3NpdmVcbikge1xuICBoYW5kbGVyID0gd2l0aE1hY3JvVGFzayhoYW5kbGVyKTtcbiAgaWYgKG9uY2UkJDEpIHsgaGFuZGxlciA9IGNyZWF0ZU9uY2VIYW5kbGVyKGhhbmRsZXIsIGV2ZW50LCBjYXB0dXJlKTsgfVxuICB0YXJnZXQkMS5hZGRFdmVudExpc3RlbmVyKFxuICAgIGV2ZW50LFxuICAgIGhhbmRsZXIsXG4gICAgc3VwcG9ydHNQYXNzaXZlXG4gICAgICA/IHsgY2FwdHVyZTogY2FwdHVyZSwgcGFzc2l2ZTogcGFzc2l2ZSB9XG4gICAgICA6IGNhcHR1cmVcbiAgKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlJDIgKFxuICBldmVudCxcbiAgaGFuZGxlcixcbiAgY2FwdHVyZSxcbiAgX3RhcmdldFxuKSB7XG4gIChfdGFyZ2V0IHx8IHRhcmdldCQxKS5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgIGV2ZW50LFxuICAgIGhhbmRsZXIuX3dpdGhUYXNrIHx8IGhhbmRsZXIsXG4gICAgY2FwdHVyZVxuICApO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVET01MaXN0ZW5lcnMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLm9uKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEub24pKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9uID0gdm5vZGUuZGF0YS5vbiB8fCB7fTtcbiAgdmFyIG9sZE9uID0gb2xkVm5vZGUuZGF0YS5vbiB8fCB7fTtcbiAgdGFyZ2V0JDEgPSB2bm9kZS5lbG07XG4gIG5vcm1hbGl6ZUV2ZW50cyhvbik7XG4gIHVwZGF0ZUxpc3RlbmVycyhvbiwgb2xkT24sIGFkZCQxLCByZW1vdmUkMiwgdm5vZGUuY29udGV4dCk7XG4gIHRhcmdldCQxID0gdW5kZWZpbmVkO1xufVxuXG52YXIgZXZlbnRzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURPTUxpc3RlbmVycyxcbiAgdXBkYXRlOiB1cGRhdGVET01MaXN0ZW5lcnNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZURPTVByb3BzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5kb21Qcm9wcykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmRvbVByb3BzKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBrZXksIGN1cjtcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZFByb3BzID0gb2xkVm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgdmFyIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gIGlmIChpc0RlZihwcm9wcy5fX29iX18pKSB7XG4gICAgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzID0gZXh0ZW5kKHt9LCBwcm9wcyk7XG4gIH1cblxuICBmb3IgKGtleSBpbiBvbGRQcm9wcykge1xuICAgIGlmIChpc1VuZGVmKHByb3BzW2tleV0pKSB7XG4gICAgICBlbG1ba2V5XSA9ICcnO1xuICAgIH1cbiAgfVxuICBmb3IgKGtleSBpbiBwcm9wcykge1xuICAgIGN1ciA9IHByb3BzW2tleV07XG4gICAgLy8gaWdub3JlIGNoaWxkcmVuIGlmIHRoZSBub2RlIGhhcyB0ZXh0Q29udGVudCBvciBpbm5lckhUTUwsXG4gICAgLy8gYXMgdGhlc2Ugd2lsbCB0aHJvdyBhd2F5IGV4aXN0aW5nIERPTSBub2RlcyBhbmQgY2F1c2UgcmVtb3ZhbCBlcnJvcnNcbiAgICAvLyBvbiBzdWJzZXF1ZW50IHBhdGNoZXMgKCMzMzYwKVxuICAgIGlmIChrZXkgPT09ICd0ZXh0Q29udGVudCcgfHwga2V5ID09PSAnaW5uZXJIVE1MJykge1xuICAgICAgaWYgKHZub2RlLmNoaWxkcmVuKSB7IHZub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7IH1cbiAgICAgIGlmIChjdXIgPT09IG9sZFByb3BzW2tleV0pIHsgY29udGludWUgfVxuICAgICAgLy8gIzY2MDEgd29yayBhcm91bmQgQ2hyb21lIHZlcnNpb24gPD0gNTUgYnVnIHdoZXJlIHNpbmdsZSB0ZXh0Tm9kZVxuICAgICAgLy8gcmVwbGFjZWQgYnkgaW5uZXJIVE1ML3RleHRDb250ZW50IHJldGFpbnMgaXRzIHBhcmVudE5vZGUgcHJvcGVydHlcbiAgICAgIGlmIChlbG0uY2hpbGROb2Rlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgZWxtLnJlbW92ZUNoaWxkKGVsbS5jaGlsZE5vZGVzWzBdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAndmFsdWUnKSB7XG4gICAgICAvLyBzdG9yZSB2YWx1ZSBhcyBfdmFsdWUgYXMgd2VsbCBzaW5jZVxuICAgICAgLy8gbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZFxuICAgICAgZWxtLl92YWx1ZSA9IGN1cjtcbiAgICAgIC8vIGF2b2lkIHJlc2V0dGluZyBjdXJzb3IgcG9zaXRpb24gd2hlbiB2YWx1ZSBpcyB0aGUgc2FtZVxuICAgICAgdmFyIHN0ckN1ciA9IGlzVW5kZWYoY3VyKSA/ICcnIDogU3RyaW5nKGN1cik7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlVmFsdWUoZWxtLCBzdHJDdXIpKSB7XG4gICAgICAgIGVsbS52YWx1ZSA9IHN0ckN1cjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWxtW2tleV0gPSBjdXI7XG4gICAgfVxuICB9XG59XG5cbi8vIGNoZWNrIHBsYXRmb3Jtcy93ZWIvdXRpbC9hdHRycy5qcyBhY2NlcHRWYWx1ZVxuXG5cbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZVZhbHVlIChlbG0sIGNoZWNrVmFsKSB7XG4gIHJldHVybiAoIWVsbS5jb21wb3NpbmcgJiYgKFxuICAgIGVsbS50YWdOYW1lID09PSAnT1BUSU9OJyB8fFxuICAgIGlzTm90SW5Gb2N1c0FuZERpcnR5KGVsbSwgY2hlY2tWYWwpIHx8XG4gICAgaXNEaXJ0eVdpdGhNb2RpZmllcnMoZWxtLCBjaGVja1ZhbClcbiAgKSlcbn1cblxuZnVuY3Rpb24gaXNOb3RJbkZvY3VzQW5kRGlydHkgKGVsbSwgY2hlY2tWYWwpIHtcbiAgLy8gcmV0dXJuIHRydWUgd2hlbiB0ZXh0Ym94ICgubnVtYmVyIGFuZCAudHJpbSkgbG9zZXMgZm9jdXMgYW5kIGl0cyB2YWx1ZSBpc1xuICAvLyBub3QgZXF1YWwgdG8gdGhlIHVwZGF0ZWQgdmFsdWVcbiAgdmFyIG5vdEluRm9jdXMgPSB0cnVlO1xuICAvLyAjNjE1N1xuICAvLyB3b3JrIGFyb3VuZCBJRSBidWcgd2hlbiBhY2Nlc3NpbmcgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpbiBhbiBpZnJhbWVcbiAgdHJ5IHsgbm90SW5Gb2N1cyA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IGVsbTsgfSBjYXRjaCAoZSkge31cbiAgcmV0dXJuIG5vdEluRm9jdXMgJiYgZWxtLnZhbHVlICE9PSBjaGVja1ZhbFxufVxuXG5mdW5jdGlvbiBpc0RpcnR5V2l0aE1vZGlmaWVycyAoZWxtLCBuZXdWYWwpIHtcbiAgdmFyIHZhbHVlID0gZWxtLnZhbHVlO1xuICB2YXIgbW9kaWZpZXJzID0gZWxtLl92TW9kaWZpZXJzOyAvLyBpbmplY3RlZCBieSB2LW1vZGVsIHJ1bnRpbWVcbiAgaWYgKGlzRGVmKG1vZGlmaWVycykpIHtcbiAgICBpZiAobW9kaWZpZXJzLmxhenkpIHtcbiAgICAgIC8vIGlucHV0cyB3aXRoIGxhenkgc2hvdWxkIG9ubHkgYmUgdXBkYXRlZCB3aGVuIG5vdCBpbiBmb2N1c1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmIChtb2RpZmllcnMubnVtYmVyKSB7XG4gICAgICByZXR1cm4gdG9OdW1iZXIodmFsdWUpICE9PSB0b051bWJlcihuZXdWYWwpXG4gICAgfVxuICAgIGlmIChtb2RpZmllcnMudHJpbSkge1xuICAgICAgcmV0dXJuIHZhbHVlLnRyaW0oKSAhPT0gbmV3VmFsLnRyaW0oKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWUgIT09IG5ld1ZhbFxufVxuXG52YXIgZG9tUHJvcHMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRE9NUHJvcHMsXG4gIHVwZGF0ZTogdXBkYXRlRE9NUHJvcHNcbn1cblxuLyogICovXG5cbnZhciBwYXJzZVN0eWxlVGV4dCA9IGNhY2hlZChmdW5jdGlvbiAoY3NzVGV4dCkge1xuICB2YXIgcmVzID0ge307XG4gIHZhciBsaXN0RGVsaW1pdGVyID0gLzsoPyFbXihdKlxcKSkvZztcbiAgdmFyIHByb3BlcnR5RGVsaW1pdGVyID0gLzooLispLztcbiAgY3NzVGV4dC5zcGxpdChsaXN0RGVsaW1pdGVyKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIHZhciB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyKTtcbiAgICAgIHRtcC5sZW5ndGggPiAxICYmIChyZXNbdG1wWzBdLnRyaW0oKV0gPSB0bXBbMV0udHJpbSgpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzXG59KTtcblxuLy8gbWVyZ2Ugc3RhdGljIGFuZCBkeW5hbWljIHN0eWxlIGRhdGEgb24gdGhlIHNhbWUgdm5vZGVcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlRGF0YSAoZGF0YSkge1xuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcoZGF0YS5zdHlsZSk7XG4gIC8vIHN0YXRpYyBzdHlsZSBpcyBwcmUtcHJvY2Vzc2VkIGludG8gYW4gb2JqZWN0IGR1cmluZyBjb21waWxhdGlvblxuICAvLyBhbmQgaXMgYWx3YXlzIGEgZnJlc2ggb2JqZWN0LCBzbyBpdCdzIHNhZmUgdG8gbWVyZ2UgaW50byBpdFxuICByZXR1cm4gZGF0YS5zdGF0aWNTdHlsZVxuICAgID8gZXh0ZW5kKGRhdGEuc3RhdGljU3R5bGUsIHN0eWxlKVxuICAgIDogc3R5bGVcbn1cblxuLy8gbm9ybWFsaXplIHBvc3NpYmxlIGFycmF5IC8gc3RyaW5nIHZhbHVlcyBpbnRvIE9iamVjdFxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVCaW5kaW5nIChiaW5kaW5nU3R5bGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYmluZGluZ1N0eWxlKSkge1xuICAgIHJldHVybiB0b09iamVjdChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgaWYgKHR5cGVvZiBiaW5kaW5nU3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhcnNlU3R5bGVUZXh0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICByZXR1cm4gYmluZGluZ1N0eWxlXG59XG5cbi8qKlxuICogcGFyZW50IGNvbXBvbmVudCBzdHlsZSBzaG91bGQgYmUgYWZ0ZXIgY2hpbGQnc1xuICogc28gdGhhdCBwYXJlbnQgY29tcG9uZW50J3Mgc3R5bGUgY291bGQgb3ZlcnJpZGUgaXRcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGUgKHZub2RlLCBjaGVja0NoaWxkKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIHN0eWxlRGF0YTtcblxuICBpZiAoY2hlY2tDaGlsZCkge1xuICAgIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKFxuICAgICAgICBjaGlsZE5vZGUgJiYgY2hpbGROb2RlLmRhdGEgJiZcbiAgICAgICAgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShjaGlsZE5vZGUuZGF0YSkpXG4gICAgICApIHtcbiAgICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YSh2bm9kZS5kYXRhKSkpIHtcbiAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICB9XG5cbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUuZGF0YSAmJiAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHBhcmVudE5vZGUuZGF0YSkpKSB7XG4gICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgY3NzVmFyUkUgPSAvXi0tLztcbnZhciBpbXBvcnRhbnRSRSA9IC9cXHMqIWltcG9ydGFudCQvO1xudmFyIHNldFByb3AgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGNzc1ZhclJFLnRlc3QobmFtZSkpIHtcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwpO1xuICB9IGVsc2UgaWYgKGltcG9ydGFudFJFLnRlc3QodmFsKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbC5yZXBsYWNlKGltcG9ydGFudFJFLCAnJyksICdpbXBvcnRhbnQnKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbm9ybWFsaXplZE5hbWUgPSBub3JtYWxpemUobmFtZSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgLy8gU3VwcG9ydCB2YWx1ZXMgYXJyYXkgY3JlYXRlZCBieSBhdXRvcHJlZml4ZXIsIGUuZy5cbiAgICAgIC8vIHtkaXNwbGF5OiBbXCItd2Via2l0LWJveFwiLCBcIi1tcy1mbGV4Ym94XCIsIFwiZmxleFwiXX1cbiAgICAgIC8vIFNldCB0aGVtIG9uZSBieSBvbmUsIGFuZCB0aGUgYnJvd3NlciB3aWxsIG9ubHkgc2V0IHRob3NlIGl0IGNhbiByZWNvZ25pemVcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB2YWwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZWwuc3R5bGVbbm9ybWFsaXplZE5hbWVdID0gdmFsW2ldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWw7XG4gICAgfVxuICB9XG59O1xuXG52YXIgdmVuZG9yTmFtZXMgPSBbJ1dlYmtpdCcsICdNb3onLCAnbXMnXTtcblxudmFyIGVtcHR5U3R5bGU7XG52YXIgbm9ybWFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChwcm9wKSB7XG4gIGVtcHR5U3R5bGUgPSBlbXB0eVN0eWxlIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlO1xuICBwcm9wID0gY2FtZWxpemUocHJvcCk7XG4gIGlmIChwcm9wICE9PSAnZmlsdGVyJyAmJiAocHJvcCBpbiBlbXB0eVN0eWxlKSkge1xuICAgIHJldHVybiBwcm9wXG4gIH1cbiAgdmFyIGNhcE5hbWUgPSBwcm9wLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zbGljZSgxKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZW5kb3JOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBuYW1lID0gdmVuZG9yTmFtZXNbaV0gKyBjYXBOYW1lO1xuICAgIGlmIChuYW1lIGluIGVtcHR5U3R5bGUpIHtcbiAgICAgIHJldHVybiBuYW1lXG4gICAgfVxuICB9XG59KTtcblxuZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcblxuICBpZiAoaXNVbmRlZihkYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKGRhdGEuc3R5bGUpICYmXG4gICAgaXNVbmRlZihvbGREYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKG9sZERhdGEuc3R5bGUpXG4gICkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGN1ciwgbmFtZTtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkU3RhdGljU3R5bGUgPSBvbGREYXRhLnN0YXRpY1N0eWxlO1xuICB2YXIgb2xkU3R5bGVCaW5kaW5nID0gb2xkRGF0YS5ub3JtYWxpemVkU3R5bGUgfHwgb2xkRGF0YS5zdHlsZSB8fCB7fTtcblxuICAvLyBpZiBzdGF0aWMgc3R5bGUgZXhpc3RzLCBzdHlsZWJpbmRpbmcgYWxyZWFkeSBtZXJnZWQgaW50byBpdCB3aGVuIGRvaW5nIG5vcm1hbGl6ZVN0eWxlRGF0YVxuICB2YXIgb2xkU3R5bGUgPSBvbGRTdGF0aWNTdHlsZSB8fCBvbGRTdHlsZUJpbmRpbmc7XG5cbiAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKHZub2RlLmRhdGEuc3R5bGUpIHx8IHt9O1xuXG4gIC8vIHN0b3JlIG5vcm1hbGl6ZWQgc3R5bGUgdW5kZXIgYSBkaWZmZXJlbnQga2V5IGZvciBuZXh0IGRpZmZcbiAgLy8gbWFrZSBzdXJlIHRvIGNsb25lIGl0IGlmIGl0J3MgcmVhY3RpdmUsIHNpbmNlIHRoZSB1c2VyIGxpa2VseSB3YW50c1xuICAvLyB0byBtdXRhdGUgaXQuXG4gIHZub2RlLmRhdGEubm9ybWFsaXplZFN0eWxlID0gaXNEZWYoc3R5bGUuX19vYl9fKVxuICAgID8gZXh0ZW5kKHt9LCBzdHlsZSlcbiAgICA6IHN0eWxlO1xuXG4gIHZhciBuZXdTdHlsZSA9IGdldFN0eWxlKHZub2RlLCB0cnVlKTtcblxuICBmb3IgKG5hbWUgaW4gb2xkU3R5bGUpIHtcbiAgICBpZiAoaXNVbmRlZihuZXdTdHlsZVtuYW1lXSkpIHtcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsICcnKTtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIG5ld1N0eWxlKSB7XG4gICAgY3VyID0gbmV3U3R5bGVbbmFtZV07XG4gICAgaWYgKGN1ciAhPT0gb2xkU3R5bGVbbmFtZV0pIHtcbiAgICAgIC8vIGllOSBzZXR0aW5nIHRvIG51bGwgaGFzIG5vIGVmZmVjdCwgbXVzdCB1c2UgZW1wdHkgc3RyaW5nXG4gICAgICBzZXRQcm9wKGVsLCBuYW1lLCBjdXIgPT0gbnVsbCA/ICcnIDogY3VyKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHN0eWxlID0ge1xuICBjcmVhdGU6IHVwZGF0ZVN0eWxlLFxuICB1cGRhdGU6IHVwZGF0ZVN0eWxlXG59XG5cbi8qICAqL1xuXG4vKipcbiAqIEFkZCBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIGFkZENsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LmFkZChjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICBpZiAoY3VyLmluZGV4T2YoJyAnICsgY2xzICsgJyAnKSA8IDApIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoY3VyICsgY2xzKS50cmltKCkpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LnJlbW92ZShjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xzKTtcbiAgICB9XG4gICAgaWYgKCFlbC5jbGFzc0xpc3QubGVuZ3RoKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgdmFyIHRhciA9ICcgJyArIGNscyArICcgJztcbiAgICB3aGlsZSAoY3VyLmluZGV4T2YodGFyKSA+PSAwKSB7XG4gICAgICBjdXIgPSBjdXIucmVwbGFjZSh0YXIsICcgJyk7XG4gICAgfVxuICAgIGN1ciA9IGN1ci50cmltKCk7XG4gICAgaWYgKGN1cikge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGN1cik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uIChkZWYpIHtcbiAgaWYgKCFkZWYpIHtcbiAgICByZXR1cm5cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodHlwZW9mIGRlZiA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgcmVzID0ge307XG4gICAgaWYgKGRlZi5jc3MgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbmQocmVzLCBhdXRvQ3NzVHJhbnNpdGlvbihkZWYubmFtZSB8fCAndicpKTtcbiAgICB9XG4gICAgZXh0ZW5kKHJlcywgZGVmKTtcbiAgICByZXR1cm4gcmVzXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gYXV0b0Nzc1RyYW5zaXRpb24oZGVmKVxuICB9XG59XG5cbnZhciBhdXRvQ3NzVHJhbnNpdGlvbiA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4ge1xuICAgIGVudGVyQ2xhc3M6IChuYW1lICsgXCItZW50ZXJcIiksXG4gICAgZW50ZXJUb0NsYXNzOiAobmFtZSArIFwiLWVudGVyLXRvXCIpLFxuICAgIGVudGVyQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItZW50ZXItYWN0aXZlXCIpLFxuICAgIGxlYXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmVcIiksXG4gICAgbGVhdmVUb0NsYXNzOiAobmFtZSArIFwiLWxlYXZlLXRvXCIpLFxuICAgIGxlYXZlQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtYWN0aXZlXCIpXG4gIH1cbn0pO1xuXG52YXIgaGFzVHJhbnNpdGlvbiA9IGluQnJvd3NlciAmJiAhaXNJRTk7XG52YXIgVFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcbnZhciBBTklNQVRJT04gPSAnYW5pbWF0aW9uJztcblxuLy8gVHJhbnNpdGlvbiBwcm9wZXJ0eS9ldmVudCBzbmlmZmluZ1xudmFyIHRyYW5zaXRpb25Qcm9wID0gJ3RyYW5zaXRpb24nO1xudmFyIHRyYW5zaXRpb25FbmRFdmVudCA9ICd0cmFuc2l0aW9uZW5kJztcbnZhciBhbmltYXRpb25Qcm9wID0gJ2FuaW1hdGlvbic7XG52YXIgYW5pbWF0aW9uRW5kRXZlbnQgPSAnYW5pbWF0aW9uZW5kJztcbmlmIChoYXNUcmFuc2l0aW9uKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAod2luZG93Lm9udHJhbnNpdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0dHJhbnNpdGlvbmVuZCAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHRyYW5zaXRpb25Qcm9wID0gJ1dlYmtpdFRyYW5zaXRpb24nO1xuICAgIHRyYW5zaXRpb25FbmRFdmVudCA9ICd3ZWJraXRUcmFuc2l0aW9uRW5kJztcbiAgfVxuICBpZiAod2luZG93Lm9uYW5pbWF0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICB3aW5kb3cub253ZWJraXRhbmltYXRpb25lbmQgIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICBhbmltYXRpb25Qcm9wID0gJ1dlYmtpdEFuaW1hdGlvbic7XG4gICAgYW5pbWF0aW9uRW5kRXZlbnQgPSAnd2Via2l0QW5pbWF0aW9uRW5kJztcbiAgfVxufVxuXG4vLyBiaW5kaW5nIHRvIHdpbmRvdyBpcyBuZWNlc3NhcnkgdG8gbWFrZSBob3QgcmVsb2FkIHdvcmsgaW4gSUUgaW4gc3RyaWN0IG1vZGVcbnZhciByYWYgPSBpbkJyb3dzZXJcbiAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KVxuICAgIDogc2V0VGltZW91dFxuICA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfTtcblxuZnVuY3Rpb24gbmV4dEZyYW1lIChmbikge1xuICByYWYoZnVuY3Rpb24gKCkge1xuICAgIHJhZihmbik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgdmFyIHRyYW5zaXRpb25DbGFzc2VzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzIHx8IChlbC5fdHJhbnNpdGlvbkNsYXNzZXMgPSBbXSk7XG4gIGlmICh0cmFuc2l0aW9uQ2xhc3Nlcy5pbmRleE9mKGNscykgPCAwKSB7XG4gICAgdHJhbnNpdGlvbkNsYXNzZXMucHVzaChjbHMpO1xuICAgIGFkZENsYXNzKGVsLCBjbHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgcmVtb3ZlKGVsLl90cmFuc2l0aW9uQ2xhc3NlcywgY2xzKTtcbiAgfVxuICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcbn1cblxuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25FbmRzIChcbiAgZWwsXG4gIGV4cGVjdGVkVHlwZSxcbiAgY2Jcbikge1xuICB2YXIgcmVmID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XG4gIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gIHZhciB0aW1lb3V0ID0gcmVmLnRpbWVvdXQ7XG4gIHZhciBwcm9wQ291bnQgPSByZWYucHJvcENvdW50O1xuICBpZiAoIXR5cGUpIHsgcmV0dXJuIGNiKCkgfVxuICB2YXIgZXZlbnQgPSB0eXBlID09PSBUUkFOU0lUSU9OID8gdHJhbnNpdGlvbkVuZEV2ZW50IDogYW5pbWF0aW9uRW5kRXZlbnQ7XG4gIHZhciBlbmRlZCA9IDA7XG4gIHZhciBlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xuICAgIGNiKCk7XG4gIH07XG4gIHZhciBvbkVuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSBlbCkge1xuICAgICAgaWYgKCsrZW5kZWQgPj0gcHJvcENvdW50KSB7XG4gICAgICAgIGVuZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVuZGVkIDwgcHJvcENvdW50KSB7XG4gICAgICBlbmQoKTtcbiAgICB9XG4gIH0sIHRpbWVvdXQgKyAxKTtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xufVxuXG52YXIgdHJhbnNmb3JtUkUgPSAvXFxiKHRyYW5zZm9ybXxhbGwpKCx8JCkvO1xuXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyAoZWwsIGV4cGVjdGVkVHlwZSkge1xuICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICB2YXIgdHJhbnNpdGlvbkRlbGF5cyA9IHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEZWxheSddLnNwbGl0KCcsICcpO1xuICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9ucyA9IHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEdXJhdGlvbiddLnNwbGl0KCcsICcpO1xuICB2YXIgdHJhbnNpdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KHRyYW5zaXRpb25EZWxheXMsIHRyYW5zaXRpb25EdXJhdGlvbnMpO1xuICB2YXIgYW5pbWF0aW9uRGVsYXlzID0gc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRGVsYXknXS5zcGxpdCgnLCAnKTtcbiAgdmFyIGFuaW1hdGlvbkR1cmF0aW9ucyA9IHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10uc3BsaXQoJywgJyk7XG4gIHZhciBhbmltYXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dChhbmltYXRpb25EZWxheXMsIGFuaW1hdGlvbkR1cmF0aW9ucyk7XG5cbiAgdmFyIHR5cGU7XG4gIHZhciB0aW1lb3V0ID0gMDtcbiAgdmFyIHByb3BDb3VudCA9IDA7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZXhwZWN0ZWRUeXBlID09PSBUUkFOU0lUSU9OKSB7XG4gICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IFRSQU5TSVRJT047XG4gICAgICB0aW1lb3V0ID0gdHJhbnNpdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBBTklNQVRJT04pIHtcbiAgICBpZiAoYW5pbWF0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBBTklNQVRJT047XG4gICAgICB0aW1lb3V0ID0gYW5pbWF0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRpbWVvdXQgPSBNYXRoLm1heCh0cmFuc2l0aW9uVGltZW91dCwgYW5pbWF0aW9uVGltZW91dCk7XG4gICAgdHlwZSA9IHRpbWVvdXQgPiAwXG4gICAgICA/IHRyYW5zaXRpb25UaW1lb3V0ID4gYW5pbWF0aW9uVGltZW91dFxuICAgICAgICA/IFRSQU5TSVRJT05cbiAgICAgICAgOiBBTklNQVRJT05cbiAgICAgIDogbnVsbDtcbiAgICBwcm9wQ291bnQgPSB0eXBlXG4gICAgICA/IHR5cGUgPT09IFRSQU5TSVRJT05cbiAgICAgICAgPyB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgICA6IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgIDogMDtcbiAgfVxuICB2YXIgaGFzVHJhbnNmb3JtID1cbiAgICB0eXBlID09PSBUUkFOU0lUSU9OICYmXG4gICAgdHJhbnNmb3JtUkUudGVzdChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnUHJvcGVydHknXSk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogdHlwZSxcbiAgICB0aW1lb3V0OiB0aW1lb3V0LFxuICAgIHByb3BDb3VudDogcHJvcENvdW50LFxuICAgIGhhc1RyYW5zZm9ybTogaGFzVHJhbnNmb3JtXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VGltZW91dCAoZGVsYXlzLCBkdXJhdGlvbnMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgd2hpbGUgKGRlbGF5cy5sZW5ndGggPCBkdXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgZGVsYXlzID0gZGVsYXlzLmNvbmNhdChkZWxheXMpO1xuICB9XG5cbiAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KG51bGwsIGR1cmF0aW9ucy5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICByZXR1cm4gdG9NcyhkKSArIHRvTXMoZGVsYXlzW2ldKVxuICB9KSlcbn1cblxuZnVuY3Rpb24gdG9NcyAocykge1xuICByZXR1cm4gTnVtYmVyKHMuc2xpY2UoMCwgLTEpKSAqIDEwMDBcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVudGVyICh2bm9kZSwgdG9nZ2xlRGlzcGxheSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cbiAgLy8gY2FsbCBsZWF2ZSBjYWxsYmFjayBub3dcbiAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSkge1xuICAgIGVsLl9sZWF2ZUNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgZWwuX2xlYXZlQ2IoKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgaWYgKGlzVW5kZWYoZGF0YSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgZW50ZXJDbGFzcyA9IGRhdGEuZW50ZXJDbGFzcztcbiAgdmFyIGVudGVyVG9DbGFzcyA9IGRhdGEuZW50ZXJUb0NsYXNzO1xuICB2YXIgZW50ZXJBY3RpdmVDbGFzcyA9IGRhdGEuZW50ZXJBY3RpdmVDbGFzcztcbiAgdmFyIGFwcGVhckNsYXNzID0gZGF0YS5hcHBlYXJDbGFzcztcbiAgdmFyIGFwcGVhclRvQ2xhc3MgPSBkYXRhLmFwcGVhclRvQ2xhc3M7XG4gIHZhciBhcHBlYXJBY3RpdmVDbGFzcyA9IGRhdGEuYXBwZWFyQWN0aXZlQ2xhc3M7XG4gIHZhciBiZWZvcmVFbnRlciA9IGRhdGEuYmVmb3JlRW50ZXI7XG4gIHZhciBlbnRlciA9IGRhdGEuZW50ZXI7XG4gIHZhciBhZnRlckVudGVyID0gZGF0YS5hZnRlckVudGVyO1xuICB2YXIgZW50ZXJDYW5jZWxsZWQgPSBkYXRhLmVudGVyQ2FuY2VsbGVkO1xuICB2YXIgYmVmb3JlQXBwZWFyID0gZGF0YS5iZWZvcmVBcHBlYXI7XG4gIHZhciBhcHBlYXIgPSBkYXRhLmFwcGVhcjtcbiAgdmFyIGFmdGVyQXBwZWFyID0gZGF0YS5hZnRlckFwcGVhcjtcbiAgdmFyIGFwcGVhckNhbmNlbGxlZCA9IGRhdGEuYXBwZWFyQ2FuY2VsbGVkO1xuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gIC8vIGFjdGl2ZUluc3RhbmNlIHdpbGwgYWx3YXlzIGJlIHRoZSA8dHJhbnNpdGlvbj4gY29tcG9uZW50IG1hbmFnaW5nIHRoaXNcbiAgLy8gdHJhbnNpdGlvbi4gT25lIGVkZ2UgY2FzZSB0byBjaGVjayBpcyB3aGVuIHRoZSA8dHJhbnNpdGlvbj4gaXMgcGxhY2VkXG4gIC8vIGFzIHRoZSByb290IG5vZGUgb2YgYSBjaGlsZCBjb21wb25lbnQuIEluIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIGNoZWNrXG4gIC8vIDx0cmFuc2l0aW9uPidzIHBhcmVudCBmb3IgYXBwZWFyIGNoZWNrLlxuICB2YXIgY29udGV4dCA9IGFjdGl2ZUluc3RhbmNlO1xuICB2YXIgdHJhbnNpdGlvbk5vZGUgPSBhY3RpdmVJbnN0YW5jZS4kdm5vZGU7XG4gIHdoaWxlICh0cmFuc2l0aW9uTm9kZSAmJiB0cmFuc2l0aW9uTm9kZS5wYXJlbnQpIHtcbiAgICB0cmFuc2l0aW9uTm9kZSA9IHRyYW5zaXRpb25Ob2RlLnBhcmVudDtcbiAgICBjb250ZXh0ID0gdHJhbnNpdGlvbk5vZGUuY29udGV4dDtcbiAgfVxuXG4gIHZhciBpc0FwcGVhciA9ICFjb250ZXh0Ll9pc01vdW50ZWQgfHwgIXZub2RlLmlzUm9vdEluc2VydDtcblxuICBpZiAoaXNBcHBlYXIgJiYgIWFwcGVhciAmJiBhcHBlYXIgIT09ICcnKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgc3RhcnRDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckNsYXNzXG4gICAgPyBhcHBlYXJDbGFzc1xuICAgIDogZW50ZXJDbGFzcztcbiAgdmFyIGFjdGl2ZUNsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA/IGFwcGVhckFjdGl2ZUNsYXNzXG4gICAgOiBlbnRlckFjdGl2ZUNsYXNzO1xuICB2YXIgdG9DbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhclRvQ2xhc3NcbiAgICA/IGFwcGVhclRvQ2xhc3NcbiAgICA6IGVudGVyVG9DbGFzcztcblxuICB2YXIgYmVmb3JlRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChiZWZvcmVBcHBlYXIgfHwgYmVmb3JlRW50ZXIpXG4gICAgOiBiZWZvcmVFbnRlcjtcbiAgdmFyIGVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAodHlwZW9mIGFwcGVhciA9PT0gJ2Z1bmN0aW9uJyA/IGFwcGVhciA6IGVudGVyKVxuICAgIDogZW50ZXI7XG4gIHZhciBhZnRlckVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYWZ0ZXJBcHBlYXIgfHwgYWZ0ZXJFbnRlcilcbiAgICA6IGFmdGVyRW50ZXI7XG4gIHZhciBlbnRlckNhbmNlbGxlZEhvb2sgPSBpc0FwcGVhclxuICAgID8gKGFwcGVhckNhbmNlbGxlZCB8fCBlbnRlckNhbmNlbGxlZClcbiAgICA6IGVudGVyQ2FuY2VsbGVkO1xuXG4gIHZhciBleHBsaWNpdEVudGVyRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgID8gZHVyYXRpb24uZW50ZXJcbiAgICAgIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgZXhwbGljaXRFbnRlckR1cmF0aW9uICE9IG51bGwpIHtcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbiwgJ2VudGVyJywgdm5vZGUpO1xuICB9XG5cbiAgdmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcbiAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGVudGVySG9vayk7XG5cbiAgdmFyIGNiID0gZWwuX2VudGVyQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIH1cbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgfVxuICAgICAgZW50ZXJDYW5jZWxsZWRIb29rICYmIGVudGVyQ2FuY2VsbGVkSG9vayhlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyRW50ZXJIb29rICYmIGFmdGVyRW50ZXJIb29rKGVsKTtcbiAgICB9XG4gICAgZWwuX2VudGVyQ2IgPSBudWxsO1xuICB9KTtcblxuICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgIC8vIHJlbW92ZSBwZW5kaW5nIGxlYXZlIGVsZW1lbnQgb24gZW50ZXIgYnkgaW5qZWN0aW5nIGFuIGluc2VydCBob29rXG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdpbnNlcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcbiAgICAgIHZhciBwZW5kaW5nTm9kZSA9IHBhcmVudCAmJiBwYXJlbnQuX3BlbmRpbmcgJiYgcGFyZW50Ll9wZW5kaW5nW3Zub2RlLmtleV07XG4gICAgICBpZiAocGVuZGluZ05vZGUgJiZcbiAgICAgICAgcGVuZGluZ05vZGUudGFnID09PSB2bm9kZS50YWcgJiZcbiAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiXG4gICAgICApIHtcbiAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiKCk7XG4gICAgICB9XG4gICAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gICAgfSk7XG4gIH1cblxuICAvLyBzdGFydCBlbnRlciB0cmFuc2l0aW9uXG4gIGJlZm9yZUVudGVySG9vayAmJiBiZWZvcmVFbnRlckhvb2soZWwpO1xuICBpZiAoZXhwZWN0c0NTUykge1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICBpZiAoIWNiLmNhbmNlbGxlZCkge1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgICBpZiAoIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbikpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0RW50ZXJEdXJhdGlvbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHZub2RlLmRhdGEuc2hvdykge1xuICAgIHRvZ2dsZURpc3BsYXkgJiYgdG9nZ2xlRGlzcGxheSgpO1xuICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgfVxuXG4gIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgIGNiKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGVhdmUgKHZub2RlLCBybSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cbiAgLy8gY2FsbCBlbnRlciBjYWxsYmFjayBub3dcbiAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSkge1xuICAgIGVsLl9lbnRlckNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgZWwuX2VudGVyQ2IoKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgaWYgKGlzVW5kZWYoZGF0YSkgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm4gcm0oKVxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihlbC5fbGVhdmVDYikpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjc3MgPSBkYXRhLmNzcztcbiAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XG4gIHZhciBsZWF2ZUNsYXNzID0gZGF0YS5sZWF2ZUNsYXNzO1xuICB2YXIgbGVhdmVUb0NsYXNzID0gZGF0YS5sZWF2ZVRvQ2xhc3M7XG4gIHZhciBsZWF2ZUFjdGl2ZUNsYXNzID0gZGF0YS5sZWF2ZUFjdGl2ZUNsYXNzO1xuICB2YXIgYmVmb3JlTGVhdmUgPSBkYXRhLmJlZm9yZUxlYXZlO1xuICB2YXIgbGVhdmUgPSBkYXRhLmxlYXZlO1xuICB2YXIgYWZ0ZXJMZWF2ZSA9IGRhdGEuYWZ0ZXJMZWF2ZTtcbiAgdmFyIGxlYXZlQ2FuY2VsbGVkID0gZGF0YS5sZWF2ZUNhbmNlbGxlZDtcbiAgdmFyIGRlbGF5TGVhdmUgPSBkYXRhLmRlbGF5TGVhdmU7XG4gIHZhciBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG5cbiAgdmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcbiAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGxlYXZlKTtcblxuICB2YXIgZXhwbGljaXRMZWF2ZUR1cmF0aW9uID0gdG9OdW1iZXIoXG4gICAgaXNPYmplY3QoZHVyYXRpb24pXG4gICAgICA/IGR1cmF0aW9uLmxlYXZlXG4gICAgICA6IGR1cmF0aW9uXG4gICk7XG5cbiAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzRGVmKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbiwgJ2xlYXZlJywgdm5vZGUpO1xuICB9XG5cbiAgdmFyIGNiID0gZWwuX2xlYXZlQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZWwucGFyZW50Tm9kZSAmJiBlbC5wYXJlbnROb2RlLl9wZW5kaW5nKSB7XG4gICAgICBlbC5wYXJlbnROb2RlLl9wZW5kaW5nW3Zub2RlLmtleV0gPSBudWxsO1xuICAgIH1cbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIH1cbiAgICAgIGxlYXZlQ2FuY2VsbGVkICYmIGxlYXZlQ2FuY2VsbGVkKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZShlbCk7XG4gICAgfVxuICAgIGVsLl9sZWF2ZUNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKGRlbGF5TGVhdmUpIHtcbiAgICBkZWxheUxlYXZlKHBlcmZvcm1MZWF2ZSk7XG4gIH0gZWxzZSB7XG4gICAgcGVyZm9ybUxlYXZlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtTGVhdmUgKCkge1xuICAgIC8vIHRoZSBkZWxheWVkIGxlYXZlIG1heSBoYXZlIGFscmVhZHkgYmVlbiBjYW5jZWxsZWRcbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gcmVjb3JkIGxlYXZpbmcgZWxlbWVudFxuICAgIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgICAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyB8fCAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyA9IHt9KSlbKHZub2RlLmtleSldID0gdm5vZGU7XG4gICAgfVxuICAgIGJlZm9yZUxlYXZlICYmIGJlZm9yZUxlYXZlKGVsKTtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgICBpZiAoIWNiLmNhbmNlbGxlZCkge1xuICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgICAgICBpZiAoIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uKSkge1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdExlYXZlRHVyYXRpb24pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgbGVhdmUgJiYgbGVhdmUoZWwsIGNiKTtcbiAgICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgIGNiKCk7XG4gICAgfVxuICB9XG59XG5cbi8vIG9ubHkgdXNlZCBpbiBkZXYgbW9kZVxuZnVuY3Rpb24gY2hlY2tEdXJhdGlvbiAodmFsLCBuYW1lLCB2bm9kZSkge1xuICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcbiAgICB3YXJuKFxuICAgICAgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgbm90IGEgdmFsaWQgbnVtYmVyIC0gXCIgK1xuICAgICAgXCJnb3QgXCIgKyAoSlNPTi5zdHJpbmdpZnkodmFsKSkgKyBcIi5cIixcbiAgICAgIHZub2RlLmNvbnRleHRcbiAgICApO1xuICB9IGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcbiAgICB3YXJuKFxuICAgICAgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgTmFOIC0gXCIgK1xuICAgICAgJ3RoZSBkdXJhdGlvbiBleHByZXNzaW9uIG1pZ2h0IGJlIGluY29ycmVjdC4nLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNWYWxpZER1cmF0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmICFpc05hTih2YWwpXG59XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdHJhbnNpdGlvbiBob29rJ3MgYXJndW1lbnQgbGVuZ3RoLiBUaGUgaG9vayBtYXkgYmU6XG4gKiAtIGEgbWVyZ2VkIGhvb2sgKGludm9rZXIpIHdpdGggdGhlIG9yaWdpbmFsIGluIC5mbnNcbiAqIC0gYSB3cmFwcGVkIGNvbXBvbmVudCBtZXRob2QgKGNoZWNrIC5fbGVuZ3RoKVxuICogLSBhIHBsYWluIGZ1bmN0aW9uICgubGVuZ3RoKVxuICovXG5mdW5jdGlvbiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoIChmbikge1xuICBpZiAoaXNVbmRlZihmbikpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB2YXIgaW52b2tlckZucyA9IGZuLmZucztcbiAgaWYgKGlzRGVmKGludm9rZXJGbnMpKSB7XG4gICAgLy8gaW52b2tlclxuICAgIHJldHVybiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKFxuICAgICAgQXJyYXkuaXNBcnJheShpbnZva2VyRm5zKVxuICAgICAgICA/IGludm9rZXJGbnNbMF1cbiAgICAgICAgOiBpbnZva2VyRm5zXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoZm4uX2xlbmd0aCB8fCBmbi5sZW5ndGgpID4gMVxuICB9XG59XG5cbmZ1bmN0aW9uIF9lbnRlciAoXywgdm5vZGUpIHtcbiAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgIGVudGVyKHZub2RlKTtcbiAgfVxufVxuXG52YXIgdHJhbnNpdGlvbiA9IGluQnJvd3NlciA/IHtcbiAgY3JlYXRlOiBfZW50ZXIsXG4gIGFjdGl2YXRlOiBfZW50ZXIsXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlJCQxICh2bm9kZSwgcm0pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICh2bm9kZS5kYXRhLnNob3cgIT09IHRydWUpIHtcbiAgICAgIGxlYXZlKHZub2RlLCBybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgfVxuICB9XG59IDoge31cblxudmFyIHBsYXRmb3JtTW9kdWxlcyA9IFtcbiAgYXR0cnMsXG4gIGtsYXNzLFxuICBldmVudHMsXG4gIGRvbVByb3BzLFxuICBzdHlsZSxcbiAgdHJhbnNpdGlvblxuXVxuXG4vKiAgKi9cblxuLy8gdGhlIGRpcmVjdGl2ZSBtb2R1bGUgc2hvdWxkIGJlIGFwcGxpZWQgbGFzdCwgYWZ0ZXIgYWxsXG4vLyBidWlsdC1pbiBtb2R1bGVzIGhhdmUgYmVlbiBhcHBsaWVkLlxudmFyIG1vZHVsZXMgPSBwbGF0Zm9ybU1vZHVsZXMuY29uY2F0KGJhc2VNb2R1bGVzKTtcblxudmFyIHBhdGNoID0gY3JlYXRlUGF0Y2hGdW5jdGlvbih7IG5vZGVPcHM6IG5vZGVPcHMsIG1vZHVsZXM6IG1vZHVsZXMgfSk7XG5cbi8qKlxuICogTm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IGxpa2UgYXR0YWNoaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIEVsZW1lbnRzLlxuICovXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKGlzSUU5KSB7XG4gIC8vIGh0dHA6Ly93d3cubWF0dHM0MTEuY29tL3Bvc3QvaW50ZXJuZXQtZXhwbG9yZXItOS1vbmlucHV0L1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3Rpb25jaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICBpZiAoZWwgJiYgZWwudm1vZGVsKSB7XG4gICAgICB0cmlnZ2VyKGVsLCAnaW5wdXQnKTtcbiAgICB9XG4gIH0pO1xufVxuXG52YXIgZGlyZWN0aXZlID0ge1xuICBpbnNlcnRlZDogZnVuY3Rpb24gaW5zZXJ0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSwgb2xkVm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgLy8gIzY5MDNcbiAgICAgIGlmIChvbGRWbm9kZS5lbG0gJiYgIW9sZFZub2RlLmVsbS5fdk9wdGlvbnMpIHtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdwb3N0cGF0Y2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZGlyZWN0aXZlLmNvbXBvbmVudFVwZGF0ZWQoZWwsIGJpbmRpbmcsIHZub2RlKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICB9XG4gICAgICBlbC5fdk9wdGlvbnMgPSBbXS5tYXAuY2FsbChlbC5vcHRpb25zLCBnZXRWYWx1ZSk7XG4gICAgfSBlbHNlIGlmICh2bm9kZS50YWcgPT09ICd0ZXh0YXJlYScgfHwgaXNUZXh0SW5wdXRUeXBlKGVsLnR5cGUpKSB7XG4gICAgICBlbC5fdk1vZGlmaWVycyA9IGJpbmRpbmcubW9kaWZpZXJzO1xuICAgICAgaWYgKCFiaW5kaW5nLm1vZGlmaWVycy5sYXp5KSB7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uc3RhcnQnLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbmVuZCcsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICAvLyBTYWZhcmkgPCAxMC4yICYgVUlXZWJWaWV3IGRvZXNuJ3QgZmlyZSBjb21wb3NpdGlvbmVuZCB3aGVuXG4gICAgICAgIC8vIHN3aXRjaGluZyBmb2N1cyBiZWZvcmUgY29uZmlybWluZyBjb21wb3NpdGlvbiBjaG9pY2VcbiAgICAgICAgLy8gdGhpcyBhbHNvIGZpeGVzIHRoZSBpc3N1ZSB3aGVyZSBzb21lIGJyb3dzZXJzIGUuZy4gaU9TIENocm9tZVxuICAgICAgICAvLyBmaXJlcyBcImNoYW5nZVwiIGluc3RlYWQgb2YgXCJpbnB1dFwiIG9uIGF1dG9jb21wbGV0ZS5cbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoaXNJRTkpIHtcbiAgICAgICAgICBlbC52bW9kZWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGNvbXBvbmVudFVwZGF0ZWQ6IGZ1bmN0aW9uIGNvbXBvbmVudFVwZGF0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICAvLyBpbiBjYXNlIHRoZSBvcHRpb25zIHJlbmRlcmVkIGJ5IHYtZm9yIGhhdmUgY2hhbmdlZCxcbiAgICAgIC8vIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgdmFsdWUgaXMgb3V0LW9mLXN5bmMgd2l0aCB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cbiAgICAgIC8vIGRldGVjdCBzdWNoIGNhc2VzIGFuZCBmaWx0ZXIgb3V0IHZhbHVlcyB0aGF0IG5vIGxvbmdlciBoYXMgYSBtYXRjaGluZ1xuICAgICAgLy8gb3B0aW9uIGluIHRoZSBET00uXG4gICAgICB2YXIgcHJldk9wdGlvbnMgPSBlbC5fdk9wdGlvbnM7XG4gICAgICB2YXIgY3VyT3B0aW9ucyA9IGVsLl92T3B0aW9ucyA9IFtdLm1hcC5jYWxsKGVsLm9wdGlvbnMsIGdldFZhbHVlKTtcbiAgICAgIGlmIChjdXJPcHRpb25zLnNvbWUoZnVuY3Rpb24gKG8sIGkpIHsgcmV0dXJuICFsb29zZUVxdWFsKG8sIHByZXZPcHRpb25zW2ldKTsgfSkpIHtcbiAgICAgICAgLy8gdHJpZ2dlciBjaGFuZ2UgZXZlbnQgaWZcbiAgICAgICAgLy8gbm8gbWF0Y2hpbmcgb3B0aW9uIGZvdW5kIGZvciBhdCBsZWFzdCBvbmUgdmFsdWVcbiAgICAgICAgdmFyIG5lZWRSZXNldCA9IGVsLm11bHRpcGxlXG4gICAgICAgICAgPyBiaW5kaW5nLnZhbHVlLnNvbWUoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGhhc05vTWF0Y2hpbmdPcHRpb24odiwgY3VyT3B0aW9ucyk7IH0pXG4gICAgICAgICAgOiBiaW5kaW5nLnZhbHVlICE9PSBiaW5kaW5nLm9sZFZhbHVlICYmIGhhc05vTWF0Y2hpbmdPcHRpb24oYmluZGluZy52YWx1ZSwgY3VyT3B0aW9ucyk7XG4gICAgICAgIGlmIChuZWVkUmVzZXQpIHtcbiAgICAgICAgICB0cmlnZ2VyKGVsLCAnY2hhbmdlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNldFNlbGVjdGVkIChlbCwgYmluZGluZywgdm0pIHtcbiAgYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzSUUgfHwgaXNFZGdlKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBhY3R1YWxseVNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bSk7XG4gICAgfSwgMCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWN0dWFsbHlTZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gIHZhciB2YWx1ZSA9IGJpbmRpbmcudmFsdWU7XG4gIHZhciBpc011bHRpcGxlID0gZWwubXVsdGlwbGU7XG4gIGlmIChpc011bHRpcGxlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIjxzZWxlY3QgbXVsdGlwbGUgdi1tb2RlbD1cXFwiXCIgKyAoYmluZGluZy5leHByZXNzaW9uKSArIFwiXFxcIj4gXCIgK1xuICAgICAgXCJleHBlY3RzIGFuIEFycmF5IHZhbHVlIGZvciBpdHMgYmluZGluZywgYnV0IGdvdCBcIiArIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKSksXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHNlbGVjdGVkLCBvcHRpb247XG4gIGZvciAodmFyIGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvcHRpb24gPSBlbC5vcHRpb25zW2ldO1xuICAgIGlmIChpc011bHRpcGxlKSB7XG4gICAgICBzZWxlY3RlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgZ2V0VmFsdWUob3B0aW9uKSkgPiAtMTtcbiAgICAgIGlmIChvcHRpb24uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobG9vc2VFcXVhbChnZXRWYWx1ZShvcHRpb24pLCB2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGVsLnNlbGVjdGVkSW5kZXggIT09IGkpIHtcbiAgICAgICAgICBlbC5zZWxlY3RlZEluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFpc011bHRpcGxlKSB7XG4gICAgZWwuc2VsZWN0ZWRJbmRleCA9IC0xO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhc05vTWF0Y2hpbmdPcHRpb24gKHZhbHVlLCBvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLmV2ZXJ5KGZ1bmN0aW9uIChvKSB7IHJldHVybiAhbG9vc2VFcXVhbChvLCB2YWx1ZSk7IH0pXG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlIChvcHRpb24pIHtcbiAgcmV0dXJuICdfdmFsdWUnIGluIG9wdGlvblxuICAgID8gb3B0aW9uLl92YWx1ZVxuICAgIDogb3B0aW9uLnZhbHVlXG59XG5cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25TdGFydCAoZSkge1xuICBlLnRhcmdldC5jb21wb3NpbmcgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uRW5kIChlKSB7XG4gIC8vIHByZXZlbnQgdHJpZ2dlcmluZyBhbiBpbnB1dCBldmVudCBmb3Igbm8gcmVhc29uXG4gIGlmICghZS50YXJnZXQuY29tcG9zaW5nKSB7IHJldHVybiB9XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IGZhbHNlO1xuICB0cmlnZ2VyKGUudGFyZ2V0LCAnaW5wdXQnKTtcbn1cblxuZnVuY3Rpb24gdHJpZ2dlciAoZWwsIHR5cGUpIHtcbiAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpO1xuICBlLmluaXRFdmVudCh0eXBlLCB0cnVlLCB0cnVlKTtcbiAgZWwuZGlzcGF0Y2hFdmVudChlKTtcbn1cblxuLyogICovXG5cbi8vIHJlY3Vyc2l2ZWx5IHNlYXJjaCBmb3IgcG9zc2libGUgdHJhbnNpdGlvbiBkZWZpbmVkIGluc2lkZSB0aGUgY29tcG9uZW50IHJvb3RcbmZ1bmN0aW9uIGxvY2F0ZU5vZGUgKHZub2RlKSB7XG4gIHJldHVybiB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJiAoIXZub2RlLmRhdGEgfHwgIXZub2RlLmRhdGEudHJhbnNpdGlvbilcbiAgICA/IGxvY2F0ZU5vZGUodm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlKVxuICAgIDogdm5vZGVcbn1cblxudmFyIHNob3cgPSB7XG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQgKGVsLCByZWYsIHZub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuXG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICB2YXIgdHJhbnNpdGlvbiQkMSA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuICAgIHZhciBvcmlnaW5hbERpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgPVxuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnID8gJycgOiBlbC5zdHlsZS5kaXNwbGF5O1xuICAgIGlmICh2YWx1ZSAmJiB0cmFuc2l0aW9uJCQxKSB7XG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IG9yaWdpbmFsRGlzcGxheTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBvcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChlbCwgcmVmLCB2bm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcbiAgICB2YXIgb2xkVmFsdWUgPSByZWYub2xkVmFsdWU7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIXZhbHVlID09PSAhb2xkVmFsdWUpIHsgcmV0dXJuIH1cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uJCQxID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgaWYgKHRyYW5zaXRpb24kJDEpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlYXZlKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQgKFxuICAgIGVsLFxuICAgIGJpbmRpbmcsXG4gICAgdm5vZGUsXG4gICAgb2xkVm5vZGUsXG4gICAgaXNEZXN0cm95XG4gICkge1xuICAgIGlmICghaXNEZXN0cm95KSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgIH1cbiAgfVxufVxuXG52YXIgcGxhdGZvcm1EaXJlY3RpdmVzID0ge1xuICBtb2RlbDogZGlyZWN0aXZlLFxuICBzaG93OiBzaG93XG59XG5cbi8qICAqL1xuXG4vLyBQcm92aWRlcyB0cmFuc2l0aW9uIHN1cHBvcnQgZm9yIGEgc2luZ2xlIGVsZW1lbnQvY29tcG9uZW50LlxuLy8gc3VwcG9ydHMgdHJhbnNpdGlvbiBtb2RlIChvdXQtaW4gLyBpbi1vdXQpXG5cbnZhciB0cmFuc2l0aW9uUHJvcHMgPSB7XG4gIG5hbWU6IFN0cmluZyxcbiAgYXBwZWFyOiBCb29sZWFuLFxuICBjc3M6IEJvb2xlYW4sXG4gIG1vZGU6IFN0cmluZyxcbiAgdHlwZTogU3RyaW5nLFxuICBlbnRlckNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJUb0NsYXNzOiBTdHJpbmcsXG4gIGxlYXZlVG9DbGFzczogU3RyaW5nLFxuICBlbnRlckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyVG9DbGFzczogU3RyaW5nLFxuICBkdXJhdGlvbjogW051bWJlciwgU3RyaW5nLCBPYmplY3RdXG59O1xuXG4vLyBpbiBjYXNlIHRoZSBjaGlsZCBpcyBhbHNvIGFuIGFic3RyYWN0IGNvbXBvbmVudCwgZS5nLiA8a2VlcC1hbGl2ZT5cbi8vIHdlIHdhbnQgdG8gcmVjdXJzaXZlbHkgcmV0cmlldmUgdGhlIHJlYWwgY29tcG9uZW50IHRvIGJlIHJlbmRlcmVkXG5mdW5jdGlvbiBnZXRSZWFsQ2hpbGQgKHZub2RlKSB7XG4gIHZhciBjb21wT3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIGlmIChjb21wT3B0aW9ucyAmJiBjb21wT3B0aW9ucy5DdG9yLm9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICByZXR1cm4gZ2V0UmVhbENoaWxkKGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoY29tcE9wdGlvbnMuY2hpbGRyZW4pKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB2bm9kZVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RUcmFuc2l0aW9uRGF0YSAoY29tcCkge1xuICB2YXIgZGF0YSA9IHt9O1xuICB2YXIgb3B0aW9ucyA9IGNvbXAuJG9wdGlvbnM7XG4gIC8vIHByb3BzXG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLnByb3BzRGF0YSkge1xuICAgIGRhdGFba2V5XSA9IGNvbXBba2V5XTtcbiAgfVxuICAvLyBldmVudHMuXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzIGFuZCBwYXNzIHRoZW0gZGlyZWN0bHkgdG8gdGhlIHRyYW5zaXRpb24gbWV0aG9kc1xuICB2YXIgbGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBmb3IgKHZhciBrZXkkMSBpbiBsaXN0ZW5lcnMpIHtcbiAgICBkYXRhW2NhbWVsaXplKGtleSQxKV0gPSBsaXN0ZW5lcnNba2V5JDFdO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIHBsYWNlaG9sZGVyIChoLCByYXdDaGlsZCkge1xuICBpZiAoL1xcZC1rZWVwLWFsaXZlJC8udGVzdChyYXdDaGlsZC50YWcpKSB7XG4gICAgcmV0dXJuIGgoJ2tlZXAtYWxpdmUnLCB7XG4gICAgICBwcm9wczogcmF3Q2hpbGQuY29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGFcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhc1BhcmVudFRyYW5zaXRpb24gKHZub2RlKSB7XG4gIHdoaWxlICgodm5vZGUgPSB2bm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHZub2RlLmRhdGEudHJhbnNpdGlvbikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTYW1lQ2hpbGQgKGNoaWxkLCBvbGRDaGlsZCkge1xuICByZXR1cm4gb2xkQ2hpbGQua2V5ID09PSBjaGlsZC5rZXkgJiYgb2xkQ2hpbGQudGFnID09PSBjaGlsZC50YWdcbn1cblxudmFyIFRyYW5zaXRpb24gPSB7XG4gIG5hbWU6ICd0cmFuc2l0aW9uJyxcbiAgcHJvcHM6IHRyYW5zaXRpb25Qcm9wcyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIG91dCB0ZXh0IG5vZGVzIChwb3NzaWJsZSB3aGl0ZXNwYWNlcylcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50YWcgfHwgaXNBc3luY1BsYWNlaG9sZGVyKGMpOyB9KTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2FybiBtdWx0aXBsZSBlbGVtZW50c1xuICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnPHRyYW5zaXRpb24+IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBzaW5nbGUgZWxlbWVudC4gVXNlICcgK1xuICAgICAgICAnPHRyYW5zaXRpb24tZ3JvdXA+IGZvciBsaXN0cy4nLFxuICAgICAgICB0aGlzLiRwYXJlbnRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIG1vZGUgPSB0aGlzLm1vZGU7XG5cbiAgICAvLyB3YXJuIGludmFsaWQgbW9kZVxuICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgbW9kZSAmJiBtb2RlICE9PSAnaW4tb3V0JyAmJiBtb2RlICE9PSAnb3V0LWluJ1xuICAgICkge1xuICAgICAgd2FybihcbiAgICAgICAgJ2ludmFsaWQgPHRyYW5zaXRpb24+IG1vZGU6ICcgKyBtb2RlLFxuICAgICAgICB0aGlzLiRwYXJlbnRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIHJhd0NoaWxkID0gY2hpbGRyZW5bMF07XG5cbiAgICAvLyBpZiB0aGlzIGlzIGEgY29tcG9uZW50IHJvb3Qgbm9kZSBhbmQgdGhlIGNvbXBvbmVudCdzXG4gICAgLy8gcGFyZW50IGNvbnRhaW5lciBub2RlIGFsc28gaGFzIHRyYW5zaXRpb24sIHNraXAuXG4gICAgaWYgKGhhc1BhcmVudFRyYW5zaXRpb24odGhpcy4kdm5vZGUpKSB7XG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG5cbiAgICAvLyBhcHBseSB0cmFuc2l0aW9uIGRhdGEgdG8gY2hpbGRcbiAgICAvLyB1c2UgZ2V0UmVhbENoaWxkKCkgdG8gaWdub3JlIGFic3RyYWN0IGNvbXBvbmVudHMgZS5nLiBrZWVwLWFsaXZlXG4gICAgdmFyIGNoaWxkID0gZ2V0UmVhbENoaWxkKHJhd0NoaWxkKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkKSB7XG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbGVhdmluZykge1xuICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgIH1cblxuICAgIC8vIGVuc3VyZSBhIGtleSB0aGF0IGlzIHVuaXF1ZSB0byB0aGUgdm5vZGUgdHlwZSBhbmQgdG8gdGhpcyB0cmFuc2l0aW9uXG4gICAgLy8gY29tcG9uZW50IGluc3RhbmNlLiBUaGlzIGtleSB3aWxsIGJlIHVzZWQgdG8gcmVtb3ZlIHBlbmRpbmcgbGVhdmluZyBub2Rlc1xuICAgIC8vIGR1cmluZyBlbnRlcmluZy5cbiAgICB2YXIgaWQgPSBcIl9fdHJhbnNpdGlvbi1cIiArICh0aGlzLl91aWQpICsgXCItXCI7XG4gICAgY2hpbGQua2V5ID0gY2hpbGQua2V5ID09IG51bGxcbiAgICAgID8gY2hpbGQuaXNDb21tZW50XG4gICAgICAgID8gaWQgKyAnY29tbWVudCdcbiAgICAgICAgOiBpZCArIGNoaWxkLnRhZ1xuICAgICAgOiBpc1ByaW1pdGl2ZShjaGlsZC5rZXkpXG4gICAgICAgID8gKFN0cmluZyhjaGlsZC5rZXkpLmluZGV4T2YoaWQpID09PSAwID8gY2hpbGQua2V5IDogaWQgKyBjaGlsZC5rZXkpXG4gICAgICAgIDogY2hpbGQua2V5O1xuXG4gICAgdmFyIGRhdGEgPSAoY2hpbGQuZGF0YSB8fCAoY2hpbGQuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcbiAgICB2YXIgb2xkUmF3Q2hpbGQgPSB0aGlzLl92bm9kZTtcbiAgICB2YXIgb2xkQ2hpbGQgPSBnZXRSZWFsQ2hpbGQob2xkUmF3Q2hpbGQpO1xuXG4gICAgLy8gbWFyayB2LXNob3dcbiAgICAvLyBzbyB0aGF0IHRoZSB0cmFuc2l0aW9uIG1vZHVsZSBjYW4gaGFuZCBvdmVyIHRoZSBjb250cm9sIHRvIHRoZSBkaXJlY3RpdmVcbiAgICBpZiAoY2hpbGQuZGF0YS5kaXJlY3RpdmVzICYmIGNoaWxkLmRhdGEuZGlyZWN0aXZlcy5zb21lKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWUgPT09ICdzaG93JzsgfSkpIHtcbiAgICAgIGNoaWxkLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgb2xkQ2hpbGQgJiZcbiAgICAgIG9sZENoaWxkLmRhdGEgJiZcbiAgICAgICFpc1NhbWVDaGlsZChjaGlsZCwgb2xkQ2hpbGQpICYmXG4gICAgICAhaXNBc3luY1BsYWNlaG9sZGVyKG9sZENoaWxkKSAmJlxuICAgICAgLy8gIzY2ODcgY29tcG9uZW50IHJvb3QgaXMgYSBjb21tZW50IG5vZGVcbiAgICAgICEob2xkQ2hpbGQuY29tcG9uZW50SW5zdGFuY2UgJiYgb2xkQ2hpbGQuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlLmlzQ29tbWVudClcbiAgICApIHtcbiAgICAgIC8vIHJlcGxhY2Ugb2xkIGNoaWxkIHRyYW5zaXRpb24gZGF0YSB3aXRoIGZyZXNoIG9uZVxuICAgICAgLy8gaW1wb3J0YW50IGZvciBkeW5hbWljIHRyYW5zaXRpb25zIVxuICAgICAgdmFyIG9sZERhdGEgPSBvbGRDaGlsZC5kYXRhLnRyYW5zaXRpb24gPSBleHRlbmQoe30sIGRhdGEpO1xuICAgICAgLy8gaGFuZGxlIHRyYW5zaXRpb24gbW9kZVxuICAgICAgaWYgKG1vZGUgPT09ICdvdXQtaW4nKSB7XG4gICAgICAgIC8vIHJldHVybiBwbGFjZWhvbGRlciBub2RlIGFuZCBxdWV1ZSB1cGRhdGUgd2hlbiBsZWF2ZSBmaW5pc2hlc1xuICAgICAgICB0aGlzLl9sZWF2aW5nID0gdHJ1ZTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2FmdGVyTGVhdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcyQxLl9sZWF2aW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcyQxLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgICAgfSBlbHNlIGlmIChtb2RlID09PSAnaW4tb3V0Jykge1xuICAgICAgICBpZiAoaXNBc3luY1BsYWNlaG9sZGVyKGNoaWxkKSkge1xuICAgICAgICAgIHJldHVybiBvbGRSYXdDaGlsZFxuICAgICAgICB9XG4gICAgICAgIHZhciBkZWxheWVkTGVhdmU7XG4gICAgICAgIHZhciBwZXJmb3JtTGVhdmUgPSBmdW5jdGlvbiAoKSB7IGRlbGF5ZWRMZWF2ZSgpOyB9O1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnYWZ0ZXJFbnRlcicsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdlbnRlckNhbmNlbGxlZCcsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdkZWxheUxlYXZlJywgZnVuY3Rpb24gKGxlYXZlKSB7IGRlbGF5ZWRMZWF2ZSA9IGxlYXZlOyB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmF3Q2hpbGRcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gUHJvdmlkZXMgdHJhbnNpdGlvbiBzdXBwb3J0IGZvciBsaXN0IGl0ZW1zLlxuLy8gc3VwcG9ydHMgbW92ZSB0cmFuc2l0aW9ucyB1c2luZyB0aGUgRkxJUCB0ZWNobmlxdWUuXG5cbi8vIEJlY2F1c2UgdGhlIHZkb20ncyBjaGlsZHJlbiB1cGRhdGUgYWxnb3JpdGhtIGlzIFwidW5zdGFibGVcIiAtIGkuZS5cbi8vIGl0IGRvZXNuJ3QgZ3VhcmFudGVlIHRoZSByZWxhdGl2ZSBwb3NpdGlvbmluZyBvZiByZW1vdmVkIGVsZW1lbnRzLFxuLy8gd2UgZm9yY2UgdHJhbnNpdGlvbi1ncm91cCB0byB1cGRhdGUgaXRzIGNoaWxkcmVuIGludG8gdHdvIHBhc3Nlczpcbi8vIGluIHRoZSBmaXJzdCBwYXNzLCB3ZSByZW1vdmUgYWxsIG5vZGVzIHRoYXQgbmVlZCB0byBiZSByZW1vdmVkLFxuLy8gdHJpZ2dlcmluZyB0aGVpciBsZWF2aW5nIHRyYW5zaXRpb247IGluIHRoZSBzZWNvbmQgcGFzcywgd2UgaW5zZXJ0L21vdmVcbi8vIGludG8gdGhlIGZpbmFsIGRlc2lyZWQgc3RhdGUuIFRoaXMgd2F5IGluIHRoZSBzZWNvbmQgcGFzcyByZW1vdmVkXG4vLyBub2RlcyB3aWxsIHJlbWFpbiB3aGVyZSB0aGV5IHNob3VsZCBiZS5cblxudmFyIHByb3BzID0gZXh0ZW5kKHtcbiAgdGFnOiBTdHJpbmcsXG4gIG1vdmVDbGFzczogU3RyaW5nXG59LCB0cmFuc2l0aW9uUHJvcHMpO1xuXG5kZWxldGUgcHJvcHMubW9kZTtcblxudmFyIFRyYW5zaXRpb25Hcm91cCA9IHtcbiAgcHJvcHM6IHByb3BzLFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRhZyA9IHRoaXMudGFnIHx8IHRoaXMuJHZub2RlLmRhdGEudGFnIHx8ICdzcGFuJztcbiAgICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgIHZhciByYXdDaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQgfHwgW107XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIHZhciB0cmFuc2l0aW9uRGF0YSA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmF3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gcmF3Q2hpbGRyZW5baV07XG4gICAgICBpZiAoYy50YWcpIHtcbiAgICAgICAgaWYgKGMua2V5ICE9IG51bGwgJiYgU3RyaW5nKGMua2V5KS5pbmRleE9mKCdfX3ZsaXN0JykgIT09IDApIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKGMpO1xuICAgICAgICAgIG1hcFtjLmtleV0gPSBjXG4gICAgICAgICAgOyhjLmRhdGEgfHwgKGMuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBvcHRzID0gYy5jb21wb25lbnRPcHRpb25zO1xuICAgICAgICAgIHZhciBuYW1lID0gb3B0cyA/IChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnIHx8ICcnKSA6IGMudGFnO1xuICAgICAgICAgIHdhcm4oKFwiPHRyYW5zaXRpb24tZ3JvdXA+IGNoaWxkcmVuIG11c3QgYmUga2V5ZWQ6IDxcIiArIG5hbWUgKyBcIj5cIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByZXZDaGlsZHJlbikge1xuICAgICAgdmFyIGtlcHQgPSBbXTtcbiAgICAgIHZhciByZW1vdmVkID0gW107XG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBwcmV2Q2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICB2YXIgYyQxID0gcHJldkNoaWxkcmVuW2kkMV07XG4gICAgICAgIGMkMS5kYXRhLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcbiAgICAgICAgYyQxLmRhdGEucG9zID0gYyQxLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKG1hcFtjJDEua2V5XSkge1xuICAgICAgICAgIGtlcHQucHVzaChjJDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlbW92ZWQucHVzaChjJDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmtlcHQgPSBoKHRhZywgbnVsbCwga2VwdCk7XG4gICAgICB0aGlzLnJlbW92ZWQgPSByZW1vdmVkO1xuICAgIH1cblxuICAgIHJldHVybiBoKHRhZywgbnVsbCwgY2hpbGRyZW4pXG4gIH0sXG5cbiAgYmVmb3JlVXBkYXRlOiBmdW5jdGlvbiBiZWZvcmVVcGRhdGUgKCkge1xuICAgIC8vIGZvcmNlIHJlbW92aW5nIHBhc3NcbiAgICB0aGlzLl9fcGF0Y2hfXyhcbiAgICAgIHRoaXMuX3Zub2RlLFxuICAgICAgdGhpcy5rZXB0LFxuICAgICAgZmFsc2UsIC8vIGh5ZHJhdGluZ1xuICAgICAgdHJ1ZSAvLyByZW1vdmVPbmx5ICghaW1wb3J0YW50LCBhdm9pZHMgdW5uZWNlc3NhcnkgbW92ZXMpXG4gICAgKTtcbiAgICB0aGlzLl92bm9kZSA9IHRoaXMua2VwdDtcbiAgfSxcblxuICB1cGRhdGVkOiBmdW5jdGlvbiB1cGRhdGVkICgpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbjtcbiAgICB2YXIgbW92ZUNsYXNzID0gdGhpcy5tb3ZlQ2xhc3MgfHwgKCh0aGlzLm5hbWUgfHwgJ3YnKSArICctbW92ZScpO1xuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoIHx8ICF0aGlzLmhhc01vdmUoY2hpbGRyZW5bMF0uZWxtLCBtb3ZlQ2xhc3MpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB3ZSBkaXZpZGUgdGhlIHdvcmsgaW50byB0aHJlZSBsb29wcyB0byBhdm9pZCBtaXhpbmcgRE9NIHJlYWRzIGFuZCB3cml0ZXNcbiAgICAvLyBpbiBlYWNoIGl0ZXJhdGlvbiAtIHdoaWNoIGhlbHBzIHByZXZlbnQgbGF5b3V0IHRocmFzaGluZy5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNhbGxQZW5kaW5nQ2JzKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKHJlY29yZFBvc2l0aW9uKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGFwcGx5VHJhbnNsYXRpb24pO1xuXG4gICAgLy8gZm9yY2UgcmVmbG93IHRvIHB1dCBldmVyeXRoaW5nIGluIHBvc2l0aW9uXG4gICAgLy8gYXNzaWduIHRvIHRoaXMgdG8gYXZvaWQgYmVpbmcgcmVtb3ZlZCBpbiB0cmVlLXNoYWtpbmdcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICB0aGlzLl9yZWZsb3cgPSBkb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodDtcblxuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgIGlmIChjLmRhdGEubW92ZWQpIHtcbiAgICAgICAgdmFyIGVsID0gYy5lbG07XG4gICAgICAgIHZhciBzID0gZWwuc3R5bGU7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJyc7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBlbC5fbW92ZUNiID0gZnVuY3Rpb24gY2IgKGUpIHtcbiAgICAgICAgICBpZiAoIWUgfHwgL3RyYW5zZm9ybSQvLnRlc3QoZS5wcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgY2IpO1xuICAgICAgICAgICAgZWwuX21vdmVDYiA9IG51bGw7XG4gICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICBtZXRob2RzOiB7XG4gICAgaGFzTW92ZTogZnVuY3Rpb24gaGFzTW92ZSAoZWwsIG1vdmVDbGFzcykge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoIWhhc1RyYW5zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICh0aGlzLl9oYXNNb3ZlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNNb3ZlXG4gICAgICB9XG4gICAgICAvLyBEZXRlY3Qgd2hldGhlciBhbiBlbGVtZW50IHdpdGggdGhlIG1vdmUgY2xhc3MgYXBwbGllZCBoYXNcbiAgICAgIC8vIENTUyB0cmFuc2l0aW9ucy4gU2luY2UgdGhlIGVsZW1lbnQgbWF5IGJlIGluc2lkZSBhbiBlbnRlcmluZ1xuICAgICAgLy8gdHJhbnNpdGlvbiBhdCB0aGlzIHZlcnkgbW9tZW50LCB3ZSBtYWtlIGEgY2xvbmUgb2YgaXQgYW5kIHJlbW92ZVxuICAgICAgLy8gYWxsIG90aGVyIHRyYW5zaXRpb24gY2xhc3NlcyBhcHBsaWVkIHRvIGVuc3VyZSBvbmx5IHRoZSBtb3ZlIGNsYXNzXG4gICAgICAvLyBpcyBhcHBsaWVkLlxuICAgICAgdmFyIGNsb25lID0gZWwuY2xvbmVOb2RlKCk7XG4gICAgICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgICAgIGVsLl90cmFuc2l0aW9uQ2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHsgcmVtb3ZlQ2xhc3MoY2xvbmUsIGNscyk7IH0pO1xuICAgICAgfVxuICAgICAgYWRkQ2xhc3MoY2xvbmUsIG1vdmVDbGFzcyk7XG4gICAgICBjbG9uZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgdGhpcy4kZWwuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuICAgICAgdmFyIGluZm8gPSBnZXRUcmFuc2l0aW9uSW5mbyhjbG9uZSk7XG4gICAgICB0aGlzLiRlbC5yZW1vdmVDaGlsZChjbG9uZSk7XG4gICAgICByZXR1cm4gKHRoaXMuX2hhc01vdmUgPSBpbmZvLmhhc1RyYW5zZm9ybSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMgKGMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fbW92ZUNiKSB7XG4gICAgYy5lbG0uX21vdmVDYigpO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX2VudGVyQ2IpIHtcbiAgICBjLmVsbS5fZW50ZXJDYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY29yZFBvc2l0aW9uIChjKSB7XG4gIGMuZGF0YS5uZXdQb3MgPSBjLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbiAoYykge1xuICB2YXIgb2xkUG9zID0gYy5kYXRhLnBvcztcbiAgdmFyIG5ld1BvcyA9IGMuZGF0YS5uZXdQb3M7XG4gIHZhciBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XG4gIHZhciBkeSA9IG9sZFBvcy50b3AgLSBuZXdQb3MudG9wO1xuICBpZiAoZHggfHwgZHkpIHtcbiAgICBjLmRhdGEubW92ZWQgPSB0cnVlO1xuICAgIHZhciBzID0gYy5lbG0uc3R5bGU7XG4gICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgZHggKyBcInB4LFwiICsgZHkgKyBcInB4KVwiO1xuICAgIHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcbiAgfVxufVxuXG52YXIgcGxhdGZvcm1Db21wb25lbnRzID0ge1xuICBUcmFuc2l0aW9uOiBUcmFuc2l0aW9uLFxuICBUcmFuc2l0aW9uR3JvdXA6IFRyYW5zaXRpb25Hcm91cFxufVxuXG4vKiAgKi9cblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBzcGVjaWZpYyB1dGlsc1xuVnVlLmNvbmZpZy5tdXN0VXNlUHJvcCA9IG11c3RVc2VQcm9wO1xuVnVlLmNvbmZpZy5pc1Jlc2VydmVkVGFnID0gaXNSZXNlcnZlZFRhZztcblZ1ZS5jb25maWcuaXNSZXNlcnZlZEF0dHIgPSBpc1Jlc2VydmVkQXR0cjtcblZ1ZS5jb25maWcuZ2V0VGFnTmFtZXNwYWNlID0gZ2V0VGFnTmFtZXNwYWNlO1xuVnVlLmNvbmZpZy5pc1Vua25vd25FbGVtZW50ID0gaXNVbmtub3duRWxlbWVudDtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBydW50aW1lIGRpcmVjdGl2ZXMgJiBjb21wb25lbnRzXG5leHRlbmQoVnVlLm9wdGlvbnMuZGlyZWN0aXZlcywgcGxhdGZvcm1EaXJlY3RpdmVzKTtcbmV4dGVuZChWdWUub3B0aW9ucy5jb21wb25lbnRzLCBwbGF0Zm9ybUNvbXBvbmVudHMpO1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHBhdGNoIGZ1bmN0aW9uXG5WdWUucHJvdG90eXBlLl9fcGF0Y2hfXyA9IGluQnJvd3NlciA/IHBhdGNoIDogbm9vcDtcblxuLy8gcHVibGljIG1vdW50IG1ldGhvZFxuVnVlLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICBlbCA9IGVsICYmIGluQnJvd3NlciA/IHF1ZXJ5KGVsKSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIG1vdW50Q29tcG9uZW50KHRoaXMsIGVsLCBoeWRyYXRpbmcpXG59O1xuXG4vLyBkZXZ0b29scyBnbG9iYWwgaG9va1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmlmIChpbkJyb3dzZXIpIHtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNvbmZpZy5kZXZ0b29scykge1xuICAgICAgaWYgKGRldnRvb2xzKSB7XG4gICAgICAgIGRldnRvb2xzLmVtaXQoJ2luaXQnLCBWdWUpO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgXCJkZXZlbG9wbWVudFwiICE9PSAndGVzdCcgJiZcbiAgICAgICAgaXNDaHJvbWVcbiAgICAgICkge1xuICAgICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgICAnRG93bmxvYWQgdGhlIFZ1ZSBEZXZ0b29scyBleHRlbnNpb24gZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6XFxuJyArXG4gICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUtZGV2dG9vbHMnXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgXCJkZXZlbG9wbWVudFwiICE9PSAndGVzdCcgJiZcbiAgICAgIGNvbmZpZy5wcm9kdWN0aW9uVGlwICE9PSBmYWxzZSAmJlxuICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnXG4gICAgKSB7XG4gICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgXCJZb3UgYXJlIHJ1bm5pbmcgVnVlIGluIGRldmVsb3BtZW50IG1vZGUuXFxuXCIgK1xuICAgICAgICBcIk1ha2Ugc3VyZSB0byB0dXJuIG9uIHByb2R1Y3Rpb24gbW9kZSB3aGVuIGRlcGxveWluZyBmb3IgcHJvZHVjdGlvbi5cXG5cIiArXG4gICAgICAgIFwiU2VlIG1vcmUgdGlwcyBhdCBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9kZXBsb3ltZW50Lmh0bWxcIlxuICAgICAgKTtcbiAgICB9XG4gIH0sIDApO1xufVxuXG4vKiAgKi9cblxudmFyIGRlZmF1bHRUYWdSRSA9IC9cXHtcXHsoKD86LnxcXG4pKz8pXFx9XFx9L2c7XG52YXIgcmVnZXhFc2NhcGVSRSA9IC9bLS4qKz9eJHt9KCl8W1xcXVxcL1xcXFxdL2c7XG5cbnZhciBidWlsZFJlZ2V4ID0gY2FjaGVkKGZ1bmN0aW9uIChkZWxpbWl0ZXJzKSB7XG4gIHZhciBvcGVuID0gZGVsaW1pdGVyc1swXS5yZXBsYWNlKHJlZ2V4RXNjYXBlUkUsICdcXFxcJCYnKTtcbiAgdmFyIGNsb3NlID0gZGVsaW1pdGVyc1sxXS5yZXBsYWNlKHJlZ2V4RXNjYXBlUkUsICdcXFxcJCYnKTtcbiAgcmV0dXJuIG5ldyBSZWdFeHAob3BlbiArICcoKD86LnxcXFxcbikrPyknICsgY2xvc2UsICdnJylcbn0pO1xuXG5cblxuZnVuY3Rpb24gcGFyc2VUZXh0IChcbiAgdGV4dCxcbiAgZGVsaW1pdGVyc1xuKSB7XG4gIHZhciB0YWdSRSA9IGRlbGltaXRlcnMgPyBidWlsZFJlZ2V4KGRlbGltaXRlcnMpIDogZGVmYXVsdFRhZ1JFO1xuICBpZiAoIXRhZ1JFLnRlc3QodGV4dCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdG9rZW5zID0gW107XG4gIHZhciByYXdUb2tlbnMgPSBbXTtcbiAgdmFyIGxhc3RJbmRleCA9IHRhZ1JFLmxhc3RJbmRleCA9IDA7XG4gIHZhciBtYXRjaCwgaW5kZXgsIHRva2VuVmFsdWU7XG4gIHdoaWxlICgobWF0Y2ggPSB0YWdSRS5leGVjKHRleHQpKSkge1xuICAgIGluZGV4ID0gbWF0Y2guaW5kZXg7XG4gICAgLy8gcHVzaCB0ZXh0IHRva2VuXG4gICAgaWYgKGluZGV4ID4gbGFzdEluZGV4KSB7XG4gICAgICByYXdUb2tlbnMucHVzaCh0b2tlblZhbHVlID0gdGV4dC5zbGljZShsYXN0SW5kZXgsIGluZGV4KSk7XG4gICAgICB0b2tlbnMucHVzaChKU09OLnN0cmluZ2lmeSh0b2tlblZhbHVlKSk7XG4gICAgfVxuICAgIC8vIHRhZyB0b2tlblxuICAgIHZhciBleHAgPSBwYXJzZUZpbHRlcnMobWF0Y2hbMV0udHJpbSgpKTtcbiAgICB0b2tlbnMucHVzaCgoXCJfcyhcIiArIGV4cCArIFwiKVwiKSk7XG4gICAgcmF3VG9rZW5zLnB1c2goeyAnQGJpbmRpbmcnOiBleHAgfSk7XG4gICAgbGFzdEluZGV4ID0gaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gIH1cbiAgaWYgKGxhc3RJbmRleCA8IHRleHQubGVuZ3RoKSB7XG4gICAgcmF3VG9rZW5zLnB1c2godG9rZW5WYWx1ZSA9IHRleHQuc2xpY2UobGFzdEluZGV4KSk7XG4gICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodG9rZW5WYWx1ZSkpO1xuICB9XG4gIHJldHVybiB7XG4gICAgZXhwcmVzc2lvbjogdG9rZW5zLmpvaW4oJysnKSxcbiAgICB0b2tlbnM6IHJhd1Rva2Vuc1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Ob2RlIChlbCwgb3B0aW9ucykge1xuICB2YXIgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdmFyIHN0YXRpY0NsYXNzID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ2NsYXNzJyk7XG4gIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBzdGF0aWNDbGFzcykge1xuICAgIHZhciByZXMgPSBwYXJzZVRleHQoc3RhdGljQ2xhc3MsIG9wdGlvbnMuZGVsaW1pdGVycyk7XG4gICAgaWYgKHJlcykge1xuICAgICAgd2FybihcbiAgICAgICAgXCJjbGFzcz1cXFwiXCIgKyBzdGF0aWNDbGFzcyArIFwiXFxcIjogXCIgK1xuICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgY2xhc3M9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDpjbGFzcz1cInZhbFwiPi4nXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBpZiAoc3RhdGljQ2xhc3MpIHtcbiAgICBlbC5zdGF0aWNDbGFzcyA9IEpTT04uc3RyaW5naWZ5KHN0YXRpY0NsYXNzKTtcbiAgfVxuICB2YXIgY2xhc3NCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdjbGFzcycsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG4gIGlmIChjbGFzc0JpbmRpbmcpIHtcbiAgICBlbC5jbGFzc0JpbmRpbmcgPSBjbGFzc0JpbmRpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSAoZWwpIHtcbiAgdmFyIGRhdGEgPSAnJztcbiAgaWYgKGVsLnN0YXRpY0NsYXNzKSB7XG4gICAgZGF0YSArPSBcInN0YXRpY0NsYXNzOlwiICsgKGVsLnN0YXRpY0NsYXNzKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5jbGFzc0JpbmRpbmcpIHtcbiAgICBkYXRhICs9IFwiY2xhc3M6XCIgKyAoZWwuY2xhc3NCaW5kaW5nKSArIFwiLFwiO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbnZhciBrbGFzcyQxID0ge1xuICBzdGF0aWNLZXlzOiBbJ3N0YXRpY0NsYXNzJ10sXG4gIHRyYW5zZm9ybU5vZGU6IHRyYW5zZm9ybU5vZGUsXG4gIGdlbkRhdGE6IGdlbkRhdGFcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU5vZGUkMSAoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHdhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHZhciBzdGF0aWNTdHlsZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzdHlsZScpO1xuICBpZiAoc3RhdGljU3R5bGUpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICB7XG4gICAgICB2YXIgcmVzID0gcGFyc2VUZXh0KHN0YXRpY1N0eWxlLCBvcHRpb25zLmRlbGltaXRlcnMpO1xuICAgICAgaWYgKHJlcykge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwic3R5bGU9XFxcIlwiICsgc3RhdGljU3R5bGUgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IHN0eWxlPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6c3R5bGU9XCJ2YWxcIj4uJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBlbC5zdGF0aWNTdHlsZSA9IEpTT04uc3RyaW5naWZ5KHBhcnNlU3R5bGVUZXh0KHN0YXRpY1N0eWxlKSk7XG4gIH1cblxuICB2YXIgc3R5bGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzdHlsZScsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG4gIGlmIChzdHlsZUJpbmRpbmcpIHtcbiAgICBlbC5zdHlsZUJpbmRpbmcgPSBzdHlsZUJpbmRpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSQxIChlbCkge1xuICB2YXIgZGF0YSA9ICcnO1xuICBpZiAoZWwuc3RhdGljU3R5bGUpIHtcbiAgICBkYXRhICs9IFwic3RhdGljU3R5bGU6XCIgKyAoZWwuc3RhdGljU3R5bGUpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLnN0eWxlQmluZGluZykge1xuICAgIGRhdGEgKz0gXCJzdHlsZTooXCIgKyAoZWwuc3R5bGVCaW5kaW5nKSArIFwiKSxcIjtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG52YXIgc3R5bGUkMSA9IHtcbiAgc3RhdGljS2V5czogWydzdGF0aWNTdHlsZSddLFxuICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlJDEsXG4gIGdlbkRhdGE6IGdlbkRhdGEkMVxufVxuXG4vKiAgKi9cblxudmFyIGRlY29kZXI7XG5cbnZhciBoZSA9IHtcbiAgZGVjb2RlOiBmdW5jdGlvbiBkZWNvZGUgKGh0bWwpIHtcbiAgICBkZWNvZGVyID0gZGVjb2RlciB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkZWNvZGVyLmlubmVySFRNTCA9IGh0bWw7XG4gICAgcmV0dXJuIGRlY29kZXIudGV4dENvbnRlbnRcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGlzVW5hcnlUYWcgPSBtYWtlTWFwKFxuICAnYXJlYSxiYXNlLGJyLGNvbCxlbWJlZCxmcmFtZSxocixpbWcsaW5wdXQsaXNpbmRleCxrZXlnZW4sJyArXG4gICdsaW5rLG1ldGEscGFyYW0sc291cmNlLHRyYWNrLHdicidcbik7XG5cbi8vIEVsZW1lbnRzIHRoYXQgeW91IGNhbiwgaW50ZW50aW9uYWxseSwgbGVhdmUgb3BlblxuLy8gKGFuZCB3aGljaCBjbG9zZSB0aGVtc2VsdmVzKVxudmFyIGNhbkJlTGVmdE9wZW5UYWcgPSBtYWtlTWFwKFxuICAnY29sZ3JvdXAsZGQsZHQsbGksb3B0aW9ucyxwLHRkLHRmb290LHRoLHRoZWFkLHRyLHNvdXJjZSdcbik7XG5cbi8vIEhUTUw1IHRhZ3MgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5kaWNlcy5odG1sI2VsZW1lbnRzLTNcbi8vIFBocmFzaW5nIENvbnRlbnQgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG9tLmh0bWwjcGhyYXNpbmctY29udGVudFxudmFyIGlzTm9uUGhyYXNpbmdUYWcgPSBtYWtlTWFwKFxuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGJhc2UsYmxvY2txdW90ZSxib2R5LGNhcHRpb24sY29sLGNvbGdyb3VwLGRkLCcgK1xuICAnZGV0YWlscyxkaWFsb2csZGl2LGRsLGR0LGZpZWxkc2V0LGZpZ2NhcHRpb24sZmlndXJlLGZvb3Rlcixmb3JtLCcgK1xuICAnaDEsaDIsaDMsaDQsaDUsaDYsaGVhZCxoZWFkZXIsaGdyb3VwLGhyLGh0bWwsbGVnZW5kLGxpLG1lbnVpdGVtLG1ldGEsJyArXG4gICdvcHRncm91cCxvcHRpb24scGFyYW0scnAscnQsc291cmNlLHN0eWxlLHN1bW1hcnksdGJvZHksdGQsdGZvb3QsdGgsdGhlYWQsJyArXG4gICd0aXRsZSx0cix0cmFjaydcbik7XG5cbi8qKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgaXQncyBtb3N0bHkgdmVuZG9yIGNvZGUuXG4gKi9cblxuLyohXG4gKiBIVE1MIFBhcnNlciBCeSBKb2huIFJlc2lnIChlam9obi5vcmcpXG4gKiBNb2RpZmllZCBieSBKdXJpeSBcImthbmdheFwiIFpheXRzZXZcbiAqIE9yaWdpbmFsIGNvZGUgYnkgRXJpayBBcnZpZHNzb24sIE1vemlsbGEgUHVibGljIExpY2Vuc2VcbiAqIGh0dHA6Ly9lcmlrLmVhZS5uZXQvc2ltcGxlaHRtbHBhcnNlci9zaW1wbGVodG1scGFyc2VyLmpzXG4gKi9cblxuLy8gUmVndWxhciBFeHByZXNzaW9ucyBmb3IgcGFyc2luZyB0YWdzIGFuZCBhdHRyaWJ1dGVzXG52YXIgYXR0cmlidXRlID0gL15cXHMqKFteXFxzXCInPD5cXC89XSspKD86XFxzKig9KVxccyooPzpcIihbXlwiXSopXCIrfCcoW14nXSopJyt8KFteXFxzXCInPTw+YF0rKSkpPy87XG4vLyBjb3VsZCB1c2UgaHR0cHM6Ly93d3cudzMub3JnL1RSLzE5OTkvUkVDLXhtbC1uYW1lcy0xOTk5MDExNC8jTlQtUU5hbWVcbi8vIGJ1dCBmb3IgVnVlIHRlbXBsYXRlcyB3ZSBjYW4gZW5mb3JjZSBhIHNpbXBsZSBjaGFyc2V0XG52YXIgbmNuYW1lID0gJ1thLXpBLVpfXVtcXFxcd1xcXFwtXFxcXC5dKic7XG52YXIgcW5hbWVDYXB0dXJlID0gXCIoKD86XCIgKyBuY25hbWUgKyBcIlxcXFw6KT9cIiArIG5jbmFtZSArIFwiKVwiO1xudmFyIHN0YXJ0VGFnT3BlbiA9IG5ldyBSZWdFeHAoKFwiXjxcIiArIHFuYW1lQ2FwdHVyZSkpO1xudmFyIHN0YXJ0VGFnQ2xvc2UgPSAvXlxccyooXFwvPyk+LztcbnZhciBlbmRUYWcgPSBuZXcgUmVnRXhwKChcIl48XFxcXC9cIiArIHFuYW1lQ2FwdHVyZSArIFwiW14+XSo+XCIpKTtcbnZhciBkb2N0eXBlID0gL148IURPQ1RZUEUgW14+XSs+L2k7XG4vLyAjNzI5ODogZXNjYXBlIC0gdG8gYXZvaWQgYmVpbmcgcGFzZWQgYXMgSFRNTCBjb21tZW50IHdoZW4gaW5saW5lZCBpbiBwYWdlXG52YXIgY29tbWVudCA9IC9ePCFcXC0tLztcbnZhciBjb25kaXRpb25hbENvbW1lbnQgPSAvXjwhXFxbLztcblxudmFyIElTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4gPSBmYWxzZTtcbid4Jy5yZXBsYWNlKC94KC4pPy9nLCBmdW5jdGlvbiAobSwgZykge1xuICBJU19SRUdFWF9DQVBUVVJJTkdfQlJPS0VOID0gZyA9PT0gJyc7XG59KTtcblxuLy8gU3BlY2lhbCBFbGVtZW50cyAoY2FuIGNvbnRhaW4gYW55dGhpbmcpXG52YXIgaXNQbGFpblRleHRFbGVtZW50ID0gbWFrZU1hcCgnc2NyaXB0LHN0eWxlLHRleHRhcmVhJywgdHJ1ZSk7XG52YXIgcmVDYWNoZSA9IHt9O1xuXG52YXIgZGVjb2RpbmdNYXAgPSB7XG4gICcmbHQ7JzogJzwnLFxuICAnJmd0Oyc6ICc+JyxcbiAgJyZxdW90Oyc6ICdcIicsXG4gICcmYW1wOyc6ICcmJyxcbiAgJyYjMTA7JzogJ1xcbicsXG4gICcmIzk7JzogJ1xcdCdcbn07XG52YXIgZW5jb2RlZEF0dHIgPSAvJig/Omx0fGd0fHF1b3R8YW1wKTsvZztcbnZhciBlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyA9IC8mKD86bHR8Z3R8cXVvdHxhbXB8IzEwfCM5KTsvZztcblxuLy8gIzU5OTJcbnZhciBpc0lnbm9yZU5ld2xpbmVUYWcgPSBtYWtlTWFwKCdwcmUsdGV4dGFyZWEnLCB0cnVlKTtcbnZhciBzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUgPSBmdW5jdGlvbiAodGFnLCBodG1sKSB7IHJldHVybiB0YWcgJiYgaXNJZ25vcmVOZXdsaW5lVGFnKHRhZykgJiYgaHRtbFswXSA9PT0gJ1xcbic7IH07XG5cbmZ1bmN0aW9uIGRlY29kZUF0dHIgKHZhbHVlLCBzaG91bGREZWNvZGVOZXdsaW5lcykge1xuICB2YXIgcmUgPSBzaG91bGREZWNvZGVOZXdsaW5lcyA/IGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzIDogZW5jb2RlZEF0dHI7XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKHJlLCBmdW5jdGlvbiAobWF0Y2gpIHsgcmV0dXJuIGRlY29kaW5nTWFwW21hdGNoXTsgfSlcbn1cblxuZnVuY3Rpb24gcGFyc2VIVE1MIChodG1sLCBvcHRpb25zKSB7XG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgZXhwZWN0SFRNTCA9IG9wdGlvbnMuZXhwZWN0SFRNTDtcbiAgdmFyIGlzVW5hcnlUYWckJDEgPSBvcHRpb25zLmlzVW5hcnlUYWcgfHwgbm87XG4gIHZhciBjYW5CZUxlZnRPcGVuVGFnJCQxID0gb3B0aW9ucy5jYW5CZUxlZnRPcGVuVGFnIHx8IG5vO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdCwgbGFzdFRhZztcbiAgd2hpbGUgKGh0bWwpIHtcbiAgICBsYXN0ID0gaHRtbDtcbiAgICAvLyBNYWtlIHN1cmUgd2UncmUgbm90IGluIGEgcGxhaW50ZXh0IGNvbnRlbnQgZWxlbWVudCBsaWtlIHNjcmlwdC9zdHlsZVxuICAgIGlmICghbGFzdFRhZyB8fCAhaXNQbGFpblRleHRFbGVtZW50KGxhc3RUYWcpKSB7XG4gICAgICB2YXIgdGV4dEVuZCA9IGh0bWwuaW5kZXhPZignPCcpO1xuICAgICAgaWYgKHRleHRFbmQgPT09IDApIHtcbiAgICAgICAgLy8gQ29tbWVudDpcbiAgICAgICAgaWYgKGNvbW1lbnQudGVzdChodG1sKSkge1xuICAgICAgICAgIHZhciBjb21tZW50RW5kID0gaHRtbC5pbmRleE9mKCctLT4nKTtcblxuICAgICAgICAgIGlmIChjb21tZW50RW5kID49IDApIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3VsZEtlZXBDb21tZW50KSB7XG4gICAgICAgICAgICAgIG9wdGlvbnMuY29tbWVudChodG1sLnN1YnN0cmluZyg0LCBjb21tZW50RW5kKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZHZhbmNlKGNvbW1lbnRFbmQgKyAzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db25kaXRpb25hbF9jb21tZW50I0Rvd25sZXZlbC1yZXZlYWxlZF9jb25kaXRpb25hbF9jb21tZW50XG4gICAgICAgIGlmIChjb25kaXRpb25hbENvbW1lbnQudGVzdChodG1sKSkge1xuICAgICAgICAgIHZhciBjb25kaXRpb25hbEVuZCA9IGh0bWwuaW5kZXhPZignXT4nKTtcblxuICAgICAgICAgIGlmIChjb25kaXRpb25hbEVuZCA+PSAwKSB7XG4gICAgICAgICAgICBhZHZhbmNlKGNvbmRpdGlvbmFsRW5kICsgMik7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERvY3R5cGU6XG4gICAgICAgIHZhciBkb2N0eXBlTWF0Y2ggPSBodG1sLm1hdGNoKGRvY3R5cGUpO1xuICAgICAgICBpZiAoZG9jdHlwZU1hdGNoKSB7XG4gICAgICAgICAgYWR2YW5jZShkb2N0eXBlTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRW5kIHRhZzpcbiAgICAgICAgdmFyIGVuZFRhZ01hdGNoID0gaHRtbC5tYXRjaChlbmRUYWcpO1xuICAgICAgICBpZiAoZW5kVGFnTWF0Y2gpIHtcbiAgICAgICAgICB2YXIgY3VySW5kZXggPSBpbmRleDtcbiAgICAgICAgICBhZHZhbmNlKGVuZFRhZ01hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgcGFyc2VFbmRUYWcoZW5kVGFnTWF0Y2hbMV0sIGN1ckluZGV4LCBpbmRleCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0YXJ0IHRhZzpcbiAgICAgICAgdmFyIHN0YXJ0VGFnTWF0Y2ggPSBwYXJzZVN0YXJ0VGFnKCk7XG4gICAgICAgIGlmIChzdGFydFRhZ01hdGNoKSB7XG4gICAgICAgICAgaGFuZGxlU3RhcnRUYWcoc3RhcnRUYWdNYXRjaCk7XG4gICAgICAgICAgaWYgKHNob3VsZElnbm9yZUZpcnN0TmV3bGluZShsYXN0VGFnLCBodG1sKSkge1xuICAgICAgICAgICAgYWR2YW5jZSgxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdGV4dCA9ICh2b2lkIDApLCByZXN0ID0gKHZvaWQgMCksIG5leHQgPSAodm9pZCAwKTtcbiAgICAgIGlmICh0ZXh0RW5kID49IDApIHtcbiAgICAgICAgcmVzdCA9IGh0bWwuc2xpY2UodGV4dEVuZCk7XG4gICAgICAgIHdoaWxlIChcbiAgICAgICAgICAhZW5kVGFnLnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAhc3RhcnRUYWdPcGVuLnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAhY29tbWVudC50ZXN0KHJlc3QpICYmXG4gICAgICAgICAgIWNvbmRpdGlvbmFsQ29tbWVudC50ZXN0KHJlc3QpXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIDwgaW4gcGxhaW4gdGV4dCwgYmUgZm9yZ2l2aW5nIGFuZCB0cmVhdCBpdCBhcyB0ZXh0XG4gICAgICAgICAgbmV4dCA9IHJlc3QuaW5kZXhPZignPCcsIDEpO1xuICAgICAgICAgIGlmIChuZXh0IDwgMCkgeyBicmVhayB9XG4gICAgICAgICAgdGV4dEVuZCArPSBuZXh0O1xuICAgICAgICAgIHJlc3QgPSBodG1sLnNsaWNlKHRleHRFbmQpO1xuICAgICAgICB9XG4gICAgICAgIHRleHQgPSBodG1sLnN1YnN0cmluZygwLCB0ZXh0RW5kKTtcbiAgICAgICAgYWR2YW5jZSh0ZXh0RW5kKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRleHRFbmQgPCAwKSB7XG4gICAgICAgIHRleHQgPSBodG1sO1xuICAgICAgICBodG1sID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmNoYXJzICYmIHRleHQpIHtcbiAgICAgICAgb3B0aW9ucy5jaGFycyh0ZXh0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVuZFRhZ0xlbmd0aCA9IDA7XG4gICAgICB2YXIgc3RhY2tlZFRhZyA9IGxhc3RUYWcudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciByZVN0YWNrZWRUYWcgPSByZUNhY2hlW3N0YWNrZWRUYWddIHx8IChyZUNhY2hlW3N0YWNrZWRUYWddID0gbmV3IFJlZ0V4cCgnKFtcXFxcc1xcXFxTXSo/KSg8LycgKyBzdGFja2VkVGFnICsgJ1tePl0qPiknLCAnaScpKTtcbiAgICAgIHZhciByZXN0JDEgPSBodG1sLnJlcGxhY2UocmVTdGFja2VkVGFnLCBmdW5jdGlvbiAoYWxsLCB0ZXh0LCBlbmRUYWcpIHtcbiAgICAgICAgZW5kVGFnTGVuZ3RoID0gZW5kVGFnLmxlbmd0aDtcbiAgICAgICAgaWYgKCFpc1BsYWluVGV4dEVsZW1lbnQoc3RhY2tlZFRhZykgJiYgc3RhY2tlZFRhZyAhPT0gJ25vc2NyaXB0Jykge1xuICAgICAgICAgIHRleHQgPSB0ZXh0XG4gICAgICAgICAgICAucmVwbGFjZSgvPCFcXC0tKFtcXHNcXFNdKj8pLS0+L2csICckMScpIC8vICM3Mjk4XG4gICAgICAgICAgICAucmVwbGFjZSgvPCFcXFtDREFUQVxcWyhbXFxzXFxTXSo/KV1dPi9nLCAnJDEnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lKHN0YWNrZWRUYWcsIHRleHQpKSB7XG4gICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuY2hhcnMpIHtcbiAgICAgICAgICBvcHRpb25zLmNoYXJzKHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJ1xuICAgICAgfSk7XG4gICAgICBpbmRleCArPSBodG1sLmxlbmd0aCAtIHJlc3QkMS5sZW5ndGg7XG4gICAgICBodG1sID0gcmVzdCQxO1xuICAgICAgcGFyc2VFbmRUYWcoc3RhY2tlZFRhZywgaW5kZXggLSBlbmRUYWdMZW5ndGgsIGluZGV4KTtcbiAgICB9XG5cbiAgICBpZiAoaHRtbCA9PT0gbGFzdCkge1xuICAgICAgb3B0aW9ucy5jaGFycyAmJiBvcHRpb25zLmNoYXJzKGh0bWwpO1xuICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmICFzdGFjay5sZW5ndGggJiYgb3B0aW9ucy53YXJuKSB7XG4gICAgICAgIG9wdGlvbnMud2FybigoXCJNYWwtZm9ybWF0dGVkIHRhZyBhdCBlbmQgb2YgdGVtcGxhdGU6IFxcXCJcIiArIGh0bWwgKyBcIlxcXCJcIikpO1xuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICAvLyBDbGVhbiB1cCBhbnkgcmVtYWluaW5nIHRhZ3NcbiAgcGFyc2VFbmRUYWcoKTtcblxuICBmdW5jdGlvbiBhZHZhbmNlIChuKSB7XG4gICAgaW5kZXggKz0gbjtcbiAgICBodG1sID0gaHRtbC5zdWJzdHJpbmcobik7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVN0YXJ0VGFnICgpIHtcbiAgICB2YXIgc3RhcnQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnT3Blbik7XG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICB2YXIgbWF0Y2ggPSB7XG4gICAgICAgIHRhZ05hbWU6IHN0YXJ0WzFdLFxuICAgICAgICBhdHRyczogW10sXG4gICAgICAgIHN0YXJ0OiBpbmRleFxuICAgICAgfTtcbiAgICAgIGFkdmFuY2Uoc3RhcnRbMF0ubGVuZ3RoKTtcbiAgICAgIHZhciBlbmQsIGF0dHI7XG4gICAgICB3aGlsZSAoIShlbmQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnQ2xvc2UpKSAmJiAoYXR0ciA9IGh0bWwubWF0Y2goYXR0cmlidXRlKSkpIHtcbiAgICAgICAgYWR2YW5jZShhdHRyWzBdLmxlbmd0aCk7XG4gICAgICAgIG1hdGNoLmF0dHJzLnB1c2goYXR0cik7XG4gICAgICB9XG4gICAgICBpZiAoZW5kKSB7XG4gICAgICAgIG1hdGNoLnVuYXJ5U2xhc2ggPSBlbmRbMV07XG4gICAgICAgIGFkdmFuY2UoZW5kWzBdLmxlbmd0aCk7XG4gICAgICAgIG1hdGNoLmVuZCA9IGluZGV4O1xuICAgICAgICByZXR1cm4gbWF0Y2hcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVTdGFydFRhZyAobWF0Y2gpIHtcbiAgICB2YXIgdGFnTmFtZSA9IG1hdGNoLnRhZ05hbWU7XG4gICAgdmFyIHVuYXJ5U2xhc2ggPSBtYXRjaC51bmFyeVNsYXNoO1xuXG4gICAgaWYgKGV4cGVjdEhUTUwpIHtcbiAgICAgIGlmIChsYXN0VGFnID09PSAncCcgJiYgaXNOb25QaHJhc2luZ1RhZyh0YWdOYW1lKSkge1xuICAgICAgICBwYXJzZUVuZFRhZyhsYXN0VGFnKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYW5CZUxlZnRPcGVuVGFnJCQxKHRhZ05hbWUpICYmIGxhc3RUYWcgPT09IHRhZ05hbWUpIHtcbiAgICAgICAgcGFyc2VFbmRUYWcodGFnTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHVuYXJ5ID0gaXNVbmFyeVRhZyQkMSh0YWdOYW1lKSB8fCAhIXVuYXJ5U2xhc2g7XG5cbiAgICB2YXIgbCA9IG1hdGNoLmF0dHJzLmxlbmd0aDtcbiAgICB2YXIgYXR0cnMgPSBuZXcgQXJyYXkobCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhcmdzID0gbWF0Y2guYXR0cnNbaV07XG4gICAgICAvLyBoYWNraXNoIHdvcmsgYXJvdW5kIEZGIGJ1ZyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0zNjk3NzhcbiAgICAgIGlmIChJU19SRUdFWF9DQVBUVVJJTkdfQlJPS0VOICYmIGFyZ3NbMF0uaW5kZXhPZignXCJcIicpID09PSAtMSkge1xuICAgICAgICBpZiAoYXJnc1szXSA9PT0gJycpIHsgZGVsZXRlIGFyZ3NbM107IH1cbiAgICAgICAgaWYgKGFyZ3NbNF0gPT09ICcnKSB7IGRlbGV0ZSBhcmdzWzRdOyB9XG4gICAgICAgIGlmIChhcmdzWzVdID09PSAnJykgeyBkZWxldGUgYXJnc1s1XTsgfVxuICAgICAgfVxuICAgICAgdmFyIHZhbHVlID0gYXJnc1szXSB8fCBhcmdzWzRdIHx8IGFyZ3NbNV0gfHwgJyc7XG4gICAgICB2YXIgc2hvdWxkRGVjb2RlTmV3bGluZXMgPSB0YWdOYW1lID09PSAnYScgJiYgYXJnc1sxXSA9PT0gJ2hyZWYnXG4gICAgICAgID8gb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWZcbiAgICAgICAgOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzO1xuICAgICAgYXR0cnNbaV0gPSB7XG4gICAgICAgIG5hbWU6IGFyZ3NbMV0sXG4gICAgICAgIHZhbHVlOiBkZWNvZGVBdHRyKHZhbHVlLCBzaG91bGREZWNvZGVOZXdsaW5lcylcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCF1bmFyeSkge1xuICAgICAgc3RhY2sucHVzaCh7IHRhZzogdGFnTmFtZSwgbG93ZXJDYXNlZFRhZzogdGFnTmFtZS50b0xvd2VyQ2FzZSgpLCBhdHRyczogYXR0cnMgfSk7XG4gICAgICBsYXN0VGFnID0gdGFnTmFtZTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBhdHRycywgdW5hcnksIG1hdGNoLnN0YXJ0LCBtYXRjaC5lbmQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRW5kVGFnICh0YWdOYW1lLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHBvcywgbG93ZXJDYXNlZFRhZ05hbWU7XG4gICAgaWYgKHN0YXJ0ID09IG51bGwpIHsgc3RhcnQgPSBpbmRleDsgfVxuICAgIGlmIChlbmQgPT0gbnVsbCkgeyBlbmQgPSBpbmRleDsgfVxuXG4gICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgIGxvd2VyQ2FzZWRUYWdOYW1lID0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3Qgb3BlbmVkIHRhZyBvZiB0aGUgc2FtZSB0eXBlXG4gICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgIGZvciAocG9zID0gc3RhY2subGVuZ3RoIC0gMTsgcG9zID49IDA7IHBvcy0tKSB7XG4gICAgICAgIGlmIChzdGFja1twb3NdLmxvd2VyQ2FzZWRUYWcgPT09IGxvd2VyQ2FzZWRUYWdOYW1lKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBubyB0YWcgbmFtZSBpcyBwcm92aWRlZCwgY2xlYW4gc2hvcFxuICAgICAgcG9zID0gMDtcbiAgICB9XG5cbiAgICBpZiAocG9zID49IDApIHtcbiAgICAgIC8vIENsb3NlIGFsbCB0aGUgb3BlbiBlbGVtZW50cywgdXAgdGhlIHN0YWNrXG4gICAgICBmb3IgKHZhciBpID0gc3RhY2subGVuZ3RoIC0gMTsgaSA+PSBwb3M7IGktLSkge1xuICAgICAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAoaSA+IHBvcyB8fCAhdGFnTmFtZSkgJiZcbiAgICAgICAgICBvcHRpb25zLndhcm5cbiAgICAgICAgKSB7XG4gICAgICAgICAgb3B0aW9ucy53YXJuKFxuICAgICAgICAgICAgKFwidGFnIDxcIiArIChzdGFja1tpXS50YWcpICsgXCI+IGhhcyBubyBtYXRjaGluZyBlbmQgdGFnLlwiKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZW5kKSB7XG4gICAgICAgICAgb3B0aW9ucy5lbmQoc3RhY2tbaV0udGFnLCBzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgdGhlIG9wZW4gZWxlbWVudHMgZnJvbSB0aGUgc3RhY2tcbiAgICAgIHN0YWNrLmxlbmd0aCA9IHBvcztcbiAgICAgIGxhc3RUYWcgPSBwb3MgJiYgc3RhY2tbcG9zIC0gMV0udGFnO1xuICAgIH0gZWxzZSBpZiAobG93ZXJDYXNlZFRhZ05hbWUgPT09ICdicicpIHtcbiAgICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgW10sIHRydWUsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobG93ZXJDYXNlZFRhZ05hbWUgPT09ICdwJykge1xuICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBbXSwgZmFsc2UsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuZW5kKSB7XG4gICAgICAgIG9wdGlvbnMuZW5kKHRhZ05hbWUsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIG9uUkUgPSAvXkB8XnYtb246LztcbnZhciBkaXJSRSA9IC9edi18XkB8XjovO1xudmFyIGZvckFsaWFzUkUgPSAvKFteXSo/KVxccysoPzppbnxvZilcXHMrKFteXSopLztcbnZhciBmb3JJdGVyYXRvclJFID0gLywoW14sXFx9XFxdXSopKD86LChbXixcXH1cXF1dKikpPyQvO1xudmFyIHN0cmlwUGFyZW5zUkUgPSAvXlxcKHxcXCkkL2c7XG5cbnZhciBhcmdSRSA9IC86KC4qKSQvO1xudmFyIGJpbmRSRSA9IC9eOnxedi1iaW5kOi87XG52YXIgbW9kaWZpZXJSRSA9IC9cXC5bXi5dKy9nO1xuXG52YXIgZGVjb2RlSFRNTENhY2hlZCA9IGNhY2hlZChoZS5kZWNvZGUpO1xuXG4vLyBjb25maWd1cmFibGUgc3RhdGVcbnZhciB3YXJuJDI7XG52YXIgZGVsaW1pdGVycztcbnZhciB0cmFuc2Zvcm1zO1xudmFyIHByZVRyYW5zZm9ybXM7XG52YXIgcG9zdFRyYW5zZm9ybXM7XG52YXIgcGxhdGZvcm1Jc1ByZVRhZztcbnZhciBwbGF0Zm9ybU11c3RVc2VQcm9wO1xudmFyIHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlO1xuXG5cblxuZnVuY3Rpb24gY3JlYXRlQVNURWxlbWVudCAoXG4gIHRhZyxcbiAgYXR0cnMsXG4gIHBhcmVudFxuKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogMSxcbiAgICB0YWc6IHRhZyxcbiAgICBhdHRyc0xpc3Q6IGF0dHJzLFxuICAgIGF0dHJzTWFwOiBtYWtlQXR0cnNNYXAoYXR0cnMpLFxuICAgIHBhcmVudDogcGFyZW50LFxuICAgIGNoaWxkcmVuOiBbXVxuICB9XG59XG5cbi8qKlxuICogQ29udmVydCBIVE1MIHN0cmluZyB0byBBU1QuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlIChcbiAgdGVtcGxhdGUsXG4gIG9wdGlvbnNcbikge1xuICB3YXJuJDIgPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG5cbiAgcGxhdGZvcm1Jc1ByZVRhZyA9IG9wdGlvbnMuaXNQcmVUYWcgfHwgbm87XG4gIHBsYXRmb3JtTXVzdFVzZVByb3AgPSBvcHRpb25zLm11c3RVc2VQcm9wIHx8IG5vO1xuICBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSA9IG9wdGlvbnMuZ2V0VGFnTmFtZXNwYWNlIHx8IG5vO1xuXG4gIHRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybU5vZGUnKTtcbiAgcHJlVHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncHJlVHJhbnNmb3JtTm9kZScpO1xuICBwb3N0VHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncG9zdFRyYW5zZm9ybU5vZGUnKTtcblxuICBkZWxpbWl0ZXJzID0gb3B0aW9ucy5kZWxpbWl0ZXJzO1xuXG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgcHJlc2VydmVXaGl0ZXNwYWNlID0gb3B0aW9ucy5wcmVzZXJ2ZVdoaXRlc3BhY2UgIT09IGZhbHNlO1xuICB2YXIgcm9vdDtcbiAgdmFyIGN1cnJlbnRQYXJlbnQ7XG4gIHZhciBpblZQcmUgPSBmYWxzZTtcbiAgdmFyIGluUHJlID0gZmFsc2U7XG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiB3YXJuT25jZSAobXNnKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICB3YXJuJDIobXNnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbG9zZUVsZW1lbnQgKGVsZW1lbnQpIHtcbiAgICAvLyBjaGVjayBwcmUgc3RhdGVcbiAgICBpZiAoZWxlbWVudC5wcmUpIHtcbiAgICAgIGluVlByZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcbiAgICAgIGluUHJlID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIGFwcGx5IHBvc3QtdHJhbnNmb3Jtc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9zdFRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBvc3RUcmFuc2Zvcm1zW2ldKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlSFRNTCh0ZW1wbGF0ZSwge1xuICAgIHdhcm46IHdhcm4kMixcbiAgICBleHBlY3RIVE1MOiBvcHRpb25zLmV4cGVjdEhUTUwsXG4gICAgaXNVbmFyeVRhZzogb3B0aW9ucy5pc1VuYXJ5VGFnLFxuICAgIGNhbkJlTGVmdE9wZW5UYWc6IG9wdGlvbnMuY2FuQmVMZWZ0T3BlblRhZyxcbiAgICBzaG91bGREZWNvZGVOZXdsaW5lczogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWY6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmLFxuICAgIHNob3VsZEtlZXBDb21tZW50OiBvcHRpb25zLmNvbW1lbnRzLFxuICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydCAodGFnLCBhdHRycywgdW5hcnkpIHtcbiAgICAgIC8vIGNoZWNrIG5hbWVzcGFjZS5cbiAgICAgIC8vIGluaGVyaXQgcGFyZW50IG5zIGlmIHRoZXJlIGlzIG9uZVxuICAgICAgdmFyIG5zID0gKGN1cnJlbnRQYXJlbnQgJiYgY3VycmVudFBhcmVudC5ucykgfHwgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UodGFnKTtcblxuICAgICAgLy8gaGFuZGxlIElFIHN2ZyBidWdcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzSUUgJiYgbnMgPT09ICdzdmcnKSB7XG4gICAgICAgIGF0dHJzID0gZ3VhcmRJRVNWR0J1ZyhhdHRycyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbGVtZW50ID0gY3JlYXRlQVNURWxlbWVudCh0YWcsIGF0dHJzLCBjdXJyZW50UGFyZW50KTtcbiAgICAgIGlmIChucykge1xuICAgICAgICBlbGVtZW50Lm5zID0gbnM7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0ZvcmJpZGRlblRhZyhlbGVtZW50KSAmJiAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSkge1xuICAgICAgICBlbGVtZW50LmZvcmJpZGRlbiA9IHRydWU7XG4gICAgICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMihcbiAgICAgICAgICAnVGVtcGxhdGVzIHNob3VsZCBvbmx5IGJlIHJlc3BvbnNpYmxlIGZvciBtYXBwaW5nIHRoZSBzdGF0ZSB0byB0aGUgJyArXG4gICAgICAgICAgJ1VJLiBBdm9pZCBwbGFjaW5nIHRhZ3Mgd2l0aCBzaWRlLWVmZmVjdHMgaW4geW91ciB0ZW1wbGF0ZXMsIHN1Y2ggYXMgJyArXG4gICAgICAgICAgXCI8XCIgKyB0YWcgKyBcIj5cIiArICcsIGFzIHRoZXkgd2lsbCBub3QgYmUgcGFyc2VkLidcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gYXBwbHkgcHJlLXRyYW5zZm9ybXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlVHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBlbGVtZW50ID0gcHJlVHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKSB8fCBlbGVtZW50O1xuICAgICAgfVxuXG4gICAgICBpZiAoIWluVlByZSkge1xuICAgICAgICBwcm9jZXNzUHJlKGVsZW1lbnQpO1xuICAgICAgICBpZiAoZWxlbWVudC5wcmUpIHtcbiAgICAgICAgICBpblZQcmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcbiAgICAgICAgaW5QcmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGluVlByZSkge1xuICAgICAgICBwcm9jZXNzUmF3QXR0cnMoZWxlbWVudCk7XG4gICAgICB9IGVsc2UgaWYgKCFlbGVtZW50LnByb2Nlc3NlZCkge1xuICAgICAgICAvLyBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZXNcbiAgICAgICAgcHJvY2Vzc0ZvcihlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc0lmKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzT25jZShlbGVtZW50KTtcbiAgICAgICAgLy8gZWxlbWVudC1zY29wZSBzdHVmZlxuICAgICAgICBwcm9jZXNzRWxlbWVudChlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2hlY2tSb290Q29uc3RyYWludHMgKGVsKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoZWwudGFnID09PSAnc2xvdCcgfHwgZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgXCJDYW5ub3QgdXNlIDxcIiArIChlbC50YWcpICsgXCI+IGFzIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSBpdCBtYXkgXCIgK1xuICAgICAgICAgICAgICAnY29udGFpbiBtdWx0aXBsZSBub2Rlcy4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZWwuYXR0cnNNYXAuaGFzT3duUHJvcGVydHkoJ3YtZm9yJykpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAnQ2Fubm90IHVzZSB2LWZvciBvbiBzdGF0ZWZ1bCBjb21wb25lbnQgcm9vdCBlbGVtZW50IGJlY2F1c2UgJyArXG4gICAgICAgICAgICAgICdpdCByZW5kZXJzIG11bHRpcGxlIGVsZW1lbnRzLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHRyZWUgbWFuYWdlbWVudFxuICAgICAgaWYgKCFyb290KSB7XG4gICAgICAgIHJvb3QgPSBlbGVtZW50O1xuICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhyb290KTtcbiAgICAgIH0gZWxzZSBpZiAoIXN0YWNrLmxlbmd0aCkge1xuICAgICAgICAvLyBhbGxvdyByb290IGVsZW1lbnRzIHdpdGggdi1pZiwgdi1lbHNlLWlmIGFuZCB2LWVsc2VcbiAgICAgICAgaWYgKHJvb3QuaWYgJiYgKGVsZW1lbnQuZWxzZWlmIHx8IGVsZW1lbnQuZWxzZSkpIHtcbiAgICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhlbGVtZW50KTtcbiAgICAgICAgICBhZGRJZkNvbmRpdGlvbihyb290LCB7XG4gICAgICAgICAgICBleHA6IGVsZW1lbnQuZWxzZWlmLFxuICAgICAgICAgICAgYmxvY2s6IGVsZW1lbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgIFwiQ29tcG9uZW50IHRlbXBsYXRlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIHJvb3QgZWxlbWVudC4gXCIgK1xuICAgICAgICAgICAgXCJJZiB5b3UgYXJlIHVzaW5nIHYtaWYgb24gbXVsdGlwbGUgZWxlbWVudHMsIFwiICtcbiAgICAgICAgICAgIFwidXNlIHYtZWxzZS1pZiB0byBjaGFpbiB0aGVtIGluc3RlYWQuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudFBhcmVudCAmJiAhZWxlbWVudC5mb3JiaWRkZW4pIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuZWxzZWlmIHx8IGVsZW1lbnQuZWxzZSkge1xuICAgICAgICAgIHByb2Nlc3NJZkNvbmRpdGlvbnMoZWxlbWVudCwgY3VycmVudFBhcmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5zbG90U2NvcGUpIHsgLy8gc2NvcGVkIHNsb3RcbiAgICAgICAgICBjdXJyZW50UGFyZW50LnBsYWluID0gZmFsc2U7XG4gICAgICAgICAgdmFyIG5hbWUgPSBlbGVtZW50LnNsb3RUYXJnZXQgfHwgJ1wiZGVmYXVsdFwiJzsoY3VycmVudFBhcmVudC5zY29wZWRTbG90cyB8fCAoY3VycmVudFBhcmVudC5zY29wZWRTbG90cyA9IHt9KSlbbmFtZV0gPSBlbGVtZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnRQYXJlbnQuY2hpbGRyZW4ucHVzaChlbGVtZW50KTtcbiAgICAgICAgICBlbGVtZW50LnBhcmVudCA9IGN1cnJlbnRQYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghdW5hcnkpIHtcbiAgICAgICAgY3VycmVudFBhcmVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHN0YWNrLnB1c2goZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbG9zZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGVuZDogZnVuY3Rpb24gZW5kICgpIHtcbiAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlXG4gICAgICB2YXIgZWxlbWVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgdmFyIGxhc3ROb2RlID0gZWxlbWVudC5jaGlsZHJlbltlbGVtZW50LmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGxhc3ROb2RlICYmIGxhc3ROb2RlLnR5cGUgPT09IDMgJiYgbGFzdE5vZGUudGV4dCA9PT0gJyAnICYmICFpblByZSkge1xuICAgICAgICBlbGVtZW50LmNoaWxkcmVuLnBvcCgpO1xuICAgICAgfVxuICAgICAgLy8gcG9wIHN0YWNrXG4gICAgICBzdGFjay5sZW5ndGggLT0gMTtcbiAgICAgIGN1cnJlbnRQYXJlbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIGNsb3NlRWxlbWVudChlbGVtZW50KTtcbiAgICB9LFxuXG4gICAgY2hhcnM6IGZ1bmN0aW9uIGNoYXJzICh0ZXh0KSB7XG4gICAgICBpZiAoIWN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAge1xuICAgICAgICAgIGlmICh0ZXh0ID09PSB0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgICdDb21wb25lbnQgdGVtcGxhdGUgcmVxdWlyZXMgYSByb290IGVsZW1lbnQsIHJhdGhlciB0aGFuIGp1c3QgdGV4dC4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoKHRleHQgPSB0ZXh0LnRyaW0oKSkpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAoXCJ0ZXh0IFxcXCJcIiArIHRleHQgKyBcIlxcXCIgb3V0c2lkZSByb290IGVsZW1lbnQgd2lsbCBiZSBpZ25vcmVkLlwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvLyBJRSB0ZXh0YXJlYSBwbGFjZWhvbGRlciBidWdcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzSUUgJiZcbiAgICAgICAgY3VycmVudFBhcmVudC50YWcgPT09ICd0ZXh0YXJlYScgJiZcbiAgICAgICAgY3VycmVudFBhcmVudC5hdHRyc01hcC5wbGFjZWhvbGRlciA9PT0gdGV4dFxuICAgICAgKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdmFyIGNoaWxkcmVuID0gY3VycmVudFBhcmVudC5jaGlsZHJlbjtcbiAgICAgIHRleHQgPSBpblByZSB8fCB0ZXh0LnRyaW0oKVxuICAgICAgICA/IGlzVGV4dFRhZyhjdXJyZW50UGFyZW50KSA/IHRleHQgOiBkZWNvZGVIVE1MQ2FjaGVkKHRleHQpXG4gICAgICAgIC8vIG9ubHkgcHJlc2VydmUgd2hpdGVzcGFjZSBpZiBpdHMgbm90IHJpZ2h0IGFmdGVyIGEgc3RhcnRpbmcgdGFnXG4gICAgICAgIDogcHJlc2VydmVXaGl0ZXNwYWNlICYmIGNoaWxkcmVuLmxlbmd0aCA/ICcgJyA6ICcnO1xuICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgdmFyIHJlcztcbiAgICAgICAgaWYgKCFpblZQcmUgJiYgdGV4dCAhPT0gJyAnICYmIChyZXMgPSBwYXJzZVRleHQodGV4dCwgZGVsaW1pdGVycykpKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAyLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogcmVzLmV4cHJlc3Npb24sXG4gICAgICAgICAgICB0b2tlbnM6IHJlcy50b2tlbnMsXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGV4dCAhPT0gJyAnIHx8ICFjaGlsZHJlbi5sZW5ndGggfHwgY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0udGV4dCAhPT0gJyAnKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAzLFxuICAgICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBjb21tZW50OiBmdW5jdGlvbiBjb21tZW50ICh0ZXh0KSB7XG4gICAgICBjdXJyZW50UGFyZW50LmNoaWxkcmVuLnB1c2goe1xuICAgICAgICB0eXBlOiAzLFxuICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICBpc0NvbW1lbnQ6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByb290XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NQcmUgKGVsKSB7XG4gIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1wcmUnKSAhPSBudWxsKSB7XG4gICAgZWwucHJlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUmF3QXR0cnMgKGVsKSB7XG4gIHZhciBsID0gZWwuYXR0cnNMaXN0Lmxlbmd0aDtcbiAgaWYgKGwpIHtcbiAgICB2YXIgYXR0cnMgPSBlbC5hdHRycyA9IG5ldyBBcnJheShsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgYXR0cnNbaV0gPSB7XG4gICAgICAgIG5hbWU6IGVsLmF0dHJzTGlzdFtpXS5uYW1lLFxuICAgICAgICB2YWx1ZTogSlNPTi5zdHJpbmdpZnkoZWwuYXR0cnNMaXN0W2ldLnZhbHVlKVxuICAgICAgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWVsLnByZSkge1xuICAgIC8vIG5vbiByb290IG5vZGUgaW4gcHJlIGJsb2NrcyB3aXRoIG5vIGF0dHJpYnV0ZXNcbiAgICBlbC5wbGFpbiA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0VsZW1lbnQgKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgcHJvY2Vzc0tleShlbGVtZW50KTtcblxuICAvLyBkZXRlcm1pbmUgd2hldGhlciB0aGlzIGlzIGEgcGxhaW4gZWxlbWVudCBhZnRlclxuICAvLyByZW1vdmluZyBzdHJ1Y3R1cmFsIGF0dHJpYnV0ZXNcbiAgZWxlbWVudC5wbGFpbiA9ICFlbGVtZW50LmtleSAmJiAhZWxlbWVudC5hdHRyc0xpc3QubGVuZ3RoO1xuXG4gIHByb2Nlc3NSZWYoZWxlbWVudCk7XG4gIHByb2Nlc3NTbG90KGVsZW1lbnQpO1xuICBwcm9jZXNzQ29tcG9uZW50KGVsZW1lbnQpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICBlbGVtZW50ID0gdHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKSB8fCBlbGVtZW50O1xuICB9XG4gIHByb2Nlc3NBdHRycyhlbGVtZW50KTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0tleSAoZWwpIHtcbiAgdmFyIGV4cCA9IGdldEJpbmRpbmdBdHRyKGVsLCAna2V5Jyk7XG4gIGlmIChleHApIHtcbiAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICB3YXJuJDIoXCI8dGVtcGxhdGU+IGNhbm5vdCBiZSBrZXllZC4gUGxhY2UgdGhlIGtleSBvbiByZWFsIGVsZW1lbnRzIGluc3RlYWQuXCIpO1xuICAgIH1cbiAgICBlbC5rZXkgPSBleHA7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1JlZiAoZWwpIHtcbiAgdmFyIHJlZiA9IGdldEJpbmRpbmdBdHRyKGVsLCAncmVmJyk7XG4gIGlmIChyZWYpIHtcbiAgICBlbC5yZWYgPSByZWY7XG4gICAgZWwucmVmSW5Gb3IgPSBjaGVja0luRm9yKGVsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzRm9yIChlbCkge1xuICB2YXIgZXhwO1xuICBpZiAoKGV4cCA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWZvcicpKSkge1xuICAgIHZhciByZXMgPSBwYXJzZUZvcihleHApO1xuICAgIGlmIChyZXMpIHtcbiAgICAgIGV4dGVuZChlbCwgcmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybiQyKFxuICAgICAgICAoXCJJbnZhbGlkIHYtZm9yIGV4cHJlc3Npb246IFwiICsgZXhwKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuXG5cbmZ1bmN0aW9uIHBhcnNlRm9yIChleHApIHtcbiAgdmFyIGluTWF0Y2ggPSBleHAubWF0Y2goZm9yQWxpYXNSRSk7XG4gIGlmICghaW5NYXRjaCkgeyByZXR1cm4gfVxuICB2YXIgcmVzID0ge307XG4gIHJlcy5mb3IgPSBpbk1hdGNoWzJdLnRyaW0oKTtcbiAgdmFyIGFsaWFzID0gaW5NYXRjaFsxXS50cmltKCkucmVwbGFjZShzdHJpcFBhcmVuc1JFLCAnJyk7XG4gIHZhciBpdGVyYXRvck1hdGNoID0gYWxpYXMubWF0Y2goZm9ySXRlcmF0b3JSRSk7XG4gIGlmIChpdGVyYXRvck1hdGNoKSB7XG4gICAgcmVzLmFsaWFzID0gYWxpYXMucmVwbGFjZShmb3JJdGVyYXRvclJFLCAnJyk7XG4gICAgcmVzLml0ZXJhdG9yMSA9IGl0ZXJhdG9yTWF0Y2hbMV0udHJpbSgpO1xuICAgIGlmIChpdGVyYXRvck1hdGNoWzJdKSB7XG4gICAgICByZXMuaXRlcmF0b3IyID0gaXRlcmF0b3JNYXRjaFsyXS50cmltKCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlcy5hbGlhcyA9IGFsaWFzO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0lmIChlbCkge1xuICB2YXIgZXhwID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtaWYnKTtcbiAgaWYgKGV4cCkge1xuICAgIGVsLmlmID0gZXhwO1xuICAgIGFkZElmQ29uZGl0aW9uKGVsLCB7XG4gICAgICBleHA6IGV4cCxcbiAgICAgIGJsb2NrOiBlbFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlJykgIT0gbnVsbCkge1xuICAgICAgZWwuZWxzZSA9IHRydWU7XG4gICAgfVxuICAgIHZhciBlbHNlaWYgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlLWlmJyk7XG4gICAgaWYgKGVsc2VpZikge1xuICAgICAgZWwuZWxzZWlmID0gZWxzZWlmO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzSWZDb25kaXRpb25zIChlbCwgcGFyZW50KSB7XG4gIHZhciBwcmV2ID0gZmluZFByZXZFbGVtZW50KHBhcmVudC5jaGlsZHJlbik7XG4gIGlmIChwcmV2ICYmIHByZXYuaWYpIHtcbiAgICBhZGRJZkNvbmRpdGlvbihwcmV2LCB7XG4gICAgICBleHA6IGVsLmVsc2VpZixcbiAgICAgIGJsb2NrOiBlbFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHdhcm4kMihcbiAgICAgIFwidi1cIiArIChlbC5lbHNlaWYgPyAoJ2Vsc2UtaWY9XCInICsgZWwuZWxzZWlmICsgJ1wiJykgOiAnZWxzZScpICsgXCIgXCIgK1xuICAgICAgXCJ1c2VkIG9uIGVsZW1lbnQgPFwiICsgKGVsLnRhZykgKyBcIj4gd2l0aG91dCBjb3JyZXNwb25kaW5nIHYtaWYuXCJcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRQcmV2RWxlbWVudCAoY2hpbGRyZW4pIHtcbiAgdmFyIGkgPSBjaGlsZHJlbi5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAoY2hpbGRyZW5baV0udHlwZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGNoaWxkcmVuW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBjaGlsZHJlbltpXS50ZXh0ICE9PSAnICcpIHtcbiAgICAgICAgd2FybiQyKFxuICAgICAgICAgIFwidGV4dCBcXFwiXCIgKyAoY2hpbGRyZW5baV0udGV4dC50cmltKCkpICsgXCJcXFwiIGJldHdlZW4gdi1pZiBhbmQgdi1lbHNlKC1pZikgXCIgK1xuICAgICAgICAgIFwid2lsbCBiZSBpZ25vcmVkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjaGlsZHJlbi5wb3AoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkSWZDb25kaXRpb24gKGVsLCBjb25kaXRpb24pIHtcbiAgaWYgKCFlbC5pZkNvbmRpdGlvbnMpIHtcbiAgICBlbC5pZkNvbmRpdGlvbnMgPSBbXTtcbiAgfVxuICBlbC5pZkNvbmRpdGlvbnMucHVzaChjb25kaXRpb24pO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzT25jZSAoZWwpIHtcbiAgdmFyIG9uY2UkJDEgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1vbmNlJyk7XG4gIGlmIChvbmNlJCQxICE9IG51bGwpIHtcbiAgICBlbC5vbmNlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzU2xvdCAoZWwpIHtcbiAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgZWwuc2xvdE5hbWUgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ25hbWUnKTtcbiAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgZWwua2V5KSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIFwiYGtleWAgZG9lcyBub3Qgd29yayBvbiA8c2xvdD4gYmVjYXVzZSBzbG90cyBhcmUgYWJzdHJhY3Qgb3V0bGV0cyBcIiArXG4gICAgICAgIFwiYW5kIGNhbiBwb3NzaWJseSBleHBhbmQgaW50byBtdWx0aXBsZSBlbGVtZW50cy4gXCIgK1xuICAgICAgICBcIlVzZSB0aGUga2V5IG9uIGEgd3JhcHBpbmcgZWxlbWVudCBpbnN0ZWFkLlwiXG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xvdFNjb3BlO1xuICAgIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIHNsb3RTY29wZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzY29wZScpO1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgc2xvdFNjb3BlKSB7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICBcInRoZSBcXFwic2NvcGVcXFwiIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIHNsb3RzIGhhdmUgYmVlbiBkZXByZWNhdGVkIGFuZCBcIiArXG4gICAgICAgICAgXCJyZXBsYWNlZCBieSBcXFwic2xvdC1zY29wZVxcXCIgc2luY2UgMi41LiBUaGUgbmV3IFxcXCJzbG90LXNjb3BlXFxcIiBhdHRyaWJ1dGUgXCIgK1xuICAgICAgICAgIFwiY2FuIGFsc28gYmUgdXNlZCBvbiBwbGFpbiBlbGVtZW50cyBpbiBhZGRpdGlvbiB0byA8dGVtcGxhdGU+IHRvIFwiICtcbiAgICAgICAgICBcImRlbm90ZSBzY29wZWQgc2xvdHMuXCIsXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZWwuc2xvdFNjb3BlID0gc2xvdFNjb3BlIHx8IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzbG90LXNjb3BlJyk7XG4gICAgfSBlbHNlIGlmICgoc2xvdFNjb3BlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Nsb3Qtc2NvcGUnKSkpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGVsLmF0dHJzTWFwWyd2LWZvciddKSB7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICBcIkFtYmlndW91cyBjb21iaW5lZCB1c2FnZSBvZiBzbG90LXNjb3BlIGFuZCB2LWZvciBvbiA8XCIgKyAoZWwudGFnKSArIFwiPiBcIiArXG4gICAgICAgICAgXCIodi1mb3IgdGFrZXMgaGlnaGVyIHByaW9yaXR5KS4gVXNlIGEgd3JhcHBlciA8dGVtcGxhdGU+IGZvciB0aGUgXCIgK1xuICAgICAgICAgIFwic2NvcGVkIHNsb3QgdG8gbWFrZSBpdCBjbGVhcmVyLlwiLFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGVsLnNsb3RTY29wZSA9IHNsb3RTY29wZTtcbiAgICB9XG4gICAgdmFyIHNsb3RUYXJnZXQgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3Nsb3QnKTtcbiAgICBpZiAoc2xvdFRhcmdldCkge1xuICAgICAgZWwuc2xvdFRhcmdldCA9IHNsb3RUYXJnZXQgPT09ICdcIlwiJyA/ICdcImRlZmF1bHRcIicgOiBzbG90VGFyZ2V0O1xuICAgICAgLy8gcHJlc2VydmUgc2xvdCBhcyBhbiBhdHRyaWJ1dGUgZm9yIG5hdGl2ZSBzaGFkb3cgRE9NIGNvbXBhdFxuICAgICAgLy8gb25seSBmb3Igbm9uLXNjb3BlZCBzbG90cy5cbiAgICAgIGlmIChlbC50YWcgIT09ICd0ZW1wbGF0ZScgJiYgIWVsLnNsb3RTY29wZSkge1xuICAgICAgICBhZGRBdHRyKGVsLCAnc2xvdCcsIHNsb3RUYXJnZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzQ29tcG9uZW50IChlbCkge1xuICB2YXIgYmluZGluZztcbiAgaWYgKChiaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdpcycpKSkge1xuICAgIGVsLmNvbXBvbmVudCA9IGJpbmRpbmc7XG4gIH1cbiAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICdpbmxpbmUtdGVtcGxhdGUnKSAhPSBudWxsKSB7XG4gICAgZWwuaW5saW5lVGVtcGxhdGUgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NBdHRycyAoZWwpIHtcbiAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gIHZhciBpLCBsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBpc1Byb3A7XG4gIGZvciAoaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG5hbWUgPSByYXdOYW1lID0gbGlzdFtpXS5uYW1lO1xuICAgIHZhbHVlID0gbGlzdFtpXS52YWx1ZTtcbiAgICBpZiAoZGlyUkUudGVzdChuYW1lKSkge1xuICAgICAgLy8gbWFyayBlbGVtZW50IGFzIGR5bmFtaWNcbiAgICAgIGVsLmhhc0JpbmRpbmdzID0gdHJ1ZTtcbiAgICAgIC8vIG1vZGlmaWVyc1xuICAgICAgbW9kaWZpZXJzID0gcGFyc2VNb2RpZmllcnMobmFtZSk7XG4gICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UobW9kaWZpZXJSRSwgJycpO1xuICAgICAgfVxuICAgICAgaWYgKGJpbmRSRS50ZXN0KG5hbWUpKSB7IC8vIHYtYmluZFxuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGJpbmRSRSwgJycpO1xuICAgICAgICB2YWx1ZSA9IHBhcnNlRmlsdGVycyh2YWx1ZSk7XG4gICAgICAgIGlzUHJvcCA9IGZhbHNlO1xuICAgICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5wcm9wKSB7XG4gICAgICAgICAgICBpc1Byb3AgPSB0cnVlO1xuICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdpbm5lckh0bWwnKSB7IG5hbWUgPSAnaW5uZXJIVE1MJzsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW9kaWZpZXJzLmNhbWVsKSB7XG4gICAgICAgICAgICBuYW1lID0gY2FtZWxpemUobmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtb2RpZmllcnMuc3luYykge1xuICAgICAgICAgICAgYWRkSGFuZGxlcihcbiAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgIChcInVwZGF0ZTpcIiArIChjYW1lbGl6ZShuYW1lKSkpLFxuICAgICAgICAgICAgICBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgXCIkZXZlbnRcIilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Byb3AgfHwgKFxuICAgICAgICAgICFlbC5jb21wb25lbnQgJiYgcGxhdGZvcm1NdXN0VXNlUHJvcChlbC50YWcsIGVsLmF0dHJzTWFwLnR5cGUsIG5hbWUpXG4gICAgICAgICkpIHtcbiAgICAgICAgICBhZGRQcm9wKGVsLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkQXR0cihlbCwgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkgeyAvLyB2LW9uXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2Uob25SRSwgJycpO1xuICAgICAgICBhZGRIYW5kbGVyKGVsLCBuYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBmYWxzZSwgd2FybiQyKTtcbiAgICAgIH0gZWxzZSB7IC8vIG5vcm1hbCBkaXJlY3RpdmVzXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoZGlyUkUsICcnKTtcbiAgICAgICAgLy8gcGFyc2UgYXJnXG4gICAgICAgIHZhciBhcmdNYXRjaCA9IG5hbWUubWF0Y2goYXJnUkUpO1xuICAgICAgICB2YXIgYXJnID0gYXJnTWF0Y2ggJiYgYXJnTWF0Y2hbMV07XG4gICAgICAgIGlmIChhcmcpIHtcbiAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgwLCAtKGFyZy5sZW5ndGggKyAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkRGlyZWN0aXZlKGVsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgYXJnLCBtb2RpZmllcnMpO1xuICAgICAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgbmFtZSA9PT0gJ21vZGVsJykge1xuICAgICAgICAgIGNoZWNrRm9yQWxpYXNNb2RlbChlbCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGxpdGVyYWwgYXR0cmlidXRlXG4gICAgICB7XG4gICAgICAgIHZhciByZXMgPSBwYXJzZVRleHQodmFsdWUsIGRlbGltaXRlcnMpO1xuICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgbmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiOiBcIiArXG4gICAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBpZD1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOmlkPVwidmFsXCI+LidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhZGRBdHRyKGVsLCBuYW1lLCBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgICAgLy8gIzY4ODcgZmlyZWZveCBkb2Vzbid0IHVwZGF0ZSBtdXRlZCBzdGF0ZSBpZiBzZXQgdmlhIGF0dHJpYnV0ZVxuICAgICAgLy8gZXZlbiBpbW1lZGlhdGVseSBhZnRlciBlbGVtZW50IGNyZWF0aW9uXG4gICAgICBpZiAoIWVsLmNvbXBvbmVudCAmJlxuICAgICAgICAgIG5hbWUgPT09ICdtdXRlZCcgJiZcbiAgICAgICAgICBwbGF0Zm9ybU11c3RVc2VQcm9wKGVsLnRhZywgZWwuYXR0cnNNYXAudHlwZSwgbmFtZSkpIHtcbiAgICAgICAgYWRkUHJvcChlbCwgbmFtZSwgJ3RydWUnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tJbkZvciAoZWwpIHtcbiAgdmFyIHBhcmVudCA9IGVsO1xuICB3aGlsZSAocGFyZW50KSB7XG4gICAgaWYgKHBhcmVudC5mb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcGFyc2VNb2RpZmllcnMgKG5hbWUpIHtcbiAgdmFyIG1hdGNoID0gbmFtZS5tYXRjaChtb2RpZmllclJFKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgdmFyIHJldCA9IHt9O1xuICAgIG1hdGNoLmZvckVhY2goZnVuY3Rpb24gKG0pIHsgcmV0W20uc2xpY2UoMSldID0gdHJ1ZTsgfSk7XG4gICAgcmV0dXJuIHJldFxuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VBdHRyc01hcCAoYXR0cnMpIHtcbiAgdmFyIG1hcCA9IHt9O1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChcbiAgICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBtYXBbYXR0cnNbaV0ubmFtZV0gJiYgIWlzSUUgJiYgIWlzRWRnZVxuICAgICkge1xuICAgICAgd2FybiQyKCdkdXBsaWNhdGUgYXR0cmlidXRlOiAnICsgYXR0cnNbaV0ubmFtZSk7XG4gICAgfVxuICAgIG1hcFthdHRyc1tpXS5uYW1lXSA9IGF0dHJzW2ldLnZhbHVlO1xuICB9XG4gIHJldHVybiBtYXBcbn1cblxuLy8gZm9yIHNjcmlwdCAoZS5nLiB0eXBlPVwieC90ZW1wbGF0ZVwiKSBvciBzdHlsZSwgZG8gbm90IGRlY29kZSBjb250ZW50XG5mdW5jdGlvbiBpc1RleHRUYWcgKGVsKSB7XG4gIHJldHVybiBlbC50YWcgPT09ICdzY3JpcHQnIHx8IGVsLnRhZyA9PT0gJ3N0eWxlJ1xufVxuXG5mdW5jdGlvbiBpc0ZvcmJpZGRlblRhZyAoZWwpIHtcbiAgcmV0dXJuIChcbiAgICBlbC50YWcgPT09ICdzdHlsZScgfHxcbiAgICAoZWwudGFnID09PSAnc2NyaXB0JyAmJiAoXG4gICAgICAhZWwuYXR0cnNNYXAudHlwZSB8fFxuICAgICAgZWwuYXR0cnNNYXAudHlwZSA9PT0gJ3RleHQvamF2YXNjcmlwdCdcbiAgICApKVxuICApXG59XG5cbnZhciBpZU5TQnVnID0gL154bWxuczpOU1xcZCsvO1xudmFyIGllTlNQcmVmaXggPSAvXk5TXFxkKzovO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gZ3VhcmRJRVNWR0J1ZyAoYXR0cnMpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGF0dHIgPSBhdHRyc1tpXTtcbiAgICBpZiAoIWllTlNCdWcudGVzdChhdHRyLm5hbWUpKSB7XG4gICAgICBhdHRyLm5hbWUgPSBhdHRyLm5hbWUucmVwbGFjZShpZU5TUHJlZml4LCAnJyk7XG4gICAgICByZXMucHVzaChhdHRyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBjaGVja0ZvckFsaWFzTW9kZWwgKGVsLCB2YWx1ZSkge1xuICB2YXIgX2VsID0gZWw7XG4gIHdoaWxlIChfZWwpIHtcbiAgICBpZiAoX2VsLmZvciAmJiBfZWwuYWxpYXMgPT09IHZhbHVlKSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiPjogXCIgK1xuICAgICAgICBcIllvdSBhcmUgYmluZGluZyB2LW1vZGVsIGRpcmVjdGx5IHRvIGEgdi1mb3IgaXRlcmF0aW9uIGFsaWFzLiBcIiArXG4gICAgICAgIFwiVGhpcyB3aWxsIG5vdCBiZSBhYmxlIHRvIG1vZGlmeSB0aGUgdi1mb3Igc291cmNlIGFycmF5IGJlY2F1c2UgXCIgK1xuICAgICAgICBcIndyaXRpbmcgdG8gdGhlIGFsaWFzIGlzIGxpa2UgbW9kaWZ5aW5nIGEgZnVuY3Rpb24gbG9jYWwgdmFyaWFibGUuIFwiICtcbiAgICAgICAgXCJDb25zaWRlciB1c2luZyBhbiBhcnJheSBvZiBvYmplY3RzIGFuZCB1c2Ugdi1tb2RlbCBvbiBhbiBvYmplY3QgcHJvcGVydHkgaW5zdGVhZC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgX2VsID0gX2VsLnBhcmVudDtcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBFeHBhbmQgaW5wdXRbdi1tb2RlbF0gd2l0aCBkeWFubWljIHR5cGUgYmluZGluZ3MgaW50byB2LWlmLWVsc2UgY2hhaW5zXG4gKiBUdXJuIHRoaXM6XG4gKiAgIDxpbnB1dCB2LW1vZGVsPVwiZGF0YVt0eXBlXVwiIDp0eXBlPVwidHlwZVwiPlxuICogaW50byB0aGlzOlxuICogICA8aW5wdXQgdi1pZj1cInR5cGUgPT09ICdjaGVja2JveCdcIiB0eXBlPVwiY2hlY2tib3hcIiB2LW1vZGVsPVwiZGF0YVt0eXBlXVwiPlxuICogICA8aW5wdXQgdi1lbHNlLWlmPVwidHlwZSA9PT0gJ3JhZGlvJ1wiIHR5cGU9XCJyYWRpb1wiIHYtbW9kZWw9XCJkYXRhW3R5cGVdXCI+XG4gKiAgIDxpbnB1dCB2LWVsc2UgOnR5cGU9XCJ0eXBlXCIgdi1tb2RlbD1cImRhdGFbdHlwZV1cIj5cbiAqL1xuXG5mdW5jdGlvbiBwcmVUcmFuc2Zvcm1Ob2RlIChlbCwgb3B0aW9ucykge1xuICBpZiAoZWwudGFnID09PSAnaW5wdXQnKSB7XG4gICAgdmFyIG1hcCA9IGVsLmF0dHJzTWFwO1xuICAgIGlmICghbWFwWyd2LW1vZGVsJ10pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciB0eXBlQmluZGluZztcbiAgICBpZiAobWFwWyc6dHlwZSddIHx8IG1hcFsndi1iaW5kOnR5cGUnXSkge1xuICAgICAgdHlwZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3R5cGUnKTtcbiAgICB9XG4gICAgaWYgKCFtYXAudHlwZSAmJiAhdHlwZUJpbmRpbmcgJiYgbWFwWyd2LWJpbmQnXSkge1xuICAgICAgdHlwZUJpbmRpbmcgPSBcIihcIiArIChtYXBbJ3YtYmluZCddKSArIFwiKS50eXBlXCI7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVCaW5kaW5nKSB7XG4gICAgICB2YXIgaWZDb25kaXRpb24gPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1pZicsIHRydWUpO1xuICAgICAgdmFyIGlmQ29uZGl0aW9uRXh0cmEgPSBpZkNvbmRpdGlvbiA/IChcIiYmKFwiICsgaWZDb25kaXRpb24gKyBcIilcIikgOiBcIlwiO1xuICAgICAgdmFyIGhhc0Vsc2UgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlJywgdHJ1ZSkgIT0gbnVsbDtcbiAgICAgIHZhciBlbHNlSWZDb25kaXRpb24gPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlLWlmJywgdHJ1ZSk7XG4gICAgICAvLyAxLiBjaGVja2JveFxuICAgICAgdmFyIGJyYW5jaDAgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgLy8gcHJvY2VzcyBmb3Igb24gdGhlIG1haW4gbm9kZVxuICAgICAgcHJvY2Vzc0ZvcihicmFuY2gwKTtcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMCwgJ3R5cGUnLCAnY2hlY2tib3gnKTtcbiAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDAsIG9wdGlvbnMpO1xuICAgICAgYnJhbmNoMC5wcm9jZXNzZWQgPSB0cnVlOyAvLyBwcmV2ZW50IGl0IGZyb20gZG91YmxlLXByb2Nlc3NlZFxuICAgICAgYnJhbmNoMC5pZiA9IFwiKFwiICsgdHlwZUJpbmRpbmcgKyBcIik9PT0nY2hlY2tib3gnXCIgKyBpZkNvbmRpdGlvbkV4dHJhO1xuICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICBleHA6IGJyYW5jaDAuaWYsXG4gICAgICAgIGJsb2NrOiBicmFuY2gwXG4gICAgICB9KTtcbiAgICAgIC8vIDIuIGFkZCByYWRpbyBlbHNlLWlmIGNvbmRpdGlvblxuICAgICAgdmFyIGJyYW5jaDEgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgZ2V0QW5kUmVtb3ZlQXR0cihicmFuY2gxLCAndi1mb3InLCB0cnVlKTtcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMSwgJ3R5cGUnLCAncmFkaW8nKTtcbiAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDEsIG9wdGlvbnMpO1xuICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICBleHA6IFwiKFwiICsgdHlwZUJpbmRpbmcgKyBcIik9PT0ncmFkaW8nXCIgKyBpZkNvbmRpdGlvbkV4dHJhLFxuICAgICAgICBibG9jazogYnJhbmNoMVxuICAgICAgfSk7XG4gICAgICAvLyAzLiBvdGhlclxuICAgICAgdmFyIGJyYW5jaDIgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgZ2V0QW5kUmVtb3ZlQXR0cihicmFuY2gyLCAndi1mb3InLCB0cnVlKTtcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMiwgJzp0eXBlJywgdHlwZUJpbmRpbmcpO1xuICAgICAgcHJvY2Vzc0VsZW1lbnQoYnJhbmNoMiwgb3B0aW9ucyk7XG4gICAgICBhZGRJZkNvbmRpdGlvbihicmFuY2gwLCB7XG4gICAgICAgIGV4cDogaWZDb25kaXRpb24sXG4gICAgICAgIGJsb2NrOiBicmFuY2gyXG4gICAgICB9KTtcblxuICAgICAgaWYgKGhhc0Vsc2UpIHtcbiAgICAgICAgYnJhbmNoMC5lbHNlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZWxzZUlmQ29uZGl0aW9uKSB7XG4gICAgICAgIGJyYW5jaDAuZWxzZWlmID0gZWxzZUlmQ29uZGl0aW9uO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYnJhbmNoMFxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjbG9uZUFTVEVsZW1lbnQgKGVsKSB7XG4gIHJldHVybiBjcmVhdGVBU1RFbGVtZW50KGVsLnRhZywgZWwuYXR0cnNMaXN0LnNsaWNlKCksIGVsLnBhcmVudClcbn1cblxudmFyIG1vZGVsJDIgPSB7XG4gIHByZVRyYW5zZm9ybU5vZGU6IHByZVRyYW5zZm9ybU5vZGVcbn1cblxudmFyIG1vZHVsZXMkMSA9IFtcbiAga2xhc3MkMSxcbiAgc3R5bGUkMSxcbiAgbW9kZWwkMlxuXVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdGV4dCAoZWwsIGRpcikge1xuICBpZiAoZGlyLnZhbHVlKSB7XG4gICAgYWRkUHJvcChlbCwgJ3RleHRDb250ZW50JywgKFwiX3MoXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKSk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGh0bWwgKGVsLCBkaXIpIHtcbiAgaWYgKGRpci52YWx1ZSkge1xuICAgIGFkZFByb3AoZWwsICdpbm5lckhUTUwnLCAoXCJfcyhcIiArIChkaXIudmFsdWUpICsgXCIpXCIpKTtcbiAgfVxufVxuXG52YXIgZGlyZWN0aXZlcyQxID0ge1xuICBtb2RlbDogbW9kZWwsXG4gIHRleHQ6IHRleHQsXG4gIGh0bWw6IGh0bWxcbn1cblxuLyogICovXG5cbnZhciBiYXNlT3B0aW9ucyA9IHtcbiAgZXhwZWN0SFRNTDogdHJ1ZSxcbiAgbW9kdWxlczogbW9kdWxlcyQxLFxuICBkaXJlY3RpdmVzOiBkaXJlY3RpdmVzJDEsXG4gIGlzUHJlVGFnOiBpc1ByZVRhZyxcbiAgaXNVbmFyeVRhZzogaXNVbmFyeVRhZyxcbiAgbXVzdFVzZVByb3A6IG11c3RVc2VQcm9wLFxuICBjYW5CZUxlZnRPcGVuVGFnOiBjYW5CZUxlZnRPcGVuVGFnLFxuICBpc1Jlc2VydmVkVGFnOiBpc1Jlc2VydmVkVGFnLFxuICBnZXRUYWdOYW1lc3BhY2U6IGdldFRhZ05hbWVzcGFjZSxcbiAgc3RhdGljS2V5czogZ2VuU3RhdGljS2V5cyhtb2R1bGVzJDEpXG59O1xuXG4vKiAgKi9cblxudmFyIGlzU3RhdGljS2V5O1xudmFyIGlzUGxhdGZvcm1SZXNlcnZlZFRhZztcblxudmFyIGdlblN0YXRpY0tleXNDYWNoZWQgPSBjYWNoZWQoZ2VuU3RhdGljS2V5cyQxKTtcblxuLyoqXG4gKiBHb2FsIG9mIHRoZSBvcHRpbWl6ZXI6IHdhbGsgdGhlIGdlbmVyYXRlZCB0ZW1wbGF0ZSBBU1QgdHJlZVxuICogYW5kIGRldGVjdCBzdWItdHJlZXMgdGhhdCBhcmUgcHVyZWx5IHN0YXRpYywgaS5lLiBwYXJ0cyBvZlxuICogdGhlIERPTSB0aGF0IG5ldmVyIG5lZWRzIHRvIGNoYW5nZS5cbiAqXG4gKiBPbmNlIHdlIGRldGVjdCB0aGVzZSBzdWItdHJlZXMsIHdlIGNhbjpcbiAqXG4gKiAxLiBIb2lzdCB0aGVtIGludG8gY29uc3RhbnRzLCBzbyB0aGF0IHdlIG5vIGxvbmdlciBuZWVkIHRvXG4gKiAgICBjcmVhdGUgZnJlc2ggbm9kZXMgZm9yIHRoZW0gb24gZWFjaCByZS1yZW5kZXI7XG4gKiAyLiBDb21wbGV0ZWx5IHNraXAgdGhlbSBpbiB0aGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAqL1xuZnVuY3Rpb24gb3B0aW1pemUgKHJvb3QsIG9wdGlvbnMpIHtcbiAgaWYgKCFyb290KSB7IHJldHVybiB9XG4gIGlzU3RhdGljS2V5ID0gZ2VuU3RhdGljS2V5c0NhY2hlZChvcHRpb25zLnN0YXRpY0tleXMgfHwgJycpO1xuICBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gIC8vIGZpcnN0IHBhc3M6IG1hcmsgYWxsIG5vbi1zdGF0aWMgbm9kZXMuXG4gIG1hcmtTdGF0aWMkMShyb290KTtcbiAgLy8gc2Vjb25kIHBhc3M6IG1hcmsgc3RhdGljIHJvb3RzLlxuICBtYXJrU3RhdGljUm9vdHMocm9vdCwgZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzJDEgKGtleXMpIHtcbiAgcmV0dXJuIG1ha2VNYXAoXG4gICAgJ3R5cGUsdGFnLGF0dHJzTGlzdCxhdHRyc01hcCxwbGFpbixwYXJlbnQsY2hpbGRyZW4sYXR0cnMnICtcbiAgICAoa2V5cyA/ICcsJyArIGtleXMgOiAnJylcbiAgKVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljJDEgKG5vZGUpIHtcbiAgbm9kZS5zdGF0aWMgPSBpc1N0YXRpYyhub2RlKTtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIC8vIGRvIG5vdCBtYWtlIGNvbXBvbmVudCBzbG90IGNvbnRlbnQgc3RhdGljLiB0aGlzIGF2b2lkc1xuICAgIC8vIDEuIGNvbXBvbmVudHMgbm90IGFibGUgdG8gbXV0YXRlIHNsb3Qgbm9kZXNcbiAgICAvLyAyLiBzdGF0aWMgc2xvdCBjb250ZW50IGZhaWxzIGZvciBob3QtcmVsb2FkaW5nXG4gICAgaWYgKFxuICAgICAgIWlzUGxhdGZvcm1SZXNlcnZlZFRhZyhub2RlLnRhZykgJiZcbiAgICAgIG5vZGUudGFnICE9PSAnc2xvdCcgJiZcbiAgICAgIG5vZGUuYXR0cnNNYXBbJ2lubGluZS10ZW1wbGF0ZSddID09IG51bGxcbiAgICApIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgbWFya1N0YXRpYyQxKGNoaWxkKTtcbiAgICAgIGlmICghY2hpbGQuc3RhdGljKSB7XG4gICAgICAgIG5vZGUuc3RhdGljID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmlmQ29uZGl0aW9ucykge1xuICAgICAgZm9yICh2YXIgaSQxID0gMSwgbCQxID0gbm9kZS5pZkNvbmRpdGlvbnMubGVuZ3RoOyBpJDEgPCBsJDE7IGkkMSsrKSB7XG4gICAgICAgIHZhciBibG9jayA9IG5vZGUuaWZDb25kaXRpb25zW2kkMV0uYmxvY2s7XG4gICAgICAgIG1hcmtTdGF0aWMkMShibG9jayk7XG4gICAgICAgIGlmICghYmxvY2suc3RhdGljKSB7XG4gICAgICAgICAgbm9kZS5zdGF0aWMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljUm9vdHMgKG5vZGUsIGlzSW5Gb3IpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIGlmIChub2RlLnN0YXRpYyB8fCBub2RlLm9uY2UpIHtcbiAgICAgIG5vZGUuc3RhdGljSW5Gb3IgPSBpc0luRm9yO1xuICAgIH1cbiAgICAvLyBGb3IgYSBub2RlIHRvIHF1YWxpZnkgYXMgYSBzdGF0aWMgcm9vdCwgaXQgc2hvdWxkIGhhdmUgY2hpbGRyZW4gdGhhdFxuICAgIC8vIGFyZSBub3QganVzdCBzdGF0aWMgdGV4dC4gT3RoZXJ3aXNlIHRoZSBjb3N0IG9mIGhvaXN0aW5nIG91dCB3aWxsXG4gICAgLy8gb3V0d2VpZ2ggdGhlIGJlbmVmaXRzIGFuZCBpdCdzIGJldHRlciBvZmYgdG8ganVzdCBhbHdheXMgcmVuZGVyIGl0IGZyZXNoLlxuICAgIGlmIChub2RlLnN0YXRpYyAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCAmJiAhKFxuICAgICAgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgIG5vZGUuY2hpbGRyZW5bMF0udHlwZSA9PT0gM1xuICAgICkpIHtcbiAgICAgIG5vZGUuc3RhdGljUm9vdCA9IHRydWU7XG4gICAgICByZXR1cm5cbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5zdGF0aWNSb290ID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmNoaWxkcmVuW2ldLCBpc0luRm9yIHx8ICEhbm9kZS5mb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5pZkNvbmRpdGlvbnMpIHtcbiAgICAgIGZvciAodmFyIGkkMSA9IDEsIGwkMSA9IG5vZGUuaWZDb25kaXRpb25zLmxlbmd0aDsgaSQxIDwgbCQxOyBpJDErKykge1xuICAgICAgICBtYXJrU3RhdGljUm9vdHMobm9kZS5pZkNvbmRpdGlvbnNbaSQxXS5ibG9jaywgaXNJbkZvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzU3RhdGljIChub2RlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDIpIHsgLy8gZXhwcmVzc2lvblxuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGlmIChub2RlLnR5cGUgPT09IDMpIHsgLy8gdGV4dFxuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuICEhKG5vZGUucHJlIHx8IChcbiAgICAhbm9kZS5oYXNCaW5kaW5ncyAmJiAvLyBubyBkeW5hbWljIGJpbmRpbmdzXG4gICAgIW5vZGUuaWYgJiYgIW5vZGUuZm9yICYmIC8vIG5vdCB2LWlmIG9yIHYtZm9yIG9yIHYtZWxzZVxuICAgICFpc0J1aWx0SW5UYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGJ1aWx0LWluXG4gICAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJiAvLyBub3QgYSBjb21wb25lbnRcbiAgICAhaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3Iobm9kZSkgJiZcbiAgICBPYmplY3Qua2V5cyhub2RlKS5ldmVyeShpc1N0YXRpY0tleSlcbiAgKSlcbn1cblxuZnVuY3Rpb24gaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3IgKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUucGFyZW50KSB7XG4gICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgIGlmIChub2RlLnRhZyAhPT0gJ3RlbXBsYXRlJykge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmIChub2RlLmZvcikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG52YXIgZm5FeHBSRSA9IC9eKFtcXHckX10rfFxcKFteKV0qP1xcKSlcXHMqPT58XmZ1bmN0aW9uXFxzKlxcKC87XG52YXIgc2ltcGxlUGF0aFJFID0gL15bQS1aYS16XyRdW1xcdyRdKig/OlxcLltBLVphLXpfJF1bXFx3JF0qfFxcWydbXiddKj8nXXxcXFtcIlteXCJdKj9cIl18XFxbXFxkK118XFxbW0EtWmEtel8kXVtcXHckXSpdKSokLztcblxuLy8gS2V5Ym9hcmRFdmVudC5rZXlDb2RlIGFsaWFzZXNcbnZhciBrZXlDb2RlcyA9IHtcbiAgZXNjOiAyNyxcbiAgdGFiOiA5LFxuICBlbnRlcjogMTMsXG4gIHNwYWNlOiAzMixcbiAgdXA6IDM4LFxuICBsZWZ0OiAzNyxcbiAgcmlnaHQ6IDM5LFxuICBkb3duOiA0MCxcbiAgJ2RlbGV0ZSc6IFs4LCA0Nl1cbn07XG5cbi8vIEtleWJvYXJkRXZlbnQua2V5IGFsaWFzZXNcbnZhciBrZXlOYW1lcyA9IHtcbiAgZXNjOiAnRXNjYXBlJyxcbiAgdGFiOiAnVGFiJyxcbiAgZW50ZXI6ICdFbnRlcicsXG4gIHNwYWNlOiAnICcsXG4gIC8vICM3ODA2OiBJRTExIHVzZXMga2V5IG5hbWVzIHdpdGhvdXQgYEFycm93YCBwcmVmaXggZm9yIGFycm93IGtleXMuXG4gIHVwOiBbJ1VwJywgJ0Fycm93VXAnXSxcbiAgbGVmdDogWydMZWZ0JywgJ0Fycm93TGVmdCddLFxuICByaWdodDogWydSaWdodCcsICdBcnJvd1JpZ2h0J10sXG4gIGRvd246IFsnRG93bicsICdBcnJvd0Rvd24nXSxcbiAgJ2RlbGV0ZSc6IFsnQmFja3NwYWNlJywgJ0RlbGV0ZSddXG59O1xuXG4vLyAjNDg2ODogbW9kaWZpZXJzIHRoYXQgcHJldmVudCB0aGUgZXhlY3V0aW9uIG9mIHRoZSBsaXN0ZW5lclxuLy8gbmVlZCB0byBleHBsaWNpdGx5IHJldHVybiBudWxsIHNvIHRoYXQgd2UgY2FuIGRldGVybWluZSB3aGV0aGVyIHRvIHJlbW92ZVxuLy8gdGhlIGxpc3RlbmVyIGZvciAub25jZVxudmFyIGdlbkd1YXJkID0gZnVuY3Rpb24gKGNvbmRpdGlvbikgeyByZXR1cm4gKFwiaWYoXCIgKyBjb25kaXRpb24gKyBcIilyZXR1cm4gbnVsbDtcIik7IH07XG5cbnZhciBtb2RpZmllckNvZGUgPSB7XG4gIHN0b3A6ICckZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7JyxcbiAgcHJldmVudDogJyRldmVudC5wcmV2ZW50RGVmYXVsdCgpOycsXG4gIHNlbGY6IGdlbkd1YXJkKFwiJGV2ZW50LnRhcmdldCAhPT0gJGV2ZW50LmN1cnJlbnRUYXJnZXRcIiksXG4gIGN0cmw6IGdlbkd1YXJkKFwiISRldmVudC5jdHJsS2V5XCIpLFxuICBzaGlmdDogZ2VuR3VhcmQoXCIhJGV2ZW50LnNoaWZ0S2V5XCIpLFxuICBhbHQ6IGdlbkd1YXJkKFwiISRldmVudC5hbHRLZXlcIiksXG4gIG1ldGE6IGdlbkd1YXJkKFwiISRldmVudC5tZXRhS2V5XCIpLFxuICBsZWZ0OiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAwXCIpLFxuICBtaWRkbGU6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDFcIiksXG4gIHJpZ2h0OiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAyXCIpXG59O1xuXG5mdW5jdGlvbiBnZW5IYW5kbGVycyAoXG4gIGV2ZW50cyxcbiAgaXNOYXRpdmUsXG4gIHdhcm5cbikge1xuICB2YXIgcmVzID0gaXNOYXRpdmUgPyAnbmF0aXZlT246eycgOiAnb246eyc7XG4gIGZvciAodmFyIG5hbWUgaW4gZXZlbnRzKSB7XG4gICAgcmVzICs9IFwiXFxcIlwiICsgbmFtZSArIFwiXFxcIjpcIiArIChnZW5IYW5kbGVyKG5hbWUsIGV2ZW50c1tuYW1lXSkpICsgXCIsXCI7XG4gIH1cbiAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSkgKyAnfSdcbn1cblxuZnVuY3Rpb24gZ2VuSGFuZGxlciAoXG4gIG5hbWUsXG4gIGhhbmRsZXJcbikge1xuICBpZiAoIWhhbmRsZXIpIHtcbiAgICByZXR1cm4gJ2Z1bmN0aW9uKCl7fSdcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgcmV0dXJuIChcIltcIiArIChoYW5kbGVyLm1hcChmdW5jdGlvbiAoaGFuZGxlcikgeyByZXR1cm4gZ2VuSGFuZGxlcihuYW1lLCBoYW5kbGVyKTsgfSkuam9pbignLCcpKSArIFwiXVwiKVxuICB9XG5cbiAgdmFyIGlzTWV0aG9kUGF0aCA9IHNpbXBsZVBhdGhSRS50ZXN0KGhhbmRsZXIudmFsdWUpO1xuICB2YXIgaXNGdW5jdGlvbkV4cHJlc3Npb24gPSBmbkV4cFJFLnRlc3QoaGFuZGxlci52YWx1ZSk7XG5cbiAgaWYgKCFoYW5kbGVyLm1vZGlmaWVycykge1xuICAgIGlmIChpc01ldGhvZFBhdGggfHwgaXNGdW5jdGlvbkV4cHJlc3Npb24pIHtcbiAgICAgIHJldHVybiBoYW5kbGVyLnZhbHVlXG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIHJldHVybiAoXCJmdW5jdGlvbigkZXZlbnQpe1wiICsgKGhhbmRsZXIudmFsdWUpICsgXCJ9XCIpIC8vIGlubGluZSBzdGF0ZW1lbnRcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29kZSA9ICcnO1xuICAgIHZhciBnZW5Nb2RpZmllckNvZGUgPSAnJztcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBoYW5kbGVyLm1vZGlmaWVycykge1xuICAgICAgaWYgKG1vZGlmaWVyQ29kZVtrZXldKSB7XG4gICAgICAgIGdlbk1vZGlmaWVyQ29kZSArPSBtb2RpZmllckNvZGVba2V5XTtcbiAgICAgICAgLy8gbGVmdC9yaWdodFxuICAgICAgICBpZiAoa2V5Q29kZXNba2V5XSkge1xuICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2V4YWN0Jykge1xuICAgICAgICB2YXIgbW9kaWZpZXJzID0gKGhhbmRsZXIubW9kaWZpZXJzKTtcbiAgICAgICAgZ2VuTW9kaWZpZXJDb2RlICs9IGdlbkd1YXJkKFxuICAgICAgICAgIFsnY3RybCcsICdzaGlmdCcsICdhbHQnLCAnbWV0YSddXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChrZXlNb2RpZmllcikgeyByZXR1cm4gIW1vZGlmaWVyc1trZXlNb2RpZmllcl07IH0pXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChrZXlNb2RpZmllcikgeyByZXR1cm4gKFwiJGV2ZW50LlwiICsga2V5TW9kaWZpZXIgKyBcIktleVwiKTsgfSlcbiAgICAgICAgICAgIC5qb2luKCd8fCcpXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICBjb2RlICs9IGdlbktleUZpbHRlcihrZXlzKTtcbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIG1vZGlmaWVycyBsaWtlIHByZXZlbnQgYW5kIHN0b3AgZ2V0IGV4ZWN1dGVkIGFmdGVyIGtleSBmaWx0ZXJpbmdcbiAgICBpZiAoZ2VuTW9kaWZpZXJDb2RlKSB7XG4gICAgICBjb2RlICs9IGdlbk1vZGlmaWVyQ29kZTtcbiAgICB9XG4gICAgdmFyIGhhbmRsZXJDb2RlID0gaXNNZXRob2RQYXRoXG4gICAgICA/IChcInJldHVybiBcIiArIChoYW5kbGVyLnZhbHVlKSArIFwiKCRldmVudClcIilcbiAgICAgIDogaXNGdW5jdGlvbkV4cHJlc3Npb25cbiAgICAgICAgPyAoXCJyZXR1cm4gKFwiICsgKGhhbmRsZXIudmFsdWUpICsgXCIpKCRldmVudClcIilcbiAgICAgICAgOiBoYW5kbGVyLnZhbHVlO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIHJldHVybiAoXCJmdW5jdGlvbigkZXZlbnQpe1wiICsgY29kZSArIGhhbmRsZXJDb2RlICsgXCJ9XCIpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuS2V5RmlsdGVyIChrZXlzKSB7XG4gIHJldHVybiAoXCJpZighKCdidXR0b24nIGluICRldmVudCkmJlwiICsgKGtleXMubWFwKGdlbkZpbHRlckNvZGUpLmpvaW4oJyYmJykpICsgXCIpcmV0dXJuIG51bGw7XCIpXG59XG5cbmZ1bmN0aW9uIGdlbkZpbHRlckNvZGUgKGtleSkge1xuICB2YXIga2V5VmFsID0gcGFyc2VJbnQoa2V5LCAxMCk7XG4gIGlmIChrZXlWYWwpIHtcbiAgICByZXR1cm4gKFwiJGV2ZW50LmtleUNvZGUhPT1cIiArIGtleVZhbClcbiAgfVxuICB2YXIga2V5Q29kZSA9IGtleUNvZGVzW2tleV07XG4gIHZhciBrZXlOYW1lID0ga2V5TmFtZXNba2V5XTtcbiAgcmV0dXJuIChcbiAgICBcIl9rKCRldmVudC5rZXlDb2RlLFwiICtcbiAgICAoSlNPTi5zdHJpbmdpZnkoa2V5KSkgKyBcIixcIiArXG4gICAgKEpTT04uc3RyaW5naWZ5KGtleUNvZGUpKSArIFwiLFwiICtcbiAgICBcIiRldmVudC5rZXksXCIgK1xuICAgIFwiXCIgKyAoSlNPTi5zdHJpbmdpZnkoa2V5TmFtZSkpICtcbiAgICBcIilcIlxuICApXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBvbiAoZWwsIGRpcikge1xuICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgZGlyLm1vZGlmaWVycykge1xuICAgIHdhcm4oXCJ2LW9uIHdpdGhvdXQgYXJndW1lbnQgZG9lcyBub3Qgc3VwcG9ydCBtb2RpZmllcnMuXCIpO1xuICB9XG4gIGVsLndyYXBMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoY29kZSkgeyByZXR1cm4gKFwiX2coXCIgKyBjb2RlICsgXCIsXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKTsgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGJpbmQkMSAoZWwsIGRpcikge1xuICBlbC53cmFwRGF0YSA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgcmV0dXJuIChcIl9iKFwiICsgY29kZSArIFwiLCdcIiArIChlbC50YWcpICsgXCInLFwiICsgKGRpci52YWx1ZSkgKyBcIixcIiArIChkaXIubW9kaWZpZXJzICYmIGRpci5tb2RpZmllcnMucHJvcCA/ICd0cnVlJyA6ICdmYWxzZScpICsgKGRpci5tb2RpZmllcnMgJiYgZGlyLm1vZGlmaWVycy5zeW5jID8gJyx0cnVlJyA6ICcnKSArIFwiKVwiKVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIGJhc2VEaXJlY3RpdmVzID0ge1xuICBvbjogb24sXG4gIGJpbmQ6IGJpbmQkMSxcbiAgY2xvYWs6IG5vb3Bcbn1cblxuLyogICovXG5cbnZhciBDb2RlZ2VuU3RhdGUgPSBmdW5jdGlvbiBDb2RlZ2VuU3RhdGUgKG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgdGhpcy53YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICB0aGlzLnRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybUNvZGUnKTtcbiAgdGhpcy5kYXRhR2VuRm5zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdnZW5EYXRhJyk7XG4gIHRoaXMuZGlyZWN0aXZlcyA9IGV4dGVuZChleHRlbmQoe30sIGJhc2VEaXJlY3RpdmVzKSwgb3B0aW9ucy5kaXJlY3RpdmVzKTtcbiAgdmFyIGlzUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gIHRoaXMubWF5YmVDb21wb25lbnQgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuICFpc1Jlc2VydmVkVGFnKGVsLnRhZyk7IH07XG4gIHRoaXMub25jZUlkID0gMDtcbiAgdGhpcy5zdGF0aWNSZW5kZXJGbnMgPSBbXTtcbn07XG5cblxuXG5mdW5jdGlvbiBnZW5lcmF0ZSAoXG4gIGFzdCxcbiAgb3B0aW9uc1xuKSB7XG4gIHZhciBzdGF0ZSA9IG5ldyBDb2RlZ2VuU3RhdGUob3B0aW9ucyk7XG4gIHZhciBjb2RlID0gYXN0ID8gZ2VuRWxlbWVudChhc3QsIHN0YXRlKSA6ICdfYyhcImRpdlwiKSc7XG4gIHJldHVybiB7XG4gICAgcmVuZGVyOiAoXCJ3aXRoKHRoaXMpe3JldHVybiBcIiArIGNvZGUgKyBcIn1cIiksXG4gICAgc3RhdGljUmVuZGVyRm5zOiBzdGF0ZS5zdGF0aWNSZW5kZXJGbnNcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5FbGVtZW50IChlbCwgc3RhdGUpIHtcbiAgaWYgKGVsLnN0YXRpY1Jvb3QgJiYgIWVsLnN0YXRpY1Byb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5TdGF0aWMoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLm9uY2UgJiYgIWVsLm9uY2VQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuT25jZShlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuRm9yKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyAmJiAhZWwuc2xvdFRhcmdldCkge1xuICAgIHJldHVybiBnZW5DaGlsZHJlbihlbCwgc3RhdGUpIHx8ICd2b2lkIDAnXG4gIH0gZWxzZSBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICByZXR1cm4gZ2VuU2xvdChlbCwgc3RhdGUpXG4gIH0gZWxzZSB7XG4gICAgLy8gY29tcG9uZW50IG9yIGVsZW1lbnRcbiAgICB2YXIgY29kZTtcbiAgICBpZiAoZWwuY29tcG9uZW50KSB7XG4gICAgICBjb2RlID0gZ2VuQ29tcG9uZW50KGVsLmNvbXBvbmVudCwgZWwsIHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRhdGEgPSBlbC5wbGFpbiA/IHVuZGVmaW5lZCA6IGdlbkRhdGEkMihlbCwgc3RhdGUpO1xuXG4gICAgICB2YXIgY2hpbGRyZW4gPSBlbC5pbmxpbmVUZW1wbGF0ZSA/IG51bGwgOiBnZW5DaGlsZHJlbihlbCwgc3RhdGUsIHRydWUpO1xuICAgICAgY29kZSA9IFwiX2MoJ1wiICsgKGVsLnRhZykgKyBcIidcIiArIChkYXRhID8gKFwiLFwiICsgZGF0YSkgOiAnJykgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJykgKyBcIilcIjtcbiAgICB9XG4gICAgLy8gbW9kdWxlIHRyYW5zZm9ybXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlLnRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvZGUgPSBzdGF0ZS50cmFuc2Zvcm1zW2ldKGVsLCBjb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvZGVcbiAgfVxufVxuXG4vLyBob2lzdCBzdGF0aWMgc3ViLXRyZWVzIG91dFxuZnVuY3Rpb24gZ2VuU3RhdGljIChlbCwgc3RhdGUpIHtcbiAgZWwuc3RhdGljUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgc3RhdGUuc3RhdGljUmVuZGVyRm5zLnB1c2goKFwid2l0aCh0aGlzKXtyZXR1cm4gXCIgKyAoZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwifVwiKSk7XG4gIHJldHVybiAoXCJfbShcIiArIChzdGF0ZS5zdGF0aWNSZW5kZXJGbnMubGVuZ3RoIC0gMSkgKyAoZWwuc3RhdGljSW5Gb3IgPyAnLHRydWUnIDogJycpICsgXCIpXCIpXG59XG5cbi8vIHYtb25jZVxuZnVuY3Rpb24gZ2VuT25jZSAoZWwsIHN0YXRlKSB7XG4gIGVsLm9uY2VQcm9jZXNzZWQgPSB0cnVlO1xuICBpZiAoZWwuaWYgJiYgIWVsLmlmUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbklmKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5zdGF0aWNJbkZvcikge1xuICAgIHZhciBrZXkgPSAnJztcbiAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50O1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQuZm9yKSB7XG4gICAgICAgIGtleSA9IHBhcmVudC5rZXk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cbiAgICBpZiAoIWtleSkge1xuICAgICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgc3RhdGUud2FybihcbiAgICAgICAgXCJ2LW9uY2UgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgdi1mb3IgdGhhdCBpcyBrZXllZC4gXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gZ2VuRWxlbWVudChlbCwgc3RhdGUpXG4gICAgfVxuICAgIHJldHVybiAoXCJfbyhcIiArIChnZW5FbGVtZW50KGVsLCBzdGF0ZSkpICsgXCIsXCIgKyAoc3RhdGUub25jZUlkKyspICsgXCIsXCIgKyBrZXkgKyBcIilcIilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2VuU3RhdGljKGVsLCBzdGF0ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5JZiAoXG4gIGVsLFxuICBzdGF0ZSxcbiAgYWx0R2VuLFxuICBhbHRFbXB0eVxuKSB7XG4gIGVsLmlmUHJvY2Vzc2VkID0gdHJ1ZTsgLy8gYXZvaWQgcmVjdXJzaW9uXG4gIHJldHVybiBnZW5JZkNvbmRpdGlvbnMoZWwuaWZDb25kaXRpb25zLnNsaWNlKCksIHN0YXRlLCBhbHRHZW4sIGFsdEVtcHR5KVxufVxuXG5mdW5jdGlvbiBnZW5JZkNvbmRpdGlvbnMgKFxuICBjb25kaXRpb25zLFxuICBzdGF0ZSxcbiAgYWx0R2VuLFxuICBhbHRFbXB0eVxuKSB7XG4gIGlmICghY29uZGl0aW9ucy5sZW5ndGgpIHtcbiAgICByZXR1cm4gYWx0RW1wdHkgfHwgJ19lKCknXG4gIH1cblxuICB2YXIgY29uZGl0aW9uID0gY29uZGl0aW9ucy5zaGlmdCgpO1xuICBpZiAoY29uZGl0aW9uLmV4cCkge1xuICAgIHJldHVybiAoXCIoXCIgKyAoY29uZGl0aW9uLmV4cCkgKyBcIik/XCIgKyAoZ2VuVGVybmFyeUV4cChjb25kaXRpb24uYmxvY2spKSArIFwiOlwiICsgKGdlbklmQ29uZGl0aW9ucyhjb25kaXRpb25zLCBzdGF0ZSwgYWx0R2VuLCBhbHRFbXB0eSkpKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoXCJcIiArIChnZW5UZXJuYXJ5RXhwKGNvbmRpdGlvbi5ibG9jaykpKVxuICB9XG5cbiAgLy8gdi1pZiB3aXRoIHYtb25jZSBzaG91bGQgZ2VuZXJhdGUgY29kZSBsaWtlIChhKT9fbSgwKTpfbSgxKVxuICBmdW5jdGlvbiBnZW5UZXJuYXJ5RXhwIChlbCkge1xuICAgIHJldHVybiBhbHRHZW5cbiAgICAgID8gYWx0R2VuKGVsLCBzdGF0ZSlcbiAgICAgIDogZWwub25jZVxuICAgICAgICA/IGdlbk9uY2UoZWwsIHN0YXRlKVxuICAgICAgICA6IGdlbkVsZW1lbnQoZWwsIHN0YXRlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkZvciAoXG4gIGVsLFxuICBzdGF0ZSxcbiAgYWx0R2VuLFxuICBhbHRIZWxwZXJcbikge1xuICB2YXIgZXhwID0gZWwuZm9yO1xuICB2YXIgYWxpYXMgPSBlbC5hbGlhcztcbiAgdmFyIGl0ZXJhdG9yMSA9IGVsLml0ZXJhdG9yMSA/IChcIixcIiArIChlbC5pdGVyYXRvcjEpKSA6ICcnO1xuICB2YXIgaXRlcmF0b3IyID0gZWwuaXRlcmF0b3IyID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMikpIDogJyc7XG5cbiAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgc3RhdGUubWF5YmVDb21wb25lbnQoZWwpICYmXG4gICAgZWwudGFnICE9PSAnc2xvdCcgJiZcbiAgICBlbC50YWcgIT09ICd0ZW1wbGF0ZScgJiZcbiAgICAhZWwua2V5XG4gICkge1xuICAgIHN0YXRlLndhcm4oXG4gICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1mb3I9XFxcIlwiICsgYWxpYXMgKyBcIiBpbiBcIiArIGV4cCArIFwiXFxcIj46IGNvbXBvbmVudCBsaXN0cyByZW5kZXJlZCB3aXRoIFwiICtcbiAgICAgIFwidi1mb3Igc2hvdWxkIGhhdmUgZXhwbGljaXQga2V5cy4gXCIgK1xuICAgICAgXCJTZWUgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvbGlzdC5odG1sI2tleSBmb3IgbW9yZSBpbmZvLlwiLFxuICAgICAgdHJ1ZSAvKiB0aXAgKi9cbiAgICApO1xuICB9XG5cbiAgZWwuZm9yUHJvY2Vzc2VkID0gdHJ1ZTsgLy8gYXZvaWQgcmVjdXJzaW9uXG4gIHJldHVybiAoYWx0SGVscGVyIHx8ICdfbCcpICsgXCIoKFwiICsgZXhwICsgXCIpLFwiICtcbiAgICBcImZ1bmN0aW9uKFwiICsgYWxpYXMgKyBpdGVyYXRvcjEgKyBpdGVyYXRvcjIgKyBcIil7XCIgK1xuICAgICAgXCJyZXR1cm4gXCIgKyAoKGFsdEdlbiB8fCBnZW5FbGVtZW50KShlbCwgc3RhdGUpKSArXG4gICAgJ30pJ1xufVxuXG5mdW5jdGlvbiBnZW5EYXRhJDIgKGVsLCBzdGF0ZSkge1xuICB2YXIgZGF0YSA9ICd7JztcblxuICAvLyBkaXJlY3RpdmVzIGZpcnN0LlxuICAvLyBkaXJlY3RpdmVzIG1heSBtdXRhdGUgdGhlIGVsJ3Mgb3RoZXIgcHJvcGVydGllcyBiZWZvcmUgdGhleSBhcmUgZ2VuZXJhdGVkLlxuICB2YXIgZGlycyA9IGdlbkRpcmVjdGl2ZXMoZWwsIHN0YXRlKTtcbiAgaWYgKGRpcnMpIHsgZGF0YSArPSBkaXJzICsgJywnOyB9XG5cbiAgLy8ga2V5XG4gIGlmIChlbC5rZXkpIHtcbiAgICBkYXRhICs9IFwia2V5OlwiICsgKGVsLmtleSkgKyBcIixcIjtcbiAgfVxuICAvLyByZWZcbiAgaWYgKGVsLnJlZikge1xuICAgIGRhdGEgKz0gXCJyZWY6XCIgKyAoZWwucmVmKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5yZWZJbkZvcikge1xuICAgIGRhdGEgKz0gXCJyZWZJbkZvcjp0cnVlLFwiO1xuICB9XG4gIC8vIHByZVxuICBpZiAoZWwucHJlKSB7XG4gICAgZGF0YSArPSBcInByZTp0cnVlLFwiO1xuICB9XG4gIC8vIHJlY29yZCBvcmlnaW5hbCB0YWcgbmFtZSBmb3IgY29tcG9uZW50cyB1c2luZyBcImlzXCIgYXR0cmlidXRlXG4gIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICBkYXRhICs9IFwidGFnOlxcXCJcIiArIChlbC50YWcpICsgXCJcXFwiLFwiO1xuICB9XG4gIC8vIG1vZHVsZSBkYXRhIGdlbmVyYXRpb24gZnVuY3Rpb25zXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGUuZGF0YUdlbkZucy5sZW5ndGg7IGkrKykge1xuICAgIGRhdGEgKz0gc3RhdGUuZGF0YUdlbkZuc1tpXShlbCk7XG4gIH1cbiAgLy8gYXR0cmlidXRlc1xuICBpZiAoZWwuYXR0cnMpIHtcbiAgICBkYXRhICs9IFwiYXR0cnM6e1wiICsgKGdlblByb3BzKGVsLmF0dHJzKSkgKyBcIn0sXCI7XG4gIH1cbiAgLy8gRE9NIHByb3BzXG4gIGlmIChlbC5wcm9wcykge1xuICAgIGRhdGEgKz0gXCJkb21Qcm9wczp7XCIgKyAoZ2VuUHJvcHMoZWwucHJvcHMpKSArIFwifSxcIjtcbiAgfVxuICAvLyBldmVudCBoYW5kbGVyc1xuICBpZiAoZWwuZXZlbnRzKSB7XG4gICAgZGF0YSArPSAoZ2VuSGFuZGxlcnMoZWwuZXZlbnRzLCBmYWxzZSwgc3RhdGUud2FybikpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLm5hdGl2ZUV2ZW50cykge1xuICAgIGRhdGEgKz0gKGdlbkhhbmRsZXJzKGVsLm5hdGl2ZUV2ZW50cywgdHJ1ZSwgc3RhdGUud2FybikpICsgXCIsXCI7XG4gIH1cbiAgLy8gc2xvdCB0YXJnZXRcbiAgLy8gb25seSBmb3Igbm9uLXNjb3BlZCBzbG90c1xuICBpZiAoZWwuc2xvdFRhcmdldCAmJiAhZWwuc2xvdFNjb3BlKSB7XG4gICAgZGF0YSArPSBcInNsb3Q6XCIgKyAoZWwuc2xvdFRhcmdldCkgKyBcIixcIjtcbiAgfVxuICAvLyBzY29wZWQgc2xvdHNcbiAgaWYgKGVsLnNjb3BlZFNsb3RzKSB7XG4gICAgZGF0YSArPSAoZ2VuU2NvcGVkU2xvdHMoZWwuc2NvcGVkU2xvdHMsIHN0YXRlKSkgKyBcIixcIjtcbiAgfVxuICAvLyBjb21wb25lbnQgdi1tb2RlbFxuICBpZiAoZWwubW9kZWwpIHtcbiAgICBkYXRhICs9IFwibW9kZWw6e3ZhbHVlOlwiICsgKGVsLm1vZGVsLnZhbHVlKSArIFwiLGNhbGxiYWNrOlwiICsgKGVsLm1vZGVsLmNhbGxiYWNrKSArIFwiLGV4cHJlc3Npb246XCIgKyAoZWwubW9kZWwuZXhwcmVzc2lvbikgKyBcIn0sXCI7XG4gIH1cbiAgLy8gaW5saW5lLXRlbXBsYXRlXG4gIGlmIChlbC5pbmxpbmVUZW1wbGF0ZSkge1xuICAgIHZhciBpbmxpbmVUZW1wbGF0ZSA9IGdlbklubGluZVRlbXBsYXRlKGVsLCBzdGF0ZSk7XG4gICAgaWYgKGlubGluZVRlbXBsYXRlKSB7XG4gICAgICBkYXRhICs9IGlubGluZVRlbXBsYXRlICsgXCIsXCI7XG4gICAgfVxuICB9XG4gIGRhdGEgPSBkYXRhLnJlcGxhY2UoLywkLywgJycpICsgJ30nO1xuICAvLyB2LWJpbmQgZGF0YSB3cmFwXG4gIGlmIChlbC53cmFwRGF0YSkge1xuICAgIGRhdGEgPSBlbC53cmFwRGF0YShkYXRhKTtcbiAgfVxuICAvLyB2LW9uIGRhdGEgd3JhcFxuICBpZiAoZWwud3JhcExpc3RlbmVycykge1xuICAgIGRhdGEgPSBlbC53cmFwTGlzdGVuZXJzKGRhdGEpO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIGdlbkRpcmVjdGl2ZXMgKGVsLCBzdGF0ZSkge1xuICB2YXIgZGlycyA9IGVsLmRpcmVjdGl2ZXM7XG4gIGlmICghZGlycykgeyByZXR1cm4gfVxuICB2YXIgcmVzID0gJ2RpcmVjdGl2ZXM6Wyc7XG4gIHZhciBoYXNSdW50aW1lID0gZmFsc2U7XG4gIHZhciBpLCBsLCBkaXIsIG5lZWRSdW50aW1lO1xuICBmb3IgKGkgPSAwLCBsID0gZGlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBkaXIgPSBkaXJzW2ldO1xuICAgIG5lZWRSdW50aW1lID0gdHJ1ZTtcbiAgICB2YXIgZ2VuID0gc3RhdGUuZGlyZWN0aXZlc1tkaXIubmFtZV07XG4gICAgaWYgKGdlbikge1xuICAgICAgLy8gY29tcGlsZS10aW1lIGRpcmVjdGl2ZSB0aGF0IG1hbmlwdWxhdGVzIEFTVC5cbiAgICAgIC8vIHJldHVybnMgdHJ1ZSBpZiBpdCBhbHNvIG5lZWRzIGEgcnVudGltZSBjb3VudGVycGFydC5cbiAgICAgIG5lZWRSdW50aW1lID0gISFnZW4oZWwsIGRpciwgc3RhdGUud2Fybik7XG4gICAgfVxuICAgIGlmIChuZWVkUnVudGltZSkge1xuICAgICAgaGFzUnVudGltZSA9IHRydWU7XG4gICAgICByZXMgKz0gXCJ7bmFtZTpcXFwiXCIgKyAoZGlyLm5hbWUpICsgXCJcXFwiLHJhd05hbWU6XFxcIlwiICsgKGRpci5yYXdOYW1lKSArIFwiXFxcIlwiICsgKGRpci52YWx1ZSA/IChcIix2YWx1ZTooXCIgKyAoZGlyLnZhbHVlKSArIFwiKSxleHByZXNzaW9uOlwiICsgKEpTT04uc3RyaW5naWZ5KGRpci52YWx1ZSkpKSA6ICcnKSArIChkaXIuYXJnID8gKFwiLGFyZzpcXFwiXCIgKyAoZGlyLmFyZykgKyBcIlxcXCJcIikgOiAnJykgKyAoZGlyLm1vZGlmaWVycyA/IChcIixtb2RpZmllcnM6XCIgKyAoSlNPTi5zdHJpbmdpZnkoZGlyLm1vZGlmaWVycykpKSA6ICcnKSArIFwifSxcIjtcbiAgICB9XG4gIH1cbiAgaWYgKGhhc1J1bnRpbWUpIHtcbiAgICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKSArICddJ1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbklubGluZVRlbXBsYXRlIChlbCwgc3RhdGUpIHtcbiAgdmFyIGFzdCA9IGVsLmNoaWxkcmVuWzBdO1xuICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgKFxuICAgIGVsLmNoaWxkcmVuLmxlbmd0aCAhPT0gMSB8fCBhc3QudHlwZSAhPT0gMVxuICApKSB7XG4gICAgc3RhdGUud2FybignSW5saW5lLXRlbXBsYXRlIGNvbXBvbmVudHMgbXVzdCBoYXZlIGV4YWN0bHkgb25lIGNoaWxkIGVsZW1lbnQuJyk7XG4gIH1cbiAgaWYgKGFzdC50eXBlID09PSAxKSB7XG4gICAgdmFyIGlubGluZVJlbmRlckZucyA9IGdlbmVyYXRlKGFzdCwgc3RhdGUub3B0aW9ucyk7XG4gICAgcmV0dXJuIChcImlubGluZVRlbXBsYXRlOntyZW5kZXI6ZnVuY3Rpb24oKXtcIiArIChpbmxpbmVSZW5kZXJGbnMucmVuZGVyKSArIFwifSxzdGF0aWNSZW5kZXJGbnM6W1wiICsgKGlubGluZVJlbmRlckZucy5zdGF0aWNSZW5kZXJGbnMubWFwKGZ1bmN0aW9uIChjb2RlKSB7IHJldHVybiAoXCJmdW5jdGlvbigpe1wiICsgY29kZSArIFwifVwiKTsgfSkuam9pbignLCcpKSArIFwiXX1cIilcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5TY29wZWRTbG90cyAoXG4gIHNsb3RzLFxuICBzdGF0ZVxuKSB7XG4gIHJldHVybiAoXCJzY29wZWRTbG90czpfdShbXCIgKyAoT2JqZWN0LmtleXMoc2xvdHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gZ2VuU2NvcGVkU2xvdChrZXksIHNsb3RzW2tleV0sIHN0YXRlKVxuICAgIH0pLmpvaW4oJywnKSkgKyBcIl0pXCIpXG59XG5cbmZ1bmN0aW9uIGdlblNjb3BlZFNsb3QgKFxuICBrZXksXG4gIGVsLFxuICBzdGF0ZVxuKSB7XG4gIGlmIChlbC5mb3IgJiYgIWVsLmZvclByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5Gb3JTY29wZWRTbG90KGtleSwgZWwsIHN0YXRlKVxuICB9XG4gIHZhciBmbiA9IFwiZnVuY3Rpb24oXCIgKyAoU3RyaW5nKGVsLnNsb3RTY29wZSkpICsgXCIpe1wiICtcbiAgICBcInJldHVybiBcIiArIChlbC50YWcgPT09ICd0ZW1wbGF0ZSdcbiAgICAgID8gZWwuaWZcbiAgICAgICAgPyAoKGVsLmlmKSArIFwiP1wiICsgKGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3VuZGVmaW5lZCcpICsgXCI6dW5kZWZpbmVkXCIpXG4gICAgICAgIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndW5kZWZpbmVkJ1xuICAgICAgOiBnZW5FbGVtZW50KGVsLCBzdGF0ZSkpICsgXCJ9XCI7XG4gIHJldHVybiAoXCJ7a2V5OlwiICsga2V5ICsgXCIsZm46XCIgKyBmbiArIFwifVwiKVxufVxuXG5mdW5jdGlvbiBnZW5Gb3JTY29wZWRTbG90IChcbiAga2V5LFxuICBlbCxcbiAgc3RhdGVcbikge1xuICB2YXIgZXhwID0gZWwuZm9yO1xuICB2YXIgYWxpYXMgPSBlbC5hbGlhcztcbiAgdmFyIGl0ZXJhdG9yMSA9IGVsLml0ZXJhdG9yMSA/IChcIixcIiArIChlbC5pdGVyYXRvcjEpKSA6ICcnO1xuICB2YXIgaXRlcmF0b3IyID0gZWwuaXRlcmF0b3IyID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMikpIDogJyc7XG4gIGVsLmZvclByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICByZXR1cm4gXCJfbCgoXCIgKyBleHAgKyBcIiksXCIgK1xuICAgIFwiZnVuY3Rpb24oXCIgKyBhbGlhcyArIGl0ZXJhdG9yMSArIGl0ZXJhdG9yMiArIFwiKXtcIiArXG4gICAgICBcInJldHVybiBcIiArIChnZW5TY29wZWRTbG90KGtleSwgZWwsIHN0YXRlKSkgK1xuICAgICd9KSdcbn1cblxuZnVuY3Rpb24gZ2VuQ2hpbGRyZW4gKFxuICBlbCxcbiAgc3RhdGUsXG4gIGNoZWNrU2tpcCxcbiAgYWx0R2VuRWxlbWVudCxcbiAgYWx0R2VuTm9kZVxuKSB7XG4gIHZhciBjaGlsZHJlbiA9IGVsLmNoaWxkcmVuO1xuICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgdmFyIGVsJDEgPSBjaGlsZHJlblswXTtcbiAgICAvLyBvcHRpbWl6ZSBzaW5nbGUgdi1mb3JcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXG4gICAgICBlbCQxLmZvciAmJlxuICAgICAgZWwkMS50YWcgIT09ICd0ZW1wbGF0ZScgJiZcbiAgICAgIGVsJDEudGFnICE9PSAnc2xvdCdcbiAgICApIHtcbiAgICAgIHJldHVybiAoYWx0R2VuRWxlbWVudCB8fCBnZW5FbGVtZW50KShlbCQxLCBzdGF0ZSlcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6YXRpb25UeXBlID0gY2hlY2tTa2lwXG4gICAgICA/IGdldE5vcm1hbGl6YXRpb25UeXBlKGNoaWxkcmVuLCBzdGF0ZS5tYXliZUNvbXBvbmVudClcbiAgICAgIDogMDtcbiAgICB2YXIgZ2VuID0gYWx0R2VuTm9kZSB8fCBnZW5Ob2RlO1xuICAgIHJldHVybiAoXCJbXCIgKyAoY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBnZW4oYywgc3RhdGUpOyB9KS5qb2luKCcsJykpICsgXCJdXCIgKyAobm9ybWFsaXphdGlvblR5cGUgPyAoXCIsXCIgKyBub3JtYWxpemF0aW9uVHlwZSkgOiAnJykpXG4gIH1cbn1cblxuLy8gZGV0ZXJtaW5lIHRoZSBub3JtYWxpemF0aW9uIG5lZWRlZCBmb3IgdGhlIGNoaWxkcmVuIGFycmF5LlxuLy8gMDogbm8gbm9ybWFsaXphdGlvbiBuZWVkZWRcbi8vIDE6IHNpbXBsZSBub3JtYWxpemF0aW9uIG5lZWRlZCAocG9zc2libGUgMS1sZXZlbCBkZWVwIG5lc3RlZCBhcnJheSlcbi8vIDI6IGZ1bGwgbm9ybWFsaXphdGlvbiBuZWVkZWRcbmZ1bmN0aW9uIGdldE5vcm1hbGl6YXRpb25UeXBlIChcbiAgY2hpbGRyZW4sXG4gIG1heWJlQ29tcG9uZW50XG4pIHtcbiAgdmFyIHJlcyA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWwgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoZWwudHlwZSAhPT0gMSkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKG5lZWRzTm9ybWFsaXphdGlvbihlbCkgfHxcbiAgICAgICAgKGVsLmlmQ29uZGl0aW9ucyAmJiBlbC5pZkNvbmRpdGlvbnMuc29tZShmdW5jdGlvbiAoYykgeyByZXR1cm4gbmVlZHNOb3JtYWxpemF0aW9uKGMuYmxvY2spOyB9KSkpIHtcbiAgICAgIHJlcyA9IDI7XG4gICAgICBicmVha1xuICAgIH1cbiAgICBpZiAobWF5YmVDb21wb25lbnQoZWwpIHx8XG4gICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiYgZWwuaWZDb25kaXRpb25zLnNvbWUoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG1heWJlQ29tcG9uZW50KGMuYmxvY2spOyB9KSkpIHtcbiAgICAgIHJlcyA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gbmVlZHNOb3JtYWxpemF0aW9uIChlbCkge1xuICByZXR1cm4gZWwuZm9yICE9PSB1bmRlZmluZWQgfHwgZWwudGFnID09PSAndGVtcGxhdGUnIHx8IGVsLnRhZyA9PT0gJ3Nsb3QnXG59XG5cbmZ1bmN0aW9uIGdlbk5vZGUgKG5vZGUsIHN0YXRlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICByZXR1cm4gZ2VuRWxlbWVudChub2RlLCBzdGF0ZSlcbiAgfSBpZiAobm9kZS50eXBlID09PSAzICYmIG5vZGUuaXNDb21tZW50KSB7XG4gICAgcmV0dXJuIGdlbkNvbW1lbnQobm9kZSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2VuVGV4dChub2RlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlblRleHQgKHRleHQpIHtcbiAgcmV0dXJuIChcIl92KFwiICsgKHRleHQudHlwZSA9PT0gMlxuICAgID8gdGV4dC5leHByZXNzaW9uIC8vIG5vIG5lZWQgZm9yICgpIGJlY2F1c2UgYWxyZWFkeSB3cmFwcGVkIGluIF9zKClcbiAgICA6IHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhKU09OLnN0cmluZ2lmeSh0ZXh0LnRleHQpKSkgKyBcIilcIilcbn1cblxuZnVuY3Rpb24gZ2VuQ29tbWVudCAoY29tbWVudCkge1xuICByZXR1cm4gKFwiX2UoXCIgKyAoSlNPTi5zdHJpbmdpZnkoY29tbWVudC50ZXh0KSkgKyBcIilcIilcbn1cblxuZnVuY3Rpb24gZ2VuU2xvdCAoZWwsIHN0YXRlKSB7XG4gIHZhciBzbG90TmFtZSA9IGVsLnNsb3ROYW1lIHx8ICdcImRlZmF1bHRcIic7XG4gIHZhciBjaGlsZHJlbiA9IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSk7XG4gIHZhciByZXMgPSBcIl90KFwiICsgc2xvdE5hbWUgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJyk7XG4gIHZhciBhdHRycyA9IGVsLmF0dHJzICYmIChcIntcIiArIChlbC5hdHRycy5tYXAoZnVuY3Rpb24gKGEpIHsgcmV0dXJuICgoY2FtZWxpemUoYS5uYW1lKSkgKyBcIjpcIiArIChhLnZhbHVlKSk7IH0pLmpvaW4oJywnKSkgKyBcIn1cIik7XG4gIHZhciBiaW5kJCQxID0gZWwuYXR0cnNNYXBbJ3YtYmluZCddO1xuICBpZiAoKGF0dHJzIHx8IGJpbmQkJDEpICYmICFjaGlsZHJlbikge1xuICAgIHJlcyArPSBcIixudWxsXCI7XG4gIH1cbiAgaWYgKGF0dHJzKSB7XG4gICAgcmVzICs9IFwiLFwiICsgYXR0cnM7XG4gIH1cbiAgaWYgKGJpbmQkJDEpIHtcbiAgICByZXMgKz0gKGF0dHJzID8gJycgOiAnLG51bGwnKSArIFwiLFwiICsgYmluZCQkMTtcbiAgfVxuICByZXR1cm4gcmVzICsgJyknXG59XG5cbi8vIGNvbXBvbmVudE5hbWUgaXMgZWwuY29tcG9uZW50LCB0YWtlIGl0IGFzIGFyZ3VtZW50IHRvIHNodW4gZmxvdydzIHBlc3NpbWlzdGljIHJlZmluZW1lbnRcbmZ1bmN0aW9uIGdlbkNvbXBvbmVudCAoXG4gIGNvbXBvbmVudE5hbWUsXG4gIGVsLFxuICBzdGF0ZVxuKSB7XG4gIHZhciBjaGlsZHJlbiA9IGVsLmlubGluZVRlbXBsYXRlID8gbnVsbCA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSwgdHJ1ZSk7XG4gIHJldHVybiAoXCJfYyhcIiArIGNvbXBvbmVudE5hbWUgKyBcIixcIiArIChnZW5EYXRhJDIoZWwsIHN0YXRlKSkgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJykgKyBcIilcIilcbn1cblxuZnVuY3Rpb24gZ2VuUHJvcHMgKHByb3BzKSB7XG4gIHZhciByZXMgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAge1xuICAgICAgcmVzICs9IFwiXFxcIlwiICsgKHByb3AubmFtZSkgKyBcIlxcXCI6XCIgKyAodHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKHByb3AudmFsdWUpKSArIFwiLFwiO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKVxufVxuXG4vLyAjMzg5NSwgIzQyNjhcbmZ1bmN0aW9uIHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyAodGV4dCkge1xuICByZXR1cm4gdGV4dFxuICAgIC5yZXBsYWNlKC9cXHUyMDI4L2csICdcXFxcdTIwMjgnKVxuICAgIC5yZXBsYWNlKC9cXHUyMDI5L2csICdcXFxcdTIwMjknKVxufVxuXG4vKiAgKi9cblxuLy8gdGhlc2Uga2V5d29yZHMgc2hvdWxkIG5vdCBhcHBlYXIgaW5zaWRlIGV4cHJlc3Npb25zLCBidXQgb3BlcmF0b3JzIGxpa2Vcbi8vIHR5cGVvZiwgaW5zdGFuY2VvZiBhbmQgaW4gYXJlIGFsbG93ZWRcbnZhciBwcm9oaWJpdGVkS2V5d29yZFJFID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgKFxuICAnZG8saWYsZm9yLGxldCxuZXcsdHJ5LHZhcixjYXNlLGVsc2Usd2l0aCxhd2FpdCxicmVhayxjYXRjaCxjbGFzcyxjb25zdCwnICtcbiAgJ3N1cGVyLHRocm93LHdoaWxlLHlpZWxkLGRlbGV0ZSxleHBvcnQsaW1wb3J0LHJldHVybixzd2l0Y2gsZGVmYXVsdCwnICtcbiAgJ2V4dGVuZHMsZmluYWxseSxjb250aW51ZSxkZWJ1Z2dlcixmdW5jdGlvbixhcmd1bWVudHMnXG4pLnNwbGl0KCcsJykuam9pbignXFxcXGJ8XFxcXGInKSArICdcXFxcYicpO1xuXG4vLyB0aGVzZSB1bmFyeSBvcGVyYXRvcnMgc2hvdWxkIG5vdCBiZSB1c2VkIGFzIHByb3BlcnR5L21ldGhvZCBuYW1lc1xudmFyIHVuYXJ5T3BlcmF0b3JzUkUgPSBuZXcgUmVnRXhwKCdcXFxcYicgKyAoXG4gICdkZWxldGUsdHlwZW9mLHZvaWQnXG4pLnNwbGl0KCcsJykuam9pbignXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKXxcXFxcYicpICsgJ1xcXFxzKlxcXFwoW15cXFxcKV0qXFxcXCknKTtcblxuLy8gc3RyaXAgc3RyaW5ncyBpbiBleHByZXNzaW9uc1xudmFyIHN0cmlwU3RyaW5nUkUgPSAvJyg/OlteJ1xcXFxdfFxcXFwuKSonfFwiKD86W15cIlxcXFxdfFxcXFwuKSpcInxgKD86W15gXFxcXF18XFxcXC4pKlxcJFxce3xcXH0oPzpbXmBcXFxcXXxcXFxcLikqYHxgKD86W15gXFxcXF18XFxcXC4pKmAvZztcblxuLy8gZGV0ZWN0IHByb2JsZW1hdGljIGV4cHJlc3Npb25zIGluIGEgdGVtcGxhdGVcbmZ1bmN0aW9uIGRldGVjdEVycm9ycyAoYXN0KSB7XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYgKGFzdCkge1xuICAgIGNoZWNrTm9kZShhc3QsIGVycm9ycyk7XG4gIH1cbiAgcmV0dXJuIGVycm9yc1xufVxuXG5mdW5jdGlvbiBjaGVja05vZGUgKG5vZGUsIGVycm9ycykge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBub2RlLmF0dHJzTWFwKSB7XG4gICAgICBpZiAoZGlyUkUudGVzdChuYW1lKSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBub2RlLmF0dHJzTWFwW25hbWVdO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICBpZiAobmFtZSA9PT0gJ3YtZm9yJykge1xuICAgICAgICAgICAgY2hlY2tGb3Iobm9kZSwgKFwidi1mb3I9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIGVycm9ycyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChvblJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgIGNoZWNrRXZlbnQodmFsdWUsIChuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIGVycm9ycyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoZWNrRXhwcmVzc2lvbih2YWx1ZSwgKG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgZXJyb3JzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjaGVja05vZGUobm9kZS5jaGlsZHJlbltpXSwgZXJyb3JzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAyKSB7XG4gICAgY2hlY2tFeHByZXNzaW9uKG5vZGUuZXhwcmVzc2lvbiwgbm9kZS50ZXh0LCBlcnJvcnMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRXZlbnQgKGV4cCwgdGV4dCwgZXJyb3JzKSB7XG4gIHZhciBzdGlwcGVkID0gZXhwLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpO1xuICB2YXIga2V5d29yZE1hdGNoID0gc3RpcHBlZC5tYXRjaCh1bmFyeU9wZXJhdG9yc1JFKTtcbiAgaWYgKGtleXdvcmRNYXRjaCAmJiBzdGlwcGVkLmNoYXJBdChrZXl3b3JkTWF0Y2guaW5kZXggLSAxKSAhPT0gJyQnKSB7XG4gICAgZXJyb3JzLnB1c2goXG4gICAgICBcImF2b2lkIHVzaW5nIEphdmFTY3JpcHQgdW5hcnkgb3BlcmF0b3IgYXMgcHJvcGVydHkgbmFtZTogXCIgK1xuICAgICAgXCJcXFwiXCIgKyAoa2V5d29yZE1hdGNoWzBdKSArIFwiXFxcIiBpbiBleHByZXNzaW9uIFwiICsgKHRleHQudHJpbSgpKVxuICAgICk7XG4gIH1cbiAgY2hlY2tFeHByZXNzaW9uKGV4cCwgdGV4dCwgZXJyb3JzKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tGb3IgKG5vZGUsIHRleHQsIGVycm9ycykge1xuICBjaGVja0V4cHJlc3Npb24obm9kZS5mb3IgfHwgJycsIHRleHQsIGVycm9ycyk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLmFsaWFzLCAndi1mb3IgYWxpYXMnLCB0ZXh0LCBlcnJvcnMpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5pdGVyYXRvcjEsICd2LWZvciBpdGVyYXRvcicsIHRleHQsIGVycm9ycyk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMiwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgZXJyb3JzKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tJZGVudGlmaWVyIChcbiAgaWRlbnQsXG4gIHR5cGUsXG4gIHRleHQsXG4gIGVycm9yc1xuKSB7XG4gIGlmICh0eXBlb2YgaWRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBGdW5jdGlvbigoXCJ2YXIgXCIgKyBpZGVudCArIFwiPV9cIikpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9ycy5wdXNoKChcImludmFsaWQgXCIgKyB0eXBlICsgXCIgXFxcIlwiICsgaWRlbnQgKyBcIlxcXCIgaW4gZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpKSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRXhwcmVzc2lvbiAoZXhwLCB0ZXh0LCBlcnJvcnMpIHtcbiAgdHJ5IHtcbiAgICBuZXcgRnVuY3Rpb24oKFwicmV0dXJuIFwiICsgZXhwKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB2YXIga2V5d29yZE1hdGNoID0gZXhwLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpLm1hdGNoKHByb2hpYml0ZWRLZXl3b3JkUkUpO1xuICAgIGlmIChrZXl3b3JkTWF0Y2gpIHtcbiAgICAgIGVycm9ycy5wdXNoKFxuICAgICAgICBcImF2b2lkIHVzaW5nIEphdmFTY3JpcHQga2V5d29yZCBhcyBwcm9wZXJ0eSBuYW1lOiBcIiArXG4gICAgICAgIFwiXFxcIlwiICsgKGtleXdvcmRNYXRjaFswXSkgKyBcIlxcXCJcXG4gIFJhdyBleHByZXNzaW9uOiBcIiArICh0ZXh0LnRyaW0oKSlcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9ycy5wdXNoKFxuICAgICAgICBcImludmFsaWQgZXhwcmVzc2lvbjogXCIgKyAoZS5tZXNzYWdlKSArIFwiIGluXFxuXFxuXCIgK1xuICAgICAgICBcIiAgICBcIiArIGV4cCArIFwiXFxuXFxuXCIgK1xuICAgICAgICBcIiAgUmF3IGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSArIFwiXFxuXCJcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbiAoY29kZSwgZXJyb3JzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbihjb2RlKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnJvcnMucHVzaCh7IGVycjogZXJyLCBjb2RlOiBjb2RlIH0pO1xuICAgIHJldHVybiBub29wXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcGlsZVRvRnVuY3Rpb25GbiAoY29tcGlsZSkge1xuICB2YXIgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIHJldHVybiBmdW5jdGlvbiBjb21waWxlVG9GdW5jdGlvbnMgKFxuICAgIHRlbXBsYXRlLFxuICAgIG9wdGlvbnMsXG4gICAgdm1cbiAgKSB7XG4gICAgb3B0aW9ucyA9IGV4dGVuZCh7fSwgb3B0aW9ucyk7XG4gICAgdmFyIHdhcm4kJDEgPSBvcHRpb25zLndhcm4gfHwgd2FybjtcbiAgICBkZWxldGUgb3B0aW9ucy53YXJuO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAge1xuICAgICAgLy8gZGV0ZWN0IHBvc3NpYmxlIENTUCByZXN0cmljdGlvblxuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gMScpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZS50b1N0cmluZygpLm1hdGNoKC91bnNhZmUtZXZhbHxDU1AvKSkge1xuICAgICAgICAgIHdhcm4kJDEoXG4gICAgICAgICAgICAnSXQgc2VlbXMgeW91IGFyZSB1c2luZyB0aGUgc3RhbmRhbG9uZSBidWlsZCBvZiBWdWUuanMgaW4gYW4gJyArXG4gICAgICAgICAgICAnZW52aXJvbm1lbnQgd2l0aCBDb250ZW50IFNlY3VyaXR5IFBvbGljeSB0aGF0IHByb2hpYml0cyB1bnNhZmUtZXZhbC4gJyArXG4gICAgICAgICAgICAnVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGNhbm5vdCB3b3JrIGluIHRoaXMgZW52aXJvbm1lbnQuIENvbnNpZGVyICcgK1xuICAgICAgICAgICAgJ3JlbGF4aW5nIHRoZSBwb2xpY3kgdG8gYWxsb3cgdW5zYWZlLWV2YWwgb3IgcHJlLWNvbXBpbGluZyB5b3VyICcgK1xuICAgICAgICAgICAgJ3RlbXBsYXRlcyBpbnRvIHJlbmRlciBmdW5jdGlvbnMuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjaGVjayBjYWNoZVxuICAgIHZhciBrZXkgPSBvcHRpb25zLmRlbGltaXRlcnNcbiAgICAgID8gU3RyaW5nKG9wdGlvbnMuZGVsaW1pdGVycykgKyB0ZW1wbGF0ZVxuICAgICAgOiB0ZW1wbGF0ZTtcbiAgICBpZiAoY2FjaGVba2V5XSkge1xuICAgICAgcmV0dXJuIGNhY2hlW2tleV1cbiAgICB9XG5cbiAgICAvLyBjb21waWxlXG4gICAgdmFyIGNvbXBpbGVkID0gY29tcGlsZSh0ZW1wbGF0ZSwgb3B0aW9ucyk7XG5cbiAgICAvLyBjaGVjayBjb21waWxhdGlvbiBlcnJvcnMvdGlwc1xuICAgIHtcbiAgICAgIGlmIChjb21waWxlZC5lcnJvcnMgJiYgY29tcGlsZWQuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICB3YXJuJCQxKFxuICAgICAgICAgIFwiRXJyb3IgY29tcGlsaW5nIHRlbXBsYXRlOlxcblxcblwiICsgdGVtcGxhdGUgKyBcIlxcblxcblwiICtcbiAgICAgICAgICBjb21waWxlZC5lcnJvcnMubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiAoXCItIFwiICsgZSk7IH0pLmpvaW4oJ1xcbicpICsgJ1xcbicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb21waWxlZC50aXBzICYmIGNvbXBpbGVkLnRpcHMubGVuZ3RoKSB7XG4gICAgICAgIGNvbXBpbGVkLnRpcHMuZm9yRWFjaChmdW5jdGlvbiAobXNnKSB7IHJldHVybiB0aXAobXNnLCB2bSk7IH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHR1cm4gY29kZSBpbnRvIGZ1bmN0aW9uc1xuICAgIHZhciByZXMgPSB7fTtcbiAgICB2YXIgZm5HZW5FcnJvcnMgPSBbXTtcbiAgICByZXMucmVuZGVyID0gY3JlYXRlRnVuY3Rpb24oY29tcGlsZWQucmVuZGVyLCBmbkdlbkVycm9ycyk7XG4gICAgcmVzLnN0YXRpY1JlbmRlckZucyA9IGNvbXBpbGVkLnN0YXRpY1JlbmRlckZucy5tYXAoZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbihjb2RlLCBmbkdlbkVycm9ycylcbiAgICB9KTtcblxuICAgIC8vIGNoZWNrIGZ1bmN0aW9uIGdlbmVyYXRpb24gZXJyb3JzLlxuICAgIC8vIHRoaXMgc2hvdWxkIG9ubHkgaGFwcGVuIGlmIHRoZXJlIGlzIGEgYnVnIGluIHRoZSBjb21waWxlciBpdHNlbGYuXG4gICAgLy8gbW9zdGx5IGZvciBjb2RlZ2VuIGRldmVsb3BtZW50IHVzZVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIHtcbiAgICAgIGlmICgoIWNvbXBpbGVkLmVycm9ycyB8fCAhY29tcGlsZWQuZXJyb3JzLmxlbmd0aCkgJiYgZm5HZW5FcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIHdhcm4kJDEoXG4gICAgICAgICAgXCJGYWlsZWQgdG8gZ2VuZXJhdGUgcmVuZGVyIGZ1bmN0aW9uOlxcblxcblwiICtcbiAgICAgICAgICBmbkdlbkVycm9ycy5tYXAoZnVuY3Rpb24gKHJlZikge1xuICAgICAgICAgICAgdmFyIGVyciA9IHJlZi5lcnI7XG4gICAgICAgICAgICB2YXIgY29kZSA9IHJlZi5jb2RlO1xuXG4gICAgICAgICAgICByZXR1cm4gKChlcnIudG9TdHJpbmcoKSkgKyBcIiBpblxcblxcblwiICsgY29kZSArIFwiXFxuXCIpO1xuICAgICAgICB9KS5qb2luKCdcXG4nKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAoY2FjaGVba2V5XSA9IHJlcylcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXJDcmVhdG9yIChiYXNlQ29tcGlsZSkge1xuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXIgKGJhc2VPcHRpb25zKSB7XG4gICAgZnVuY3Rpb24gY29tcGlsZSAoXG4gICAgICB0ZW1wbGF0ZSxcbiAgICAgIG9wdGlvbnNcbiAgICApIHtcbiAgICAgIHZhciBmaW5hbE9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKGJhc2VPcHRpb25zKTtcbiAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgIHZhciB0aXBzID0gW107XG4gICAgICBmaW5hbE9wdGlvbnMud2FybiA9IGZ1bmN0aW9uIChtc2csIHRpcCkge1xuICAgICAgICAodGlwID8gdGlwcyA6IGVycm9ycykucHVzaChtc2cpO1xuICAgICAgfTtcblxuICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gbWVyZ2UgY3VzdG9tIG1vZHVsZXNcbiAgICAgICAgaWYgKG9wdGlvbnMubW9kdWxlcykge1xuICAgICAgICAgIGZpbmFsT3B0aW9ucy5tb2R1bGVzID1cbiAgICAgICAgICAgIChiYXNlT3B0aW9ucy5tb2R1bGVzIHx8IFtdKS5jb25jYXQob3B0aW9ucy5tb2R1bGVzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtZXJnZSBjdXN0b20gZGlyZWN0aXZlc1xuICAgICAgICBpZiAob3B0aW9ucy5kaXJlY3RpdmVzKSB7XG4gICAgICAgICAgZmluYWxPcHRpb25zLmRpcmVjdGl2ZXMgPSBleHRlbmQoXG4gICAgICAgICAgICBPYmplY3QuY3JlYXRlKGJhc2VPcHRpb25zLmRpcmVjdGl2ZXMgfHwgbnVsbCksXG4gICAgICAgICAgICBvcHRpb25zLmRpcmVjdGl2ZXNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvcHkgb3RoZXIgb3B0aW9uc1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgICAgIGlmIChrZXkgIT09ICdtb2R1bGVzJyAmJiBrZXkgIT09ICdkaXJlY3RpdmVzJykge1xuICAgICAgICAgICAgZmluYWxPcHRpb25zW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBjb21waWxlZCA9IGJhc2VDb21waWxlKHRlbXBsYXRlLCBmaW5hbE9wdGlvbnMpO1xuICAgICAge1xuICAgICAgICBlcnJvcnMucHVzaC5hcHBseShlcnJvcnMsIGRldGVjdEVycm9ycyhjb21waWxlZC5hc3QpKTtcbiAgICAgIH1cbiAgICAgIGNvbXBpbGVkLmVycm9ycyA9IGVycm9ycztcbiAgICAgIGNvbXBpbGVkLnRpcHMgPSB0aXBzO1xuICAgICAgcmV0dXJuIGNvbXBpbGVkXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBpbGU6IGNvbXBpbGUsXG4gICAgICBjb21waWxlVG9GdW5jdGlvbnM6IGNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4oY29tcGlsZSlcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8vIGBjcmVhdGVDb21waWxlckNyZWF0b3JgIGFsbG93cyBjcmVhdGluZyBjb21waWxlcnMgdGhhdCB1c2UgYWx0ZXJuYXRpdmVcbi8vIHBhcnNlci9vcHRpbWl6ZXIvY29kZWdlbiwgZS5nIHRoZSBTU1Igb3B0aW1pemluZyBjb21waWxlci5cbi8vIEhlcmUgd2UganVzdCBleHBvcnQgYSBkZWZhdWx0IGNvbXBpbGVyIHVzaW5nIHRoZSBkZWZhdWx0IHBhcnRzLlxudmFyIGNyZWF0ZUNvbXBpbGVyID0gY3JlYXRlQ29tcGlsZXJDcmVhdG9yKGZ1bmN0aW9uIGJhc2VDb21waWxlIChcbiAgdGVtcGxhdGUsXG4gIG9wdGlvbnNcbikge1xuICB2YXIgYXN0ID0gcGFyc2UodGVtcGxhdGUudHJpbSgpLCBvcHRpb25zKTtcbiAgaWYgKG9wdGlvbnMub3B0aW1pemUgIT09IGZhbHNlKSB7XG4gICAgb3B0aW1pemUoYXN0LCBvcHRpb25zKTtcbiAgfVxuICB2YXIgY29kZSA9IGdlbmVyYXRlKGFzdCwgb3B0aW9ucyk7XG4gIHJldHVybiB7XG4gICAgYXN0OiBhc3QsXG4gICAgcmVuZGVyOiBjb2RlLnJlbmRlcixcbiAgICBzdGF0aWNSZW5kZXJGbnM6IGNvZGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cbn0pO1xuXG4vKiAgKi9cblxudmFyIHJlZiQxID0gY3JlYXRlQ29tcGlsZXIoYmFzZU9wdGlvbnMpO1xudmFyIGNvbXBpbGVUb0Z1bmN0aW9ucyA9IHJlZiQxLmNvbXBpbGVUb0Z1bmN0aW9ucztcblxuLyogICovXG5cbi8vIGNoZWNrIHdoZXRoZXIgY3VycmVudCBicm93c2VyIGVuY29kZXMgYSBjaGFyIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzXG52YXIgZGl2O1xuZnVuY3Rpb24gZ2V0U2hvdWxkRGVjb2RlIChocmVmKSB7XG4gIGRpdiA9IGRpdiB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LmlubmVySFRNTCA9IGhyZWYgPyBcIjxhIGhyZWY9XFxcIlxcblxcXCIvPlwiIDogXCI8ZGl2IGE9XFxcIlxcblxcXCIvPlwiO1xuICByZXR1cm4gZGl2LmlubmVySFRNTC5pbmRleE9mKCcmIzEwOycpID4gMFxufVxuXG4vLyAjMzY2MzogSUUgZW5jb2RlcyBuZXdsaW5lcyBpbnNpZGUgYXR0cmlidXRlIHZhbHVlcyB3aGlsZSBvdGhlciBicm93c2VycyBkb24ndFxudmFyIHNob3VsZERlY29kZU5ld2xpbmVzID0gaW5Ccm93c2VyID8gZ2V0U2hvdWxkRGVjb2RlKGZhbHNlKSA6IGZhbHNlO1xuLy8gIzY4Mjg6IGNocm9tZSBlbmNvZGVzIGNvbnRlbnQgaW4gYVtocmVmXVxudmFyIHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZiA9IGluQnJvd3NlciA/IGdldFNob3VsZERlY29kZSh0cnVlKSA6IGZhbHNlO1xuXG4vKiAgKi9cblxudmFyIGlkVG9UZW1wbGF0ZSA9IGNhY2hlZChmdW5jdGlvbiAoaWQpIHtcbiAgdmFyIGVsID0gcXVlcnkoaWQpO1xuICByZXR1cm4gZWwgJiYgZWwuaW5uZXJIVE1MXG59KTtcblxudmFyIG1vdW50ID0gVnVlLnByb3RvdHlwZS4kbW91bnQ7XG5WdWUucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIGVsID0gZWwgJiYgcXVlcnkoZWwpO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZWwgPT09IGRvY3VtZW50LmJvZHkgfHwgZWwgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIkRvIG5vdCBtb3VudCBWdWUgdG8gPGh0bWw+IG9yIDxib2R5PiAtIG1vdW50IHRvIG5vcm1hbCBlbGVtZW50cyBpbnN0ZWFkLlwiXG4gICAgKTtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgdmFyIG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zO1xuICAvLyByZXNvbHZlIHRlbXBsYXRlL2VsIGFuZCBjb252ZXJ0IHRvIHJlbmRlciBmdW5jdGlvblxuICBpZiAoIW9wdGlvbnMucmVuZGVyKSB7XG4gICAgdmFyIHRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZTtcbiAgICBpZiAodGVtcGxhdGUpIHtcbiAgICAgIGlmICh0eXBlb2YgdGVtcGxhdGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh0ZW1wbGF0ZS5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgICAgIHRlbXBsYXRlID0gaWRUb1RlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgIXRlbXBsYXRlKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAoXCJUZW1wbGF0ZSBlbGVtZW50IG5vdCBmb3VuZCBvciBpcyBlbXB0eTogXCIgKyAob3B0aW9ucy50ZW1wbGF0ZSkpLFxuICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0ZW1wbGF0ZS5ub2RlVHlwZSkge1xuICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLmlubmVySFRNTDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHtcbiAgICAgICAgICB3YXJuKCdpbnZhbGlkIHRlbXBsYXRlIG9wdGlvbjonICsgdGVtcGxhdGUsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbCkge1xuICAgICAgdGVtcGxhdGUgPSBnZXRPdXRlckhUTUwoZWwpO1xuICAgIH1cbiAgICBpZiAodGVtcGxhdGUpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICAgIG1hcmsoJ2NvbXBpbGUnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZiA9IGNvbXBpbGVUb0Z1bmN0aW9ucyh0ZW1wbGF0ZSwge1xuICAgICAgICBzaG91bGREZWNvZGVOZXdsaW5lczogc2hvdWxkRGVjb2RlTmV3bGluZXMsXG4gICAgICAgIHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZjogc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmLFxuICAgICAgICBkZWxpbWl0ZXJzOiBvcHRpb25zLmRlbGltaXRlcnMsXG4gICAgICAgIGNvbW1lbnRzOiBvcHRpb25zLmNvbW1lbnRzXG4gICAgICB9LCB0aGlzKTtcbiAgICAgIHZhciByZW5kZXIgPSByZWYucmVuZGVyO1xuICAgICAgdmFyIHN0YXRpY1JlbmRlckZucyA9IHJlZi5zdGF0aWNSZW5kZXJGbnM7XG4gICAgICBvcHRpb25zLnJlbmRlciA9IHJlbmRlcjtcbiAgICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gc3RhdGljUmVuZGVyRm5zO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICBtYXJrKCdjb21waWxlIGVuZCcpO1xuICAgICAgICBtZWFzdXJlKChcInZ1ZSBcIiArICh0aGlzLl9uYW1lKSArIFwiIGNvbXBpbGVcIiksICdjb21waWxlJywgJ2NvbXBpbGUgZW5kJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtb3VudC5jYWxsKHRoaXMsIGVsLCBoeWRyYXRpbmcpXG59O1xuXG4vKipcbiAqIEdldCBvdXRlckhUTUwgb2YgZWxlbWVudHMsIHRha2luZyBjYXJlXG4gKiBvZiBTVkcgZWxlbWVudHMgaW4gSUUgYXMgd2VsbC5cbiAqL1xuZnVuY3Rpb24gZ2V0T3V0ZXJIVE1MIChlbCkge1xuICBpZiAoZWwub3V0ZXJIVE1MKSB7XG4gICAgcmV0dXJuIGVsLm91dGVySFRNTFxuICB9IGVsc2Uge1xuICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwuY2xvbmVOb2RlKHRydWUpKTtcbiAgICByZXR1cm4gY29udGFpbmVyLmlubmVySFRNTFxuICB9XG59XG5cblZ1ZS5jb21waWxlID0gY29tcGlsZVRvRnVuY3Rpb25zO1xuXG5yZXR1cm4gVnVlO1xuXG59KSkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYXNzZXRzL2pzL3Z1ZS5qcyIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanMiLCJ2YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7XG4gIGlmICh0aW1lb3V0KSB7XG4gICAgdGltZW91dC5jbG9zZSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHdpbmRvdywgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIHNldGltbWVkaWF0ZSBhdHRhY2hlcyBpdHNlbGYgdG8gdGhlIGdsb2JhbCBvYmplY3RcbnJlcXVpcmUoXCJzZXRpbW1lZGlhdGVcIik7XG5leHBvcnRzLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyJdLCJzb3VyY2VSb290IjoiIn0=